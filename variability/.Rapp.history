hierlm(Sepal.Length ~ 0 + Petal.Length + Species + Sepal.Width : Species | Species - . | Sepal.Width : Species - ., iris, c(1, 2))
#' Combine two formulas in hierlm-format#
#'#
#' Return the left and right side of a new combined formula.#
#' Left formula must be a standard formula.  Right formula may take the following forms:#
#' y ~ ... : an lm-style formula; the left-hand-side variables much match#
#' f - b : A requirement that two variables be close together (typically one is a factor)#
#' f - . : A requirement that a variable (or set of factors) be close to a new hyper-variable#
#' a : f - [b or .] : A requirement that the results of an interaction be near a hyper-variable#
#' TODO:#
#' a + B : A requirement that the factors in 'a' are similar to eachother by smoothness 'B'#
#'#
#' @param formula1 an lm-style formula#
#' @param formula2 an additional formula or hierlm term#
#' @return Augmented formula#
#' @examples#
#' combine.formulae(combine.formulae(combine.formulae(y ~ a + b, "b - c"), y ~ c + d), "c : d - .")#
#
combine.formulae <- function(formula1, formula2, sep="") {#
    chunks1 <- as.character(formula1)#
#
    if (is.character(formula2))#
        if (grepl("~", formula2))#
            formula2 <- as.formula(formula2)#
#
    if (class(formula2) == "formula") {#
        chunks2 <- as.character(formula2)#
        if (chunks2[2] != chunks1[2])#
            error("Left-hand-side variables do not match.")#
#
        terms1 <- get.formula.terms(formula1)#
        terms2 <- get.formula.terms(formula2)#
    } else {#
        print("yy")#
        terms2 <- get.hyper.terms(formula2, sep=sep)#
        if (length(terms2) != 3)#
            error(paste("Cannot understand expression:", formula2))#
#
        terms2 <- terms2[-3]#
#
        terms1 <- get.formula.terms(formula1)#
        print("uu")#
        print(formula1)#
        print(attr(terms(formula1), 'intercept'))#
        if (attr(terms(formula1), 'intercept') == 0) {#
            print("ss")#
            if (!("0" %in% terms1))#
                terms1 <- c("0", terms1)#
        } else {#
            if (!("0" %in% terms1 && "constant" %in% terms1))#
                terms1 <- c("0", "constant", terms1)#
        }#
    }#
#
    print("tt")#
    for (term in terms2)#
        if (!(term %in% terms1))#
            terms1 <- c(terms1, term)#
#
    as.formula(paste(chunks1[2], "~", paste(terms1, collapse=" + ")),#
               env=attr(formula1, '.Environment'))#
}
hierlm(Sepal.Length ~ 0 + Petal.Length + Species + Sepal.Width : Species | Species - . | Sepal.Width : Species - ., iris, c(1, 2))
#' Combine two formulas in hierlm-format#
#'#
#' Return the left and right side of a new combined formula.#
#' Left formula must be a standard formula.  Right formula may take the following forms:#
#' y ~ ... : an lm-style formula; the left-hand-side variables much match#
#' f - b : A requirement that two variables be close together (typically one is a factor)#
#' f - . : A requirement that a variable (or set of factors) be close to a new hyper-variable#
#' a : f - [b or .] : A requirement that the results of an interaction be near a hyper-variable#
#' TODO:#
#' a + B : A requirement that the factors in 'a' are similar to eachother by smoothness 'B'#
#'#
#' @param formula1 an lm-style formula#
#' @param formula2 an additional formula or hierlm term#
#' @return Augmented formula#
#' @examples#
#' combine.formulae(combine.formulae(combine.formulae(y ~ a + b, "b - c"), y ~ c + d), "c : d - .")#
#
combine.formulae <- function(formula1, formula2, sep="") {#
    chunks1 <- as.character(formula1)#
#
    if (is.character(formula2))#
        if (grepl("~", formula2))#
            formula2 <- as.formula(formula2)#
#
    if (class(formula2) == "formula") {#
        chunks2 <- as.character(formula2)#
        if (chunks2[2] != chunks1[2])#
            error("Left-hand-side variables do not match.")#
#
        terms1 <- get.formula.terms(formula1)#
        terms2 <- get.formula.terms(formula2)#
    } else {#
        print("yy")#
        terms2 <- get.hyper.terms(formula2, sep=sep)#
        if (length(terms2) != 3)#
            error(paste("Cannot understand expression:", formula2))#
#
        terms2 <- terms2[-3]#
#
        terms1 <- get.formula.terms(formula1)#
        print("uu")#
        print(class(formula1))#
        print(attr(terms(formula1), 'intercept'))#
        if (attr(terms(formula1), 'intercept') == 0) {#
            print("ss")#
            if (!("0" %in% terms1))#
                terms1 <- c("0", terms1)#
        } else {#
            if (!("0" %in% terms1 && "constant" %in% terms1))#
                terms1 <- c("0", "constant", terms1)#
        }#
    }#
#
    print("tt")#
    for (term in terms2)#
        if (!(term %in% terms1))#
            terms1 <- c(terms1, term)#
#
    as.formula(paste(chunks1[2], "~", paste(terms1, collapse=" + ")),#
               env=attr(formula1, '.Environment'))#
}
hierlm(Sepal.Length ~ 0 + Petal.Length + Species + Sepal.Width : Species | Species - . | Sepal.Width : Species - ., iris, c(1, 2))
#' Replace a factor term#
#'#
#' Constructs indicator terms for a factor variable.#
#'#
#' @param name term name#
#' @param formula formula#
#' @param sep paste sep used to construct factor names#
#' @return Modified formula#
#' @examples#
#' replace.factor.formula("Species", Sepal.Length ~ Species)#
#' replace.factor.formula("Species", Sepal.Length ~ Petal.Length : Species)#
#
replace.factor.formula <- function(name, formula, data, sep="") {#
    terms <- c()#
#
    for (term in get.formula.terms(formula)) {#
        if (term == name) {#
            terms <- c(terms, make.factor.names(name, data))#
        } else if (grepl(':', term)) {#
            subterms <- split.interaction.term(term)#
            if (subterms[1] == name) {#
                terms <- c(terms, paste(make.factor.names(subterms[1], data), subterms[2], sep=':'))#
            } else if (subterms[2] == name) {#
                terms <- c(terms, paste(subterms[1], make.factor.names(subterms[2], data), sep=':'))#
            } else {#
                terms <- c(terms, term)#
            }#
        } else {#
            terms <- c(terms, term)#
        }#
    }#
#
    chunks <- as.character(formula)#
    as.formula(paste(chunks[2], paste(terms, collapse=" + "), sep=" ~ "))#
}
hierlm(Sepal.Length ~ 0 + Petal.Length + Species + Sepal.Width : Species | Species - . | Sepal.Width : Species - ., iris, c(1, 2))
#' Combine two formulas in hierlm-format#
#'#
#' Return the left and right side of a new combined formula.#
#' Left formula must be a standard formula.  Right formula may take the following forms:#
#' y ~ ... : an lm-style formula; the left-hand-side variables much match#
#' f - b : A requirement that two variables be close together (typically one is a factor)#
#' f - . : A requirement that a variable (or set of factors) be close to a new hyper-variable#
#' a : f - [b or .] : A requirement that the results of an interaction be near a hyper-variable#
#' TODO:#
#' a + B : A requirement that the factors in 'a' are similar to eachother by smoothness 'B'#
#'#
#' @param formula1 an lm-style formula#
#' @param formula2 an additional formula or hierlm term#
#' @return Augmented formula#
#' @examples#
#' combine.formulae(combine.formulae(combine.formulae(y ~ a + b, "b - c"), y ~ c + d), "c : d - .")#
#
combine.formulae <- function(formula1, formula2, sep="") {#
    chunks1 <- as.character(formula1)#
#
    if (is.character(formula2))#
        if (grepl("~", formula2))#
            formula2 <- as.formula(formula2)#
#
    if (class(formula2) == "formula") {#
        chunks2 <- as.character(formula2)#
        if (chunks2[2] != chunks1[2])#
            error("Left-hand-side variables do not match.")#
#
        terms1 <- get.formula.terms(formula1)#
        terms2 <- get.formula.terms(formula2)#
    } else {#
        terms2 <- get.hyper.terms(formula2, sep=sep)#
        if (length(terms2) != 3)#
            error(paste("Cannot understand expression:", formula2))#
#
        terms2 <- terms2[-3]#
#
        terms1 <- get.formula.terms(formula1)#
        if (attr(terms(formula1), 'intercept') == 0) {#
            if (!("0" %in% terms1))#
                terms1 <- c("0", terms1)#
        } else {#
            if (!("0" %in% terms1 && "constant" %in% terms1))#
                terms1 <- c("0", "constant", terms1)#
        }#
    }#
#
    for (term in terms2)#
        if (!(term %in% terms1))#
            terms1 <- c(terms1, term)#
#
    as.formula(paste(chunks1[2], "~", paste(terms1, collapse=" + ")),#
               env=attr(formula1, '.Environment'))#
}
hierlm(Sepal.Length ~ 0 + Petal.Length + Species + Sepal.Width : Species | Species - . | Sepal.Width : Species - ., iris, c(1, 2))
#' Fit an hierarchical model#
#'#
#' Interpret a hierarchical formula and fit it with the given data and weight ratios.#
#'#
#' @param formula an hierlm-style formula#
#' @param datas a data frame or a list of data frames, for each lm-style formula contained in the hierlm#
#' @param ratios a vector a ratios for the effect of fictional#
#'   observations, with length as large as the number of hyper#
#'   expressions.#
#' @return A fitted lm model#
#' @examples#
#' hierlm(Sepal.Length ~ 0 + Petal.Length + Species + Sepal.Width : Species | Species - ., iris, 1)#
#' hierlm(Sepal.Length ~ 0 + Petal.Length + Species + Sepal.Width : Species | Species - . | Sepal.Width : Species - ., iris, c(1, 2))#
#
hierlm <- function(formula, datas, ratios, sep="") {#
    if (is.data.frame(datas))#
        datas <- list(datas)#
#
    data.ii <- 1#
    ratio.ii <- 1#
#
    data <- datas[[data.ii]]#
#
    ## Split the formula by |#
    labels <- attr(terms(formula), 'term.labels')#
    if (length(labels) == 1) { # otherwise it's just an lm formula#
        lhs <- as.character(formula)[2]#
        chunks <- strsplit(labels, "\\|")[[1]]#
        formula <- as.formula(paste(lhs, "~", chunks[1]), env=attr(formula, '.Environment'))#
        ## Keep this for weight calculations#
        oldformula <- formula#
        for (chunk in chunks[-1]) {#
            print(chunk)#
            ## Keep these around#
            olddata <- data#
#
            ## Make the new formula#
            formula <- combine.formulae(formula, chunk)#
            print("vv")#
            if (!("constant" %in% names(data)) && "constant" %in% get.formula.terms(formula))#
                data$constant <- 1#
#
            print("xx")#
#
            terms <- get.hyper.terms(chunk)#
            if (length(terms) == 3) {#
                print("ab")#
                ## Build the new relationship#
                weight <- calc.fo.weights(oldformula, terms[1], ratios[ratio.ii], datas[[data.ii]]) # use original data#
                print("ao")#
                extras <- make.hyper.rows(terms[1], terms[2], weight, datas[[data.ii]])#
#
                ## Done with this ratio#
                ratio.ii <- ratio.ii + 1#
#
                ## Create indicators for nonhyper, if not already done#
                if (terms[1] %in% data)#
                    data <- replace.factor(terms[1], data, 1, sep=sep)#
#
                data <- combine.data.frames(data, extras)#
            } else {#
                ## Add in the next formula#
                data.ii <- data.ii + 1#
                data <- combine.data.frame(data, datas[[data.ii]])#
            }#
#
            ## Have any of the terms in the formula been factorized?#
            checks <- get.formula.terms(formula)#
            for (check in checks) {#
                if (check %in% names(olddata) && is.factor(olddata[, check]))#
                    formula <- replace.factor.formula(check, formula, olddata)#
            }#
        }#
    }#
#
    print(head(data))#
    print(tail(data))#
    print(formula)#
    lm(formula, data=data)#
}
hierlm(Sepal.Length ~ 0 + Petal.Length + Species + Sepal.Width : Species | Species - . | Sepal.Width : Species - ., iris, c(1, 2))
#' Fit an hierarchical model#
#'#
#' Interpret a hierarchical formula and fit it with the given data and weight ratios.#
#'#
#' @param formula an hierlm-style formula#
#' @param datas a data frame or a list of data frames, for each lm-style formula contained in the hierlm#
#' @param ratios a vector a ratios for the effect of fictional#
#'   observations, with length as large as the number of hyper#
#'   expressions.#
#' @return A fitted lm model#
#' @examples#
#' hierlm(Sepal.Length ~ 0 + Petal.Length + Species + Sepal.Width : Species | Species - ., iris, 1)#
#' hierlm(Sepal.Length ~ 0 + Petal.Length + Species + Sepal.Width : Species | Species - . | Sepal.Width : Species - ., iris, c(1, 2))#
#
hierlm <- function(formula, datas, ratios, sep="") {#
    if (is.data.frame(datas))#
        datas <- list(datas)#
#
    data.ii <- 1#
    ratio.ii <- 1#
#
    data <- datas[[data.ii]]#
#
    ## Split the formula by |#
    labels <- attr(terms(formula), 'term.labels')#
    if (length(labels) == 1) { # otherwise it's just an lm formula#
        lhs <- as.character(formula)[2]#
        chunks <- strsplit(labels, "\\|")[[1]]#
        formula <- as.formula(paste(lhs, "~", chunks[1]), env=attr(formula, '.Environment'))#
        ## Keep this for weight calculations#
        oldformula <- formula#
        for (chunk in chunks[-1]) {#
            print(chunk)#
            ## Keep these around#
            olddata <- data#
#
            ## Make the new formula#
            formula <- combine.formulae(formula, chunk)#
            print("vv")#
            if (!("constant" %in% names(data)) && "constant" %in% get.formula.terms(formula))#
                data$constant <- 1#
#
            print("xx")#
#
            terms <- get.hyper.terms(chunk)#
            if (length(terms) == 3) {#
                print("ab")#
                ## Build the new relationship#
                weight <- calc.fo.weights(oldformula, terms[1], ratios[ratio.ii], datas[[data.ii]]) # use original data#
                print("ao")#
                print(terms)#
                extras <- make.hyper.rows(terms[1], terms[2], weight, datas[[data.ii]])#
#
                ## Done with this ratio#
                ratio.ii <- ratio.ii + 1#
#
                ## Create indicators for nonhyper, if not already done#
                if (terms[1] %in% data)#
                    data <- replace.factor(terms[1], data, 1, sep=sep)#
#
                data <- combine.data.frames(data, extras)#
            } else {#
                ## Add in the next formula#
                data.ii <- data.ii + 1#
                data <- combine.data.frame(data, datas[[data.ii]])#
            }#
#
            ## Have any of the terms in the formula been factorized?#
            checks <- get.formula.terms(formula)#
            for (check in checks) {#
                if (check %in% names(olddata) && is.factor(olddata[, check]))#
                    formula <- replace.factor.formula(check, formula, olddata)#
            }#
        }#
    }#
#
    print(head(data))#
    print(tail(data))#
    print(formula)#
    lm(formula, data=data)#
}
hierlm(Sepal.Length ~ 0 + Petal.Length + Species + Sepal.Width : Species | Species - . | Sepal.Width : Species - ., iris, c(1, 2))
make.hyper.rows("Species", "hyperSpecies", 5, iris)
#' Get any new hyper terms from formula#
#'#
#' If the "a - b" formula requires the creation of a new hyper terms#
#' (one of a or b is .), return them.#
#'#
#' @param formula Single component of a hierlm formula#
#' @return Vector of c(nonhyper, hyper, is.interaction), if a new one was created;#
#'   or c(left, right, NA) if both terms are given;#
#'   or c() if not an "a - b" expression#
#' @examples#
#' get.hyper.terms(Sepal.Length ~ Petal.Length + Species + Sepal.Width : Species)#
#
get.hyper.terms <- function(formula, sep="") {#
    if (class(formula) == "formula")#
        return(c())#
#
    terms <- strsplit(formula, "-")[[1]]#
    if (length(terms) != 2)#
        return(c())#
#
    terms <- gsub("^\\s+|\\s+$", "", terms)#
    if ("." %in% terms) {#
        nonhyper <- terms[terms != "."]#
        if (grepl(':', nonhyper)) {#
            subterms <- split.interaction.term(nonhyper)#
            hyper <- paste("hyper", paste(subterms, collapse=sep), sep=sep)#
            return(c(nonhyper, hyper, T))#
        } else {#
            hyper <- paste("hyper", nonhyper, sep=sep)#
            return(c(nonhyper, hyper, F))#
        }#
    }#
    return(c(terms, NA))#
}
get.hyper.terms(Sepal.Length ~ Petal.Length + Species + Sepal.Width : Species)
#' Create fictional observations for a hyper relationship#
#'#
#' Return a data frame with fictional observations#
#'#
#' @param nonhyper name of the non-hyper column#
#' @param hyper name of the hyper column#
#' @param weight weight to be used in the rows#
#' @param data a data frame for inspecting levels#
#' @return Fictional observations in a data frame#
#' @examples#
#' make.hyper.rows("Species", "hyperSpecies", 5, iris)#
#
make.hyper.rows <- function(nonhyper, hyper, weight, data, sep="") {#
    if (grepl(':', nonhyper)) {#
        for (subterm in split.interaction.term(nonhyper)) {#
            if (!is.numeric(data[, subterm]))#
                return(make.hyper.rows(subterm, hyper))#
        }#
    } else {#
        ## Construct extra from diagonal factor matrix#
        extras <- diag(weight, length(unique(data[, nonhyper])))#
        extras <- as.data.frame(extras)#
#
        names(extras) <- paste(nonhyper, unique(data[, nonhyper]), sep=sep)#
#
        ## Add in the hyper column#
        extras[, hyper] <- -weight#
#
        extras#
    }#
}
hierlm(Sepal.Length ~ 0 + Petal.Length + Species + Sepal.Width : Species | Species - . | Sepal.Width : Species - ., iris, c(1, 2))
#' Create fictional observations for a hyper relationship#
#'#
#' Return a data frame with fictional observations#
#'#
#' @param nonhyper name of the non-hyper column#
#' @param hyper name of the hyper column#
#' @param weight weight to be used in the rows#
#' @param data a data frame for inspecting levels#
#' @return Fictional observations in a data frame#
#' @examples#
#' make.hyper.rows("Species", "hyperSpecies", 5, iris)#
#
make.hyper.rows <- function(nonhyper, hyper, weight, data, sep="") {#
    if (grepl(':', nonhyper)) {#
        for (subterm in split.interaction.term(nonhyper)) {#
            if (!is.numeric(data[, subterm]))#
                return(make.hyper.rows(subterm, hyper, weight, data))#
        }#
    } else {#
        ## Construct extra from diagonal factor matrix#
        extras <- diag(weight, length(unique(data[, nonhyper])))#
        extras <- as.data.frame(extras)#
#
        names(extras) <- paste(nonhyper, unique(data[, nonhyper]), sep=sep)#
#
        ## Add in the hyper column#
        extras[, hyper] <- -weight#
#
        extras#
    }#
}
hierlm(Sepal.Length ~ 0 + Petal.Length + Species + Sepal.Width : Species | Species - . | Sepal.Width : Species - ., iris, c(1, 2))
#' Fit an hierarchical model#
#'#
#' Interpret a hierarchical formula and fit it with the given data and weight ratios.#
#'#
#' @param formula an hierlm-style formula#
#' @param datas a data frame or a list of data frames, for each lm-style formula contained in the hierlm#
#' @param ratios a vector a ratios for the effect of fictional#
#'   observations, with length as large as the number of hyper#
#'   expressions.#
#' @return A fitted lm model#
#' @examples#
#' hierlm(Sepal.Length ~ 0 + Petal.Length + Species + Sepal.Width : Species | Species - ., iris, 1)#
#' hierlm(Sepal.Length ~ 0 + Petal.Length + Species + Sepal.Width : Species | Species - . | Sepal.Width : Species - ., iris, c(1, 2))#
#
hierlm <- function(formula, datas, ratios, sep="") {#
    if (is.data.frame(datas))#
        datas <- list(datas)#
#
    data.ii <- 1#
    ratio.ii <- 1#
#
    data <- datas[[data.ii]]#
#
    ## Split the formula by |#
    labels <- attr(terms(formula), 'term.labels')#
    if (length(labels) == 1) { # otherwise it's just an lm formula#
        lhs <- as.character(formula)[2]#
        chunks <- strsplit(labels, "\\|")[[1]]#
        formula <- as.formula(paste(lhs, "~", chunks[1]), env=attr(formula, '.Environment'))#
        ## Keep this for weight calculations#
        oldformula <- formula#
        for (chunk in chunks[-1]) {#
            print(chunk)#
            ## Keep these around#
            olddata <- data#
#
            ## Make the new formula#
            formula <- combine.formulae(formula, chunk)#
            print("vv")#
            if (!("constant" %in% names(data)) && "constant" %in% get.formula.terms(formula))#
                data$constant <- 1#
#
            print("xx")#
#
            terms <- get.hyper.terms(chunk)#
            if (length(terms) == 3) {#
                print("ab")#
                ## Build the new relationship#
                weight <- calc.fo.weights(oldformula, terms[1], ratios[ratio.ii], datas[[data.ii]]) # use original data#
                print("ao")#
                print(terms)#
                extras <- make.hyper.rows(terms[1], terms[2], weight, datas[[data.ii]])#
#
                ## Done with this ratio#
                ratio.ii <- ratio.ii + 1#
#
                ## Create indicators for nonhyper, if not already done#
                if (terms[1] %in% data)#
                    data <- replace.factor(terms[1], data, 1, sep=sep)#
#
                data <- combine.data.frames(data, extras)#
            } else {#
                ## Add in the next formula#
                data.ii <- data.ii + 1#
                data <- combine.data.frame(data, datas[[data.ii]])#
            }#
#
            ## Have any of the terms in the formula been factorized?#
            checks <- get.formula.terms(formula)#
            for (check in checks) {#
                if (check %in% names(olddata) && !is.character(olddata[, check]))#
                    formula <- replace.factor.formula(check, formula, olddata)#
            }#
        }#
    }#
#
    print(head(data))#
    print(tail(data))#
    print(formula)#
    lm(formula, data=data)#
}
hierlm(Sepal.Length ~ 0 + Petal.Length + Species + Sepal.Width : Species | Species - . | Sepal.Width : Species - ., iris, c(1, 2))
#' Fit an hierarchical model#
#'#
#' Interpret a hierarchical formula and fit it with the given data and weight ratios.#
#'#
#' @param formula an hierlm-style formula#
#' @param datas a data frame or a list of data frames, for each lm-style formula contained in the hierlm#
#' @param ratios a vector a ratios for the effect of fictional#
#'   observations, with length as large as the number of hyper#
#'   expressions.#
#' @return A fitted lm model#
#' @examples#
#' hierlm(Sepal.Length ~ 0 + Petal.Length + Species + Sepal.Width : Species | Species - ., iris, 1)#
#' hierlm(Sepal.Length ~ 0 + Petal.Length + Species + Sepal.Width : Species | Species - . | Sepal.Width : Species - ., iris, c(1, 2))#
#
hierlm <- function(formula, datas, ratios, sep="") {#
    if (is.data.frame(datas))#
        datas <- list(datas)#
#
    data.ii <- 1#
    ratio.ii <- 1#
#
    data <- datas[[data.ii]]#
#
    ## Split the formula by |#
    labels <- attr(terms(formula), 'term.labels')#
    if (length(labels) == 1) { # otherwise it's just an lm formula#
        lhs <- as.character(formula)[2]#
        chunks <- strsplit(labels, "\\|")[[1]]#
        formula <- as.formula(paste(lhs, "~", chunks[1]), env=attr(formula, '.Environment'))#
        ## Keep this for weight calculations#
        oldformula <- formula#
        for (chunk in chunks[-1]) {#
            print(chunk)#
            ## Keep these around#
            olddata <- data#
#
            ## Make the new formula#
            formula <- combine.formulae(formula, chunk)#
            print("vv")#
            if (!("constant" %in% names(data)) && "constant" %in% get.formula.terms(formula))#
                data$constant <- 1#
#
            print("xx")#
#
            terms <- get.hyper.terms(chunk)#
            if (length(terms) == 3) {#
                print("ab")#
                ## Build the new relationship#
                weight <- calc.fo.weights(oldformula, terms[1], ratios[ratio.ii], datas[[data.ii]]) # use original data#
                print("ao")#
                print(terms)#
                extras <- make.hyper.rows(terms[1], terms[2], weight, datas[[data.ii]])#
#
                ## Done with this ratio#
                ratio.ii <- ratio.ii + 1#
#
                ## Create indicators for nonhyper, if not already done#
                if (terms[1] %in% data)#
                    data <- replace.factor(terms[1], data, 1, sep=sep)#
#
                data <- combine.data.frames(data, extras)#
            } else {#
                ## Add in the next formula#
                data.ii <- data.ii + 1#
                data <- combine.data.frame(data, datas[[data.ii]])#
            }#
#
            ## Have any of the terms in the formula been factorized?#
            checks <- get.formula.terms(formula)#
            for (check in checks) {#
                if (check %in% names(olddata) && !is.numeric(olddata[, check]))#
                    formula <- replace.factor.formula(check, formula, olddata)#
            }#
        }#
    }#
#
    print(head(data))#
    print(tail(data))#
    print(formula)#
    lm(formula, data=data)#
}
hierlm(Sepal.Length ~ 0 + Petal.Length + Species + Sepal.Width : Species | Species - . | Sepal.Width : Species - ., iris, c(1, 2))
#' Fit an hierarchical model#
#'#
#' Interpret a hierarchical formula and fit it with the given data and weight ratios.#
#'#
#' @param formula an hierlm-style formula#
#' @param datas a data frame or a list of data frames, for each lm-style formula contained in the hierlm#
#' @param ratios a vector a ratios for the effect of fictional#
#'   observations, with length as large as the number of hyper#
#'   expressions.#
#' @return A fitted lm model#
#' @examples#
#' hierlm(Sepal.Length ~ 0 + Petal.Length + Species + Sepal.Width : Species | Species - ., iris, 1)#
#' hierlm(Sepal.Length ~ 0 + Petal.Length + Species + Sepal.Width : Species | Species - . | Sepal.Width : Species - ., iris, c(1, 2))#
#
hierlm <- function(formula, datas, ratios, sep="") {#
    if (is.data.frame(datas))#
        datas <- list(datas)#
#
    data.ii <- 1#
    ratio.ii <- 1#
#
    data <- datas[[data.ii]]#
#
    ## Split the formula by |#
    labels <- attr(terms(formula), 'term.labels')#
    if (length(labels) == 1) { # otherwise it's just an lm formula#
        lhs <- as.character(formula)[2]#
        chunks <- strsplit(labels, "\\|")[[1]]#
        formula <- as.formula(paste(lhs, "~", chunks[1]), env=attr(formula, '.Environment'))#
        ## Keep this for weight calculations#
        oldformula <- formula#
        for (chunk in chunks[-1]) {#
            print(chunk)#
            ## Keep these around#
            olddata <- data#
#
            ## Make the new formula#
            formula <- combine.formulae(formula, chunk)#
            print("vv")#
            if (!("constant" %in% names(data)) && "constant" %in% get.formula.terms(formula))#
                data$constant <- 1#
#
            print("xx")#
#
            terms <- get.hyper.terms(chunk)#
            if (length(terms) == 3) {#
                print("ab")#
                ## Build the new relationship#
                weight <- calc.fo.weights(oldformula, terms[1], ratios[ratio.ii], datas[[data.ii]]) # use original data#
                print("ao")#
                print(terms)#
                extras <- make.hyper.rows(terms[1], terms[2], weight, datas[[data.ii]])#
#
                ## Done with this ratio#
                ratio.ii <- ratio.ii + 1#
#
                ## Create indicators for nonhyper, if not already done#
                if (terms[1] %in% data)#
                    data <- replace.factor(terms[1], data, 1, sep=sep)#
#
                data <- combine.data.frames(data, extras)#
            } else {#
                ## Add in the next formula#
                data.ii <- data.ii + 1#
                data <- combine.data.frame(data, datas[[data.ii]])#
            }#
#
            ## Have any of the terms in the formula been factorized?#
            checks <- get.formula.terms(formula)#
            for (check in checks) {#
                if (grepl(':', check)) {#
                    for (subterm in split.interaction.term(check))#
                        if (subterm %in% names(oldata) && !(subterm %in% names(data)) && !is.numeric(olddata[, check]))#
                            formula <- replace.factor.formula(subterm, formula, olddata)#
                } else {#
                    if (check %in% names(olddata) && !(check %in% names(data)) && !is.numeric(olddata[, check]))#
                        formula <- replace.factor.formula(check, formula, olddata)#
                }#
            }#
        }#
    }#
#
    print(head(data))#
    print(tail(data))#
    print(formula)#
    lm(formula, data=data)#
}
hierlm(Sepal.Length ~ 0 + Petal.Length + Species + Sepal.Width : Species | Species - . | Sepal.Width : Species - ., iris, c(1, 2))
#' Fit an hierarchical model#
#'#
#' Interpret a hierarchical formula and fit it with the given data and weight ratios.#
#'#
#' @param formula an hierlm-style formula#
#' @param datas a data frame or a list of data frames, for each lm-style formula contained in the hierlm#
#' @param ratios a vector a ratios for the effect of fictional#
#'   observations, with length as large as the number of hyper#
#'   expressions.#
#' @return A fitted lm model#
#' @examples#
#' hierlm(Sepal.Length ~ 0 + Petal.Length + Species + Sepal.Width : Species | Species - ., iris, 1)#
#' hierlm(Sepal.Length ~ 0 + Petal.Length + Species + Sepal.Width : Species | Species - . | Sepal.Width : Species - ., iris, c(1, 2))#
#
hierlm <- function(formula, datas, ratios, sep="") {#
    if (is.data.frame(datas))#
        datas <- list(datas)#
#
    data.ii <- 1#
    ratio.ii <- 1#
#
    data <- datas[[data.ii]]#
#
    ## Split the formula by |#
    labels <- attr(terms(formula), 'term.labels')#
    if (length(labels) == 1) { # otherwise it's just an lm formula#
        lhs <- as.character(formula)[2]#
        chunks <- strsplit(labels, "\\|")[[1]]#
        formula <- as.formula(paste(lhs, "~", chunks[1]), env=attr(formula, '.Environment'))#
        ## Keep this for weight calculations#
        oldformula <- formula#
        for (chunk in chunks[-1]) {#
            print(chunk)#
            ## Keep these around#
            olddata <- data#
#
            ## Make the new formula#
            formula <- combine.formulae(formula, chunk)#
            print("vv")#
            if (!("constant" %in% names(data)) && "constant" %in% get.formula.terms(formula))#
                data$constant <- 1#
#
            print("xx")#
#
            terms <- get.hyper.terms(chunk)#
            if (length(terms) == 3) {#
                print("ab")#
                ## Build the new relationship#
                weight <- calc.fo.weights(oldformula, terms[1], ratios[ratio.ii], datas[[data.ii]]) # use original data#
                print("ao")#
                print(terms)#
                extras <- make.hyper.rows(terms[1], terms[2], weight, datas[[data.ii]])#
#
                ## Done with this ratio#
                ratio.ii <- ratio.ii + 1#
#
                ## Create indicators for nonhyper, if not already done#
                if (terms[1] %in% data)#
                    data <- replace.factor(terms[1], data, 1, sep=sep)#
#
                data <- combine.data.frames(data, extras)#
            } else {#
                ## Add in the next formula#
                data.ii <- data.ii + 1#
                data <- combine.data.frame(data, datas[[data.ii]])#
            }#
#
            ## Have any of the terms in the formula been factorized?#
            checks <- get.formula.terms(formula)#
            for (check in checks) {#
                if (grepl(':', check)) {#
                    for (subterm in split.interaction.term(check))#
                        if (subterm %in% names(olddata) && !(subterm %in% names(data)) && !is.numeric(olddata[, check]))#
                            formula <- replace.factor.formula(subterm, formula, olddata)#
                } else {#
                    if (check %in% names(olddata) && !(check %in% names(data)) && !is.numeric(olddata[, check]))#
                        formula <- replace.factor.formula(check, formula, olddata)#
                }#
            }#
        }#
    }#
#
    print(head(data))#
    print(tail(data))#
    print(formula)#
    lm(formula, data=data)#
}
hierlm(Sepal.Length ~ 0 + Petal.Length + Species + Sepal.Width : Species | Species - . | Sepal.Width : Species - ., iris, c(1, 2))
#' Fit an hierarchical model#
#'#
#' Interpret a hierarchical formula and fit it with the given data and weight ratios.#
#'#
#' @param formula an hierlm-style formula#
#' @param datas a data frame or a list of data frames, for each lm-style formula contained in the hierlm#
#' @param ratios a vector a ratios for the effect of fictional#
#'   observations, with length as large as the number of hyper#
#'   expressions.#
#' @return A fitted lm model#
#' @examples#
#' hierlm(Sepal.Length ~ 0 + Petal.Length + Species + Sepal.Width : Species | Species - ., iris, 1)#
#' hierlm(Sepal.Length ~ 0 + Petal.Length + Species + Sepal.Width : Species | Species - . | Sepal.Width : Species - ., iris, c(1, 2))#
#
hierlm <- function(formula, datas, ratios, sep="") {#
    if (is.data.frame(datas))#
        datas <- list(datas)#
#
    data.ii <- 1#
    ratio.ii <- 1#
#
    data <- datas[[data.ii]]#
#
    ## Split the formula by |#
    labels <- attr(terms(formula), 'term.labels')#
    if (length(labels) == 1) { # otherwise it's just an lm formula#
        lhs <- as.character(formula)[2]#
        chunks <- strsplit(labels, "\\|")[[1]]#
        formula <- as.formula(paste(lhs, "~", chunks[1]), env=attr(formula, '.Environment'))#
        ## Keep this for weight calculations#
        oldformula <- formula#
        for (chunk in chunks[-1]) {#
            print(chunk)#
            ## Keep these around#
            olddata <- data#
#
            ## Make the new formula#
            formula <- combine.formulae(formula, chunk)#
            print("vv")#
            if (!("constant" %in% names(data)) && "constant" %in% get.formula.terms(formula))#
                data$constant <- 1#
#
            print("xx")#
#
            terms <- get.hyper.terms(chunk)#
            if (length(terms) == 3) {#
                print("ab")#
                ## Build the new relationship#
                weight <- calc.fo.weights(oldformula, terms[1], ratios[ratio.ii], datas[[data.ii]]) # use original data#
                print("ao")#
                print(terms)#
                extras <- make.hyper.rows(terms[1], terms[2], weight, datas[[data.ii]])#
#
                ## Done with this ratio#
                ratio.ii <- ratio.ii + 1#
#
                ## Create indicators for nonhyper, if not already done#
                if (terms[1] %in% data)#
                    data <- replace.factor(terms[1], data, 1, sep=sep)#
#
                data <- combine.data.frames(data, extras)#
            } else {#
                ## Add in the next formula#
                data.ii <- data.ii + 1#
                data <- combine.data.frame(data, datas[[data.ii]])#
            }#
#
            ## Have any of the terms in the formula been factorized?#
            checks <- get.formula.terms(formula)#
            for (check in checks) {#
                if (grepl(':', check)) {#
                    for (subterm in split.interaction.term(check))#
                        if (subterm %in% names(olddata) && !(subterm %in% names(data)) && !is.numeric(olddata[, subterm]))#
                            formula <- replace.factor.formula(subterm, formula, olddata)#
                } else {#
                    if (check %in% names(olddata) && !(check %in% names(data)) && !is.numeric(olddata[, check]))#
                        formula <- replace.factor.formula(check, formula, olddata)#
                }#
            }#
        }#
    }#
#
    print(head(data))#
    print(tail(data))#
    print(formula)#
    lm(formula, data=data)#
}
hierlm(Sepal.Length ~ 0 + Petal.Length + Species + Sepal.Width : Species | Species - . | Sepal.Width : Species - ., iris, c(1, 2))
#' Fit an hierarchical model#
#'#
#' Interpret a hierarchical formula and fit it with the given data and weight ratios.#
#'#
#' @param formula an hierlm-style formula#
#' @param datas a data frame or a list of data frames, for each lm-style formula contained in the hierlm#
#' @param ratios a vector a ratios for the effect of fictional#
#'   observations, with length as large as the number of hyper#
#'   expressions.#
#' @return A fitted lm model#
#' @examples#
#' hierlm(Sepal.Length ~ 0 + Petal.Length + Species + Sepal.Width : Species | Species - ., iris, 1)#
#' hierlm(Sepal.Length ~ 0 + Petal.Length + Species + Sepal.Width : Species | Species - . | Sepal.Width : Species - ., iris, c(1, 2))#
#
hierlm <- function(formula, datas, ratios, sep="") {#
    if (is.data.frame(datas))#
        datas <- list(datas)#
#
    data.ii <- 1#
    ratio.ii <- 1#
#
    data <- datas[[data.ii]]#
#
    ## Split the formula by |#
    labels <- attr(terms(formula), 'term.labels')#
    if (length(labels) == 1) { # otherwise it's just an lm formula#
        lhs <- as.character(formula)[2]#
        chunks <- strsplit(labels, "\\|")[[1]]#
        formula <- as.formula(paste(lhs, "~", chunks[1]), env=attr(formula, '.Environment'))#
        ## Keep this for weight calculations#
        oldformula <- formula#
        for (chunk in chunks[-1]) {#
            ## Keep these around#
            olddata <- data#
#
            ## Make the new formula#
            formula <- combine.formulae(formula, chunk)#
            if (!("constant" %in% names(data)) && "constant" %in% get.formula.terms(formula))#
                data$constant <- 1#
#
            terms <- get.hyper.terms(chunk)#
            if (length(terms) == 3) {#
                ## Build the new relationship#
                weight <- calc.fo.weights(oldformula, terms[1], ratios[ratio.ii], datas[[data.ii]]) # use original data#
                extras <- make.hyper.rows(terms[1], terms[2], weight, datas[[data.ii]])#
#
                ## Done with this ratio#
                ratio.ii <- ratio.ii + 1#
#
                ## Create indicators for nonhyper, if not already done#
                if (terms[1] %in% data)#
                    data <- replace.factor(terms[1], data, 1, sep=sep)#
#
                data <- combine.data.frames(data, extras)#
            } else {#
                ## Add in the next formula#
                data.ii <- data.ii + 1#
                data <- combine.data.frame(data, datas[[data.ii]])#
            }#
#
            ## Have any of the terms in the formula been factorized?#
            checks <- get.formula.terms(formula)#
            for (check in checks) {#
                if (grepl(':', check)) {#
                    for (subterm in split.interaction.term(check))#
                        if (subterm %in% names(olddata) && !(subterm %in% names(data)) && !is.numeric(olddata[, subterm])) {#
                            print(subterm)#
                            formula <- replace.factor.formula(subterm, formula, olddata)#
                            print(formula)#
                        }#
                } else {#
                    if (check %in% names(olddata) && !(check %in% names(data)) && !is.numeric(olddata[, check]))#
                        formula <- replace.factor.formula(check, formula, olddata)#
                }#
            }#
        }#
    }#
#
    print(head(data))#
    print(tail(data))#
    print(formula)#
    lm(formula, data=data)#
}
hierlm(Sepal.Length ~ 0 + Petal.Length + Species + Sepal.Width : Species | Species - . | Sepal.Width : Species - ., iris, c(1, 2))
#' Fit an hierarchical model#
#'#
#' Interpret a hierarchical formula and fit it with the given data and weight ratios.#
#'#
#' @param formula an hierlm-style formula#
#' @param datas a data frame or a list of data frames, for each lm-style formula contained in the hierlm#
#' @param ratios a vector a ratios for the effect of fictional#
#'   observations, with length as large as the number of hyper#
#'   expressions.#
#' @return A fitted lm model#
#' @examples#
#' hierlm(Sepal.Length ~ 0 + Petal.Length + Species + Sepal.Width : Species | Species - ., iris, 1)#
#' hierlm(Sepal.Length ~ 0 + Petal.Length + Species + Sepal.Width : Species | Species - . | Sepal.Width : Species - ., iris, c(1, 2))#
#
hierlm <- function(formula, datas, ratios, sep="") {#
    if (is.data.frame(datas))#
        datas <- list(datas)#
#
    data.ii <- 1#
    ratio.ii <- 1#
#
    data <- datas[[data.ii]]#
#
    ## Split the formula by |#
    labels <- attr(terms(formula), 'term.labels')#
    if (length(labels) == 1) { # otherwise it's just an lm formula#
        lhs <- as.character(formula)[2]#
        chunks <- strsplit(labels, "\\|")[[1]]#
        formula <- as.formula(paste(lhs, "~", chunks[1]), env=attr(formula, '.Environment'))#
        ## Keep this for weight calculations#
        oldformula <- formula#
        for (chunk in chunks[-1]) {#
            ## Keep these around#
            olddata <- data#
#
            ## Make the new formula#
            formula <- combine.formulae(formula, chunk)#
            if (!("constant" %in% names(data)) && "constant" %in% get.formula.terms(formula))#
                data$constant <- 1#
#
            terms <- get.hyper.terms(chunk)#
            if (length(terms) == 3) {#
                ## Build the new relationship#
                weight <- calc.fo.weights(oldformula, terms[1], ratios[ratio.ii], datas[[data.ii]]) # use original data#
                extras <- make.hyper.rows(terms[1], terms[2], weight, datas[[data.ii]])#
#
                ## Done with this ratio#
                ratio.ii <- ratio.ii + 1#
#
                ## Create indicators for nonhyper, if not already done#
                if (terms[1] %in% data)#
                    data <- replace.factor(terms[1], data, 1, sep=sep)#
#
                data <- combine.data.frames(data, extras)#
            } else {#
                ## Add in the next formula#
                data.ii <- data.ii + 1#
                data <- combine.data.frame(data, datas[[data.ii]])#
            }#
#
            ## Have any of the terms in the formula been factorized?#
            print("checking")#
            checks <- get.formula.terms(formula)#
            for (check in checks) {#
                if (grepl(':', check)) {#
                    for (subterm in split.interaction.term(check))#
                        if (subterm %in% names(olddata) && !(subterm %in% names(data)) && !is.numeric(olddata[, subterm])) {#
                            print(subterm)#
                            formula <- replace.factor.formula(subterm, formula, olddata)#
                            print(formula)#
                        }#
                } else {#
                    if (check %in% names(olddata) && !(check %in% names(data)) && !is.numeric(olddata[, check]))#
                        formula <- replace.factor.formula(check, formula, olddata)#
                }#
            }#
        }#
    }#
#
    print(head(data))#
    print(tail(data))#
    print(formula)#
    lm(formula, data=data)#
}
hierlm(Sepal.Length ~ 0 + Petal.Length + Species + Sepal.Width : Species | Species - . | Sepal.Width : Species - ., iris, c(1, 2))
#' Fit an hierarchical model#
#'#
#' Interpret a hierarchical formula and fit it with the given data and weight ratios.#
#'#
#' @param formula an hierlm-style formula#
#' @param datas a data frame or a list of data frames, for each lm-style formula contained in the hierlm#
#' @param ratios a vector a ratios for the effect of fictional#
#'   observations, with length as large as the number of hyper#
#'   expressions.#
#' @return A fitted lm model#
#' @examples#
#' hierlm(Sepal.Length ~ 0 + Petal.Length + Species + Sepal.Width : Species | Species - ., iris, 1)#
#' hierlm(Sepal.Length ~ 0 + Petal.Length + Species + Sepal.Width : Species | Species - . | Sepal.Width : Species - ., iris, c(1, 2))#
#
hierlm <- function(formula, datas, ratios, sep="") {#
    if (is.data.frame(datas))#
        datas <- list(datas)#
#
    data.ii <- 1#
    ratio.ii <- 1#
#
    data <- datas[[data.ii]]#
#
    ## Split the formula by |#
    labels <- attr(terms(formula), 'term.labels')#
    if (length(labels) == 1) { # otherwise it's just an lm formula#
        lhs <- as.character(formula)[2]#
        chunks <- strsplit(labels, "\\|")[[1]]#
        formula <- as.formula(paste(lhs, "~", chunks[1]), env=attr(formula, '.Environment'))#
        ## Keep this for weight calculations#
        oldformula <- formula#
        for (chunk in chunks[-1]) {#
            ## Make the new formula#
            formula <- combine.formulae(formula, chunk)#
            if (!("constant" %in% names(data)) && "constant" %in% get.formula.terms(formula))#
                data$constant <- 1#
#
            terms <- get.hyper.terms(chunk)#
            if (length(terms) == 3) {#
                ## Build the new relationship#
                weight <- calc.fo.weights(oldformula, terms[1], ratios[ratio.ii], datas[[data.ii]]) # use original data#
                extras <- make.hyper.rows(terms[1], terms[2], weight, datas[[data.ii]])#
#
                ## Done with this ratio#
                ratio.ii <- ratio.ii + 1#
#
                ## Create indicators for nonhyper, if not already done#
                if (terms[1] %in% data)#
                    data <- replace.factor(terms[1], data, 1, sep=sep)#
#
                data <- combine.data.frames(data, extras)#
            } else {#
                ## Add in the next formula#
                data.ii <- data.ii + 1#
                data <- combine.data.frame(data, datas[[data.ii]])#
            }#
#
            ## Have any of the terms in the formula been factorized?#
            print("checking")#
            checks <- get.formula.terms(formula)#
            for (check in checks) {#
                if (grepl(':', check)) {#
                    for (subterm in split.interaction.term(check))#
                        if (subterm %in% names(datas[[data.ii]]) && !(subterm %in% names(data)) && !is.numeric(datas[[data.ii]][, subterm])) {#
                            print(subterm)#
                            formula <- replace.factor.formula(subterm, formula, datas[[data.ii]])#
                            print(formula)#
                        }#
                } else {#
                    if (check %in% names(datas[[data.ii]]) && !(check %in% names(data)) && !is.numeric(datas[[data.ii]][, check]))#
                        formula <- replace.factor.formula(check, formula, datas[[data.ii]])#
                }#
            }#
        }#
    }#
#
    print(head(data))#
    print(tail(data))#
    print(formula)#
    lm(formula, data=data)#
}
hierlm(Sepal.Length ~ 0 + Petal.Length + Species + Sepal.Width : Species | Species - . | Sepal.Width : Species - ., iris, c(1, 2))
#' Fit an hierarchical model#
#'#
#' Interpret a hierarchical formula and fit it with the given data and weight ratios.#
#'#
#' @param formula an hierlm-style formula#
#' @param datas a data frame or a list of data frames, for each lm-style formula contained in the hierlm#
#' @param ratios a vector a ratios for the effect of fictional#
#'   observations, with length as large as the number of hyper#
#'   expressions.#
#' @return A fitted lm model#
#' @examples#
#' hierlm(Sepal.Length ~ 0 + Petal.Length + Species + Sepal.Width : Species | Species - ., iris, 1)#
#' hierlm(Sepal.Length ~ 0 + Petal.Length + Species + Sepal.Width : Species | Species - . | Sepal.Width : Species - ., iris, c(1, 2))#
#
hierlm <- function(formula, datas, ratios, sep="") {#
    if (is.data.frame(datas))#
        datas <- list(datas)#
#
    data.ii <- 1#
    ratio.ii <- 1#
#
    data <- datas[[data.ii]]#
#
    ## Split the formula by |#
    labels <- attr(terms(formula), 'term.labels')#
    if (length(labels) == 1) { # otherwise it's just an lm formula#
        lhs <- as.character(formula)[2]#
        chunks <- strsplit(labels, "\\|")[[1]]#
        formula <- as.formula(paste(lhs, "~", chunks[1]), env=attr(formula, '.Environment'))#
        ## Keep this for weight calculations#
        oldformula <- formula#
        for (chunk in chunks[-1]) {#
            ## Make the new formula#
            formula <- combine.formulae(formula, chunk)#
            if (!("constant" %in% names(data)) && "constant" %in% get.formula.terms(formula))#
                data$constant <- 1#
#
            terms <- get.hyper.terms(chunk)#
            if (length(terms) == 3) {#
                ## Build the new relationship#
                weight <- calc.fo.weights(oldformula, terms[1], ratios[ratio.ii], datas[[data.ii]]) # use original data#
                print(weight)#
                extras <- make.hyper.rows(terms[1], terms[2], weight, datas[[data.ii]])#
#
                ## Done with this ratio#
                ratio.ii <- ratio.ii + 1#
#
                ## Create indicators for nonhyper, if not already done#
                if (terms[1] %in% data)#
                    data <- replace.factor(terms[1], data, 1, sep=sep)#
#
                data <- combine.data.frames(data, extras)#
            } else {#
                ## Add in the next formula#
                data.ii <- data.ii + 1#
                data <- combine.data.frame(data, datas[[data.ii]])#
            }#
#
            ## Have any of the terms in the formula been factorized?#
            checks <- get.formula.terms(formula)#
            for (check in checks) {#
                if (grepl(':', check)) {#
                    for (subterm in split.interaction.term(check))#
                        if (subterm %in% names(datas[[data.ii]]) && !(subterm %in% names(data)) && !is.numeric(datas[[data.ii]][, subterm]))#
                            formula <- replace.factor.formula(subterm, formula, datas[[data.ii]])#
                } else {#
                    if (check %in% names(datas[[data.ii]]) && !(check %in% names(data)) && !is.numeric(datas[[data.ii]][, check]))#
                        formula <- replace.factor.formula(check, formula, datas[[data.ii]])#
                }#
            }#
        }#
    }#
#
    print(head(data))#
    print(tail(data))#
    print(formula)#
    lm(formula, data=data)#
}
hierlm(Sepal.Length ~ 0 + Petal.Length + Species + Sepal.Width : Species | Species - . | Sepal.Width : Species - ., iris, c(1, 2))
#' Fit an hierarchical model#
#'#
#' Interpret a hierarchical formula and fit it with the given data and weight ratios.#
#'#
#' @param formula an hierlm-style formula#
#' @param datas a data frame or a list of data frames, for each lm-style formula contained in the hierlm#
#' @param ratios a vector a ratios for the effect of fictional#
#'   observations, with length as large as the number of hyper#
#'   expressions.#
#' @return A fitted lm model#
#' @examples#
#' hierlm(Sepal.Length ~ 0 + Petal.Length + Species + Sepal.Width : Species | Species - ., iris, 1)#
#' hierlm(Sepal.Length ~ 0 + Petal.Length + Species + Sepal.Width : Species | Species - . | Sepal.Width : Species - ., iris, c(1, 2))#
#
hierlm <- function(formula, datas, ratios, sep="") {#
    if (is.data.frame(datas))#
        datas <- list(datas)#
#
    data.ii <- 1#
    ratio.ii <- 1#
#
    data <- datas[[data.ii]]#
#
    ## Split the formula by |#
    labels <- attr(terms(formula), 'term.labels')#
    if (length(labels) == 1) { # otherwise it's just an lm formula#
        lhs <- as.character(formula)[2]#
        chunks <- strsplit(labels, "\\|")[[1]]#
        formula <- as.formula(paste(lhs, "~", chunks[1]), env=attr(formula, '.Environment'))#
        ## Keep this for weight calculations#
        oldformula <- formula#
        for (chunk in chunks[-1]) {#
            ## Make the new formula#
            formula <- combine.formulae(formula, chunk)#
            if (!("constant" %in% names(data)) && "constant" %in% get.formula.terms(formula))#
                data$constant <- 1#
#
            terms <- get.hyper.terms(chunk)#
            if (length(terms) == 3) {#
                ## Build the new relationship#
                print(oldformula)#
                print(c(terms[1], ratios[ratio.ii]))#
                weight <- calc.fo.weights(oldformula, terms[1], ratios[ratio.ii], datas[[data.ii]]) # use original data#
                print(weight)#
                extras <- make.hyper.rows(terms[1], terms[2], weight, datas[[data.ii]])#
#
                ## Done with this ratio#
                ratio.ii <- ratio.ii + 1#
#
                ## Create indicators for nonhyper, if not already done#
                if (terms[1] %in% data)#
                    data <- replace.factor(terms[1], data, 1, sep=sep)#
#
                data <- combine.data.frames(data, extras)#
            } else {#
                ## Add in the next formula#
                data.ii <- data.ii + 1#
                data <- combine.data.frame(data, datas[[data.ii]])#
            }#
#
            ## Have any of the terms in the formula been factorized?#
            checks <- get.formula.terms(formula)#
            for (check in checks) {#
                if (grepl(':', check)) {#
                    for (subterm in split.interaction.term(check))#
                        if (subterm %in% names(datas[[data.ii]]) && !(subterm %in% names(data)) && !is.numeric(datas[[data.ii]][, subterm]))#
                            formula <- replace.factor.formula(subterm, formula, datas[[data.ii]])#
                } else {#
                    if (check %in% names(datas[[data.ii]]) && !(check %in% names(data)) && !is.numeric(datas[[data.ii]][, check]))#
                        formula <- replace.factor.formula(check, formula, datas[[data.ii]])#
                }#
            }#
        }#
    }#
#
    print(head(data))#
    print(tail(data))#
    print(formula)#
    lm(formula, data=data)#
}
hierlm(Sepal.Length ~ 0 + Petal.Length + Species + Sepal.Width : Species | Species - . | Sepal.Width : Species - ., iris, c(1, 2))
lm(Sepal.Length ~ 0 + Petal.Length + Species + Sepal.Width:Species, iris)
#' Calculate Fictional Observation Weights#
#'#
#' Determines the coeffiicients for terms in the fictional observations,#
#' to ensure a given weight relative to the normal observations.#
#'#
#' @param formula lm-style formula#
#' @param label the term to be used in fictional observations#
#' @param ratio desired ratio of observed and fictional data#
#' @param data optional data frame#
#' @return Coefficients for fictional observations#
#' @examples#
#' calc.fo.weights(Sepal.Length ~ Petal.Length + Sepal.Width : Species, "Sepal.Width:Species", 5, data=iris)#
#
calc.fo.weights <- function(formula, label, ratio, data) {#
    mod.lm <- lm(formula, data)#
    sumerr <- sum(mod.lm$residuals^2)#
#
    ## Collect the beta values for all of these#
    dummies <- substr(names(mod.lm$coefficients), 1, nchar(label)) == label#
    if (sum(dummies) == 0 && grepl(':', label)) {#
        ## Try flipping an interaction#
        subterms = split.interaction.term(label)#
        dummies <- grep(paste(subterms[2], ".*", subterms[1], sep=""), names(mod.lm$coefficients))#
    }#
    betas <- mod.lm$coefficients[dummies]#
#
    sumerr / (ratio * sum(dummies) * var(betas))#
}
hierlm(Sepal.Length ~ 0 + Petal.Length + Species + Sepal.Width : Species | Species - . | Sepal.Width : Species - ., iris, c(1, 2))
summary(hierlm(Sepal.Length ~ 0 + Petal.Length + Species + Sepal.Width : Species | Species - . | Sepal.Width : Species - ., iris, c(1, 2)))
summary(hierlm(Sepal.Length ~ 0 + Petal.Length + Species + Sepal.Width : Species | Species - ., iris, c(1, 2)))
hierlm(Sepal.Length ~ 0 + Petal.Length + Species + Sepal.Width : Species | Sepal.Width : Species - ., iris, 2)
summary(hierlm(Sepal.Length ~ 0 + Petal.Length + Species + Sepal.Width : Species | Sepal.Width : Species - ., iris, 2))
100 * exp((2 * 1:50 - 1) / 10) / exp(10)
2 * 1:50 - 1
###pca - calculated for the first 4 columns of the data set that correspond to biometric measurements ("Sepal.Length" "Sepal.Width"  "Petal.Length" "Petal.Width")#
data(iris)#
dat <- as.matrix(iris[,-5])#
pca <- prcomp(dat, retx=TRUE, center=TRUE, scale=TRUE)
setosa.mean <- apply(iris[iris$Species=="setosa",-5], 2, mean)#
    setosa.cov <- cov(iris[iris$Species=="setosa",-5])#
#
versicolor.mean <- apply(iris[iris$Species=="versicolor",-5], 2, mean)#
    versicolor.cov <- cov(iris[iris$Species=="versicolor",-5])#
#
virginica.mean <- apply(iris[iris$Species=="virginica",-5], 2, mean)#
    virginica.cov <- cov(iris[iris$Species=="virginica",-5])
setosa.mean
setosa.cov
require(MASS)#
set.seed(1)#
n <- 30#
new.setosa <- mvrnorm(n, setosa.mean, setosa.cov)#
new.versicolor <- mvrnorm(n, versicolor.mean, versicolor.cov)#
new.virginica <- mvrnorm(n, virginica.mean, virginica.cov)
new.setosa
pred.setosa <- predict(pca, new.setosa)#
pred.versicolor <- predict(pca, new.versicolor)#
pred.virginica <- predict(pca, new.virginica)
pred.setosa
setwd("~/projects/coffee")#
#
do.delay <- T#
#
library(splines)#
library(maps)#
#
source("lib/production.R")#
#
faostat <- load.faostat()#
#
nino <- read.table("correlations/data/nino3.4.txt", header=F)#
nino[nino == -99.99] <- NA#
nino.d6 <- cbind(rbind(rep(NA, 6), nino[,8:13]), rbind(nino[,2:7], rep(NA, 6)))#
#
nao <- read.table("correlations/data/nao.txt", header=F)#
nao[nao == -99.9] <- NA#
nao.d6 <- cbind(rbind(rep(NA, 6), nao[,8:13]), rbind(nao[,2:7], rep(NA, 6)))#
#
soi <- read.table("correlations/data/soi.txt", header=F)#
soi[soi == -99.99] <- NA#
soi.d6 <- cbind(rbind(rep(NA, 6), soi[,8:13]), rbind(soi[,2:7], rep(NA, 6)))#
#
pdo <- read.table("correlations/data/pdo.txt", header=F)#
pdo[pdo == -99.99] <- NA#
pdo.d6 <- cbind(rbind(rep(NA, 6), pdo[,8:13]), rbind(pdo[,2:7], rep(NA, 6)))#
#
amo <- read.table("correlations/data/amo.txt", header=F)#
amo[amo == -99.99] <- NA#
amo.d6 <- cbind(rbind(rep(NA, 6), amo[,8:13]), rbind(amo[,2:7], rep(NA, 6)))#
#
nino.x <- as.vector(t(nino[,-1]))#
nino.y <- (nino.x - mean(nino.x, na.rm=T)) / sd(nino.x, na.rm=T)#
#
nao.x <- as.vector(t(nao[,-1]))#
nao.y <- (nao.x - mean(nao.x, na.rm=T)) / sd(nao.x, na.rm=T)#
#
soi.x <- as.vector(t(soi[,-1]))#
soi.y <- (soi.x - mean(soi.x, na.rm=T)) / sd(soi.x, na.rm=T)#
#
pdo.x <- as.vector(t(pdo[,-1]))#
pdo.y <- (pdo.x - mean(pdo.x, na.rm=T)) / sd(pdo.x, na.rm=T)#
#
amo.x <- as.vector(t(amo[,-1]))#
amo.y <- (amo.x - mean(amo.x, na.rm=T)) / sd(amo.x, na.rm=T)#
#
tt <- seq(1950, by=1/12, length.out=length(nino.x))
do.delay
nino.d6 <- (nino.d6 - mean(nino.x, na.rm=T)) / sd(nino.x, na.rm=T)#
    nao.d6 <- (nao.d6 - mean(nao.x, na.rm=T)) / sd(nao.x, na.rm=T)#
    soi.d6 <- (soi.d6 - mean(soi.x, na.rm=T)) / sd(soi.x, na.rm=T)#
    pdo.d6 <- (pdo.d6 - mean(pdo.x, na.rm=T)) / sd(pdo.x, na.rm=T)#
    amo.d6 <- (amo.d6 - mean(amo.x, na.rm=T)) / sd(amo.x, na.rm=T)#
    alldata <- cbind(nino.d6, nao.d6, soi.d6, pdo.d6, amo.d6)
names(alldata) <- c(paste("NINO", 1:12, sep="-"), paste("NAO", 1:12, sep="-"), paste("SOI", 1:12, sep="-"), paste("PDO", 1:12, sep="-"), paste("AMO", 1:12, sep="-"))
library(locfit)#
#
fit <- locfit(CorrectedYield ~ Year, data=faostat)#
faostat$DetrendYield <- NA#
faostat$DetrendYield[!is.na(faostat$CorrectedYield)] <- residuals(fit)#
fit <- locfit(Yield ~ Year, data=faostat)#
faostat$DetrendYield2 <- NA#
faostat$DetrendYield2[!is.na(faostat$Yield)] <- residuals(fit)
for (country in unique(faostat$Country)) {#
    print(country)#
    alldata[country] <- NA#
    for (year in min(faostat$Year):max(faostat$Year)) {#
        yield <- faostat[faostat$Country == country & faostat$Year == year,]#
        if (nrow(yield) > 0 && !is.na(yield$Yield)) {#
            if (!is.na(yield$CorrectedYield))#
                alldata[year - 1947, country] <- yield$DetrendYield#
            else#
                alldata[year - 1947, country] <- yield$DetrendYield2#
        }#
        else#
            alldata[year - 1947, country] <- 0 # Want to fill in with some value#
    }#
}
library(stats)#
#
for (cc in 61:dim(alldata)[2]) # start after signals#
    alldata[,cc] <- (alldata[,cc] - mean(alldata[,cc], na.rm=T)) / sd(alldata[,cc], na.rm=T)
library(splines)#
#
alldata <- alldata[, colSums(!is.na(alldata)) > 0]
rownames(alldata) <- 1948:(1948+68)
pca <- prcomp(alldata[(min(faostat$Year) - 1947):(max(faostat$Year) - 1947),])#
plot(pca)
biplot(pca)
head(alldata[(min(faostat$Year) - 1947):(max(faostat$Year) - 1947),])
?prcomp
mean(alldata$Togo)
mean(alldata$Togo, na.rm=T)
mean(alldata$Uganda, na.rm=T)
mean(alldata[, "PDO-8"], na.rm=T)
names(pca)
?prcomp
pca
sqrt()pca$rotation * pca$rotation
sqrt(pca$rotation * pca$rotation)
dim(pca$rotation)
sqrt(pca$rotation[,1] * pca$rotation[,1])
pca1 = as.numeric(pca$rotation[,1])
pca1
sqrt(pca1 * pca1)
pca1 * pca1)
pca1 * pca1
sqrt(sum(pca1 * pca1))
pca2 = as.numeric(pca$rotation[,2])
sqrt(sum(pca2 * pca2))
names(alldata)
write.csv(alldata[(min(faostat$Year) - 1947):(max(faostat$Year) - 1947),], file="tools/variability/alldata.csv")
mean(nino.x, na.rm=T)
sd(nino.x, na.rm=T)
cor(nino.x, soi.x)
?cor
cor(nino.x, soi.x, use="complete")
mean(pdo.x, na.rm=T)
sd(pdo.x, na.rm=T)
mean(amo.x, na.rm=T)
sd(amo.x, na.rm=T)
nino.d6 <- (nino.d6 - mean(nino.x, na.rm=T)) / sd(nino.x, na.rm=T)#
    nao.d6 <- (nao.d6 - mean(nao.x, na.rm=T)) / sd(nao.x, na.rm=T)#
    soi.d6 <- (soi.d6 - mean(soi.x, na.rm=T)) / sd(soi.x, na.rm=T)#
    pdo.d6 <- (pdo.d6 - mean(pdo.x, na.rm=T)) / sd(pdo.x, na.rm=T)#
    amo.d6 <- (amo.d6 - mean(amo.x, na.rm=T)) / sd(amo.x, na.rm=T)#
    alldata <- cbind(nino.d6, nao.d6, soi.d6, pdo.d6, amo.d6)
names(alldata) <- c(paste("NINO", 1:12, sep="-"), paste("NAO", 1:12, sep="-"), paste("SOI", 1:12, sep="-"), paste("PDO", 1:12, sep="-"), paste("AMO", 1:12, sep="-"))#
#
library(locfit)#
#
fit <- locfit(CorrectedYield ~ Year, data=faostat)#
faostat$DetrendYield <- NA#
faostat$DetrendYield[!is.na(faostat$CorrectedYield)] <- residuals(fit)#
fit <- locfit(Yield ~ Year, data=faostat)#
faostat$DetrendYield2 <- NA#
faostat$DetrendYield2[!is.na(faostat$Yield)] <- residuals(fit)
plot(faostat$Year[faostat$Country == "Africa"], faostat$CorrectedYield[faostat$Country == "Africa"])#
plot(faostat$Year[faostat$Country == "Africa"], faostat$DetrendYield[faostat$Country == "Africa"])#
plot(faostat$Year[faostat$Country == "Africa"], faostat$DetrendYield2[faostat$Country == "Africa"])
for (country in unique(faostat$Country)) {#
    print(country)#
    alldata[country] <- NA#
    for (year in min(faostat$Year):max(faostat$Year)) {#
        yield <- faostat[faostat$Country == country & faostat$Year == year,]#
        if (nrow(yield) > 0 && !is.na(yield$Yield)) {#
            if (!is.na(yield$CorrectedYield))#
                alldata[year - 1947, country] <- yield$DetrendYield#
            else#
                alldata[year - 1947, country] <- yield$DetrendYield2#
        }#
        else#
            alldata[year - 1947, country] <- 0 # Want to fill in with some value#
    }#
}
alldata[1,]
scalings <- data.frame(region=c(), mean=c(), sd=c())#
for (cc in 61:dim(alldata)[2]) { # start after signals#
    scalings <- rbind(scalings, data.frame(region=names(alldata)[cc], mean=mean(alldata[,cc], na.rm=T), sd=sd(alldata[,cc], na.rm=T)))#
    alldata[,cc] <- (alldata[,cc] - mean(alldata[,cc], na.rm=T)) / sd(alldata[,cc], na.rm=T)#
}
scalings
write.csv(scalings, file="tools/variability/scalings.csv")
write.csv(scalings, file="tools/variability/scalings.csv", row.names=F)
mean(nino.x, na.rm=T)
setwd("~/projects/coffee/tools/variability")#
#
library(maps)#
#
yields <- read.csv("yields.csv")
yields
source("~/projects/research-common/R/drawmap.R")
draw.map("world", yields$region, yields$yield2016 - yields$yield2015, position="left", digits=2)
yields$percent <- NA#
#
percent1997 = list("Mexico"=-6.96, "Guatemala"=-22.63, "El Salvador"=5.65, "Costa Rica"=21.24, "Honduras"=14.77, "Nicaragua"=40.61, "Brazil"=-31.63, "Colombia"=-3.43, "Ecuador"=-12.09, "Peru"=4.88, "Venezuela"=-20.35, "Indonesia"=-17.21, "Papua New Guinea"=-18.46, "Vietnam"=2.24, "India"=9.54, "Thailand"=-11.84, "Philippines"=5.06, "Cote d'Ivoire"=3.13, "Cameroon"=-1.05, "Uganda"=-6.04, "Kenya"=-11.72, "Ethiopia"=17.25, "Madagascar"=-5.88, "Angola"=83.10)#
for (name in percent1997) {#
    if (!(name %in% yields$region)) {#
        print(paste("Cannot find", name))#
        next#
    }#
#
    yields$percent[yields$region == name] <- percent1997[[name]]#
}
percent1997
names(percent1997)
for (name in names(percent1997)) {#
    if (!(name %in% yields$region)) {#
        print(paste("Cannot find", name))#
        next#
    }#
#
    yields$percent[yields$region == name] <- percent1997[[name]]#
}
yields$region
yields <- read.csv("yields.csv")#
yields$region[yields$region == "Venezuela (Bolivarian Republic of)"] <- "Venezuela"#
yields$region[yields$region == "Viet Nam"] <- "Vietnam"#
yields$region[yields$region == "Côte d'Ivoire"] <- "Cote d'Ivoire"#
#
yields$percent <- NA#
#
percent1997 = list("Mexico"=-6.96, "Guatemala"=-22.63, "El Salvador"=5.65, "Costa Rica"=21.24, "Honduras"=14.77, "Nicaragua"=40.61, "Brazil"=-31.63, "Colombia"=-3.43, "Ecuador"=-12.09, "Peru"=4.88, "Venezuela"=-20.35, "Indonesia"=-17.21, "Papua New Guinea"=-18.46, "Vietnam"=2.24, "India"=9.54, "Thailand"=-11.84, "Philippines"=5.06, "Cote d'Ivoire"=3.13, "Cameroon"=-1.05, "Uganda"=-6.04, "Kenya"=-11.72, "Ethiopia"=17.25, "Madagascar"=-5.88, "Angola"=83.10)#
for (name in names(percent1997)) {#
    if (!(name %in% yields$region)) {#
        print(paste("Cannot find", name))#
        next#
    }#
#
    yields$percent[yields$region == name] <- percent1997[[name]]#
}
yields <- read.csv("yields.csv")#
yields$region <- as.character(yields$region)#
yields$region[yields$region == "Venezuela (Bolivarian Republic of)"] <- "Venezuela"#
yields$region[yields$region == "Viet Nam"] <- "Vietnam"#
yields$region[yields$region == "Côte d'Ivoire"] <- "Cote d'Ivoire"#
#
yields$percent <- NA#
#
percent1997 = list("Mexico"=-6.96, "Guatemala"=-22.63, "El Salvador"=5.65, "Costa Rica"=21.24, "Honduras"=14.77, "Nicaragua"=40.61, "Brazil"=-31.63, "Colombia"=-3.43, "Ecuador"=-12.09, "Peru"=4.88, "Venezuela"=-20.35, "Indonesia"=-17.21, "Papua New Guinea"=-18.46, "Vietnam"=2.24, "India"=9.54, "Thailand"=-11.84, "Philippines"=5.06, "Cote d'Ivoire"=3.13, "Cameroon"=-1.05, "Uganda"=-6.04, "Kenya"=-11.72, "Ethiopia"=17.25, "Madagascar"=-5.88, "Angola"=83.10)#
for (name in names(percent1997)) {#
    if (!(name %in% yields$region)) {#
        print(paste("Cannot find", name))#
        next#
    }#
#
    yields$percent[yields$region == name] <- percent1997[[name]]#
}
yields
source("~/projects/coffee/lib/production.R")
faostat <- load.faostat()
faostat[1,]
yields$yield1996 <- NA#
#
for (ii in 1:nrow(faostat)) {#
    country <- faostat$Country[ii]#
    if (!(country %in% yields$region)) {#
        print(paste("Cannot find", country))#
        next#
    }#
#
    yields$yield1996[yields$region == country] <- faostat$CorrectedYield[ii]#
}
faostat[1,]
yields$yield1996 <- NA#
#
for (ii in faostat$Country) {#
    if (!(country %in% yields$region)) {#
        print(paste("Cannot find", country))#
        next#
    }#
#
    yields$yield1996[yields$region == country] <- faostat$CorrectedYield[faostat$Country == country & faostat$Year == 1996]#
}
yields
for (country in faostat$Country) {#
    if (!(country %in% yields$region)) {#
        print(paste("Cannot find", country))#
        next#
    }#
#
    yields$yield1996[yields$region == country] <- faostat$CorrectedYield[faostat$Country == country & faostat$Year == 1996]#
}
sum(faostat$Country == country & faostat$Year == 1996)
yields$yield1996 <- NA#
#
for (country in faostat$Country) {#
    if (!(country %in% yields$region)) {#
        print(paste("Cannot find", country))#
        next#
    }#
#
    valid <- faostat$Country == country & faostat$Year == 1996#
    if (sum(valid) == 0)#
        next#
#
    yields$yield1996[yields$region == country] <- faostat$CorrectedYield[valid]#
}
yields$yield1996 <- NA#
#
for (country in unique(faostat$Country)) {#
    if (!(country %in% yields$region)) {#
        print(paste("Cannot find", country))#
        next#
    }#
#
    valid <- faostat$Country == country & faostat$Year == 1996#
    if (sum(valid) == 0)#
        next#
#
    yields$yield1996[yields$region == country] <- faostat$CorrectedYield[valid]#
}
yields$yield1996 <- NA#
#
for (country in unique(faostat$Country)) {#
    mycountry <- country#
    if (country == "Côte d'Ivoire")#
        mycountry <- "Cote d'Ivoire"#
    if (country == "Venezuela (Bolivarian Republic of)")#
        mycountry <- "Venezuela"#
    if (country == "Viet Nam")#
        mycountry <- "Vietnam"#
#
    if (!(mycountry %in% yields$region)) {#
        print(paste("Cannot find", country))#
        next#
    }#
#
    valid <- faostat$Country == country & faostat$Year == 1996#
    if (sum(valid) == 0)#
        next#
#
    yields$yield1996[yields$region == mycountry] <- faostat$CorrectedYield[valid]#
}
yields[1,]
yields$diff.before <- yields$yield1996 * (1 + yields$percent / 100) - yields$yield1996
yields$diff.before <- yields$yield1996 * (1 + yields$percent / 100) - yields$yield1996#
yields$diff.pred <- yields$yield2016 - yields$yield2015
par(mfrow=c(2, 1))#
draw.map("world", yields$region, yields$diff.before, position="left", digits=2)#
draw.map("world", yields$region, yields$diff.pred, position="left", digits=2)
yields
draw.map("world", yields$region, yields$diff.before, position="left", digits=2)
map(regions="Brazil", col=1)
draw.map("world", yields$region, yields$diff.before, position="left", digits=2)
map("world", yields$region)
database = "world"
names = yields$region
values = yields$diff.before
colorscheme="RdYlGn"
colors <- brewer.pal(9, colorscheme)
brks <- classIntervals(values, n=9, style="quantile")#
    brks <- brks$brks
brks
range(values)
range(values, na.rm=T)
map(database, names, col=colors[findInterval(values, brks, all.inside=TRUE)], fill=T, mar=c(1, 2, 3, 0), add=add)
map(database, names, col=colors[findInterval(values, brks, all.inside=TRUE)], fill=T, mar=c(1, 2, 3, 0))
values[names == "Brazil"]
map(database, names, col=colors[findInterval(values, brks, all.inside=F)], fill=T, mar=c(1, 2, 3, 0))
findInterval(values[names == "Brazil"], brks, all.inside=F)
colors[1]
map(database, "Brazil", col=colors[findInterval(values[names == "Brazil"], brks, all.inside=F)], fill=T)
colors[findInterval(values, brks, all.inside=TRUE)]
names
map(database, names[1:8], col=colors[findInterval(values, brks, all.inside=F)][1:8], fill=T, mar=c(1, 2, 3, 0))
map(database, names[8], col=colors[findInterval(values, brks, all.inside=F)][8], fill=T, mar=c(1, 2, 3, 0))
map(database, names[5:8], col=colors[findInterval(values, brks, all.inside=F)][5:8], fill=T, mar=c(1, 2, 3, 0))
map(database, names[7:8], col=colors[findInterval(values, brks, all.inside=F)][7:8], fill=T, mar=c(1, 2, 3, 0))
names[7:8]
map(database, "Bolivia (Plurinational State of)")
map(database, names[7:8])
map(database, names[7:8], col=c(1, 2))
map(database, names[7:8], col=c(1, 2), fill=T)
yieldsregion[yields$region == "Bolivia (Plurinational State of)"] <- "Bolivia"
yields$region[yields$region == "Bolivia (Plurinational State of)"] <- "Bolivia"
draw.map("world", yields$region, yields$diff.before, position="left", digits=2)
map("world", ylim=c(-30, 30))
for (ii in 1:nrow(yields))#
    map("world", yields$region[ii], col=colors[findInterval(yields$diff.before[ii], brks, all.inside=TRUE)], fill=T, mar=c(1, 2, 3, 0), add=T)
for (ii in 1:nrow(yields)) {#
    print(yields$region[ii])#
    map("world", yields$region[ii], col=colors[findInterval(yields$diff.before[ii], brks, all.inside=TRUE)], fill=T, mar=c(1, 2, 3, 0), add=T)#
}
yields[1,]
map("world", ylim=c(-30, 30))#
for (ii in 1:nrow(yields)) {#
    if (is.na(yields$diff.before))#
        next#
    map("world", yields$region[ii], col=colors[findInterval(yields$diff.before[ii], brks, all.inside=TRUE)], fill=T, mar=c(1, 2, 3, 0), add=T)#
}
warnings()
map("world", ylim=c(-30, 30))#
for (ii in 1:nrow(yields)) {#
    if (is.na(yields$diff.before[ii]))#
        next#
    map("world", yields$region[ii], col=colors[findInterval(yields$diff.before[ii], brks, all.inside=TRUE)], fill=T, mar=c(1, 2, 3, 0), add=T)#
}
ii
yields$region[ii]
map("world", "Ivory Coast")
yields$region[yields$region == "Cote d'Ivoire"] <- "Ivory Coast"
## Map Before#
colors <- brewer.pal(9, colorscheme)#
brks <- classIntervals(values, n=9, style="quantile")#
brks <- brks$brks#
map("world", ylim=c(-30, 30))#
for (ii in 1:nrow(yields)) {#
    if (is.na(yields$diff.before[ii]))#
        next#
    map("world", yields$region[ii], col=colors[findInterval(yields$diff.before[ii], brks, all.inside=TRUE)], fill=T, mar=c(1, 2, 3, 0), add=T)#
}
par(mfrow=c(2, 1))#
#
## Map Before#
colors <- brewer.pal(9, colorscheme)#
brks <- classIntervals(values, n=9, style="quantile")#
brks <- brks$brks#
map("world", ylim=c(-30, 30))#
for (ii in 1:nrow(yields)) {#
    if (is.na(yields$diff.before[ii]))#
        next#
    map("world", yields$region[ii], col=colors[findInterval(yields$diff.before[ii], brks, all.inside=TRUE)], fill=T, mar=c(1, 2, 3, 0), add=T)#
}#
#
draw.map("world", yields$region, yields$diff.pred, position="left", digits=2)
library(maptools)#
library(maps)#
#
library(RColorBrewer)#
library(classInt)#
#
draw.map <- function(database, names, values, colorscheme="RdYlGn", position=NA, add=F, digits=0, ylim=c(-90, 90)) {#
    if (colorscheme == "GnYlRd")#
        colors <- rev(brewer.pal(9, "RdYlGn"))#
    else#
        colors <- brewer.pal(9, colorscheme)#
#
    brks <- classIntervals(values, n=9, style="quantile")#
    brks <- brks$brks#
#
    map(database, names, col=colors[findInterval(values, brks, all.inside=TRUE)], fill=T, mar=c(1, 2, 3, 0), add=add, ylim=ylim)#
#
    if (!is.na(position))#
        legend(position, legend=leglabs(round(brks, digits=digits)), fill=colors, bty="n", cex=.5)#
}
par(mfrow=c(2, 1))#
#
## Map Before#
colors <- brewer.pal(9, colorscheme)#
brks <- classIntervals(values, n=9, style="quantile")#
brks <- brks$brks#
map("world", ylim=c(-30, 30))#
for (ii in 1:nrow(yields)) {#
    if (is.na(yields$diff.before[ii]))#
        next#
    map("world", yields$region[ii], col=colors[findInterval(yields$diff.before[ii], brks, all.inside=TRUE)], fill=T, mar=c(1, 2, 3, 0), add=T)#
}#
legend("left", legend=leglabs(round(brks, digits=2)), fill=colors, bty="n", cex=.5)#
#
draw.map("world", yields$region, yields$diff.pred, position="left", digits=2)
draw.map("world", yields$region, yields$diff.pred, position="left", digits=2, ylim=c(-30, 30))
draw.map("world", yields$region, yields$diff.pred, position="left", digits=2, ylim=c(-30, 30))
par(mfrow=c(2, 1))#
#
## Map Before#
colors <- brewer.pal(9, colorscheme)#
brks <- classIntervals(values, n=9, style="quantile")#
brks <- brks$brks#
map("world", ylim=c(-30, 30))#
for (ii in 1:nrow(yields)) {#
    if (is.na(yields$diff.before[ii]))#
        next#
    map("world", yields$region[ii], col=colors[findInterval(yields$diff.before[ii], brks, all.inside=TRUE)], fill=T, mar=c(1, 2, 3, 0), add=T)#
}#
legend("left", legend=leglabs(round(brks, digits=2)), fill=colors, bty="n", cex=.5)#
#
draw.map("world", yields$region, yields$diff.pred, position="left", digits=2, ylim=c(-30, 30))
par(mfrow=c(2, 1))#
#
## Map Before#
colors <- brewer.pal(9, colorscheme)#
brks <- classIntervals(values, n=9, style="quantile")#
brks <- brks$brks#
map("world", ylim=c(-30, 30))#
for (ii in 1:nrow(yields)) {#
    if (is.na(yields$diff.before[ii]))#
        next#
    map("world", yields$region[ii], col=colors[findInterval(yields$diff.before[ii], brks, all.inside=TRUE)], fill=T, mar=c(1, 2, 3, 0), add=T)#
}#
legend("left", legend=leglabs(round(brks, digits=2)), fill=colors, bty="n", cex=.5)#
#
map("world", ylim=c(-30, 30))#
draw.map("world", yields$region, yields$diff.pred, position="left", digits=2, add=T)
par(mfrow=c(2, 1))#
#
## Map Before#
colors <- brewer.pal(9, colorscheme)#
brks <- classIntervals(values, n=9, style="quantile")#
brks <- brks$brks#
map("world", ylim=c(-30, 30))#
for (ii in 1:nrow(yields)) {#
    if (is.na(yields$diff.before[ii]))#
        next#
    map("world", yields$region[ii], col=colors[findInterval(yields$diff.before[ii], brks, all.inside=TRUE)], fill=T, mar=c(1, 2, 3, 0), add=T)#
}#
legend("bottomleft", legend=leglabs(round(brks, digits=2)), fill=colors, bty="n", cex=.5)#
#
map("world", ylim=c(-30, 30))#
draw.map("world", yields$region, yields$diff.pred, position="bottomleft", digits=2, add=T)
par(mfrow=c(2, 1))#
#
## Map Before#
colors <- brewer.pal(9, colorscheme)#
brks <- classIntervals(values, n=9, style="quantile")#
brks <- brks$brks#
map("world", ylim=c(-30, 30), "ICO Report from 1997/1998")#
for (ii in 1:nrow(yields)) {#
    if (is.na(yields$diff.before[ii]))#
        next#
    map("world", yields$region[ii], col=colors[findInterval(yields$diff.before[ii], brks, all.inside=TRUE)], fill=T, mar=c(1, 2, 3, 0), add=T)#
}#
legend("bottomleft", legend=leglabs(round(brks, digits=2)), fill=colors, bty="n", cex=.5)#
#
map("world", ylim=c(-30, 30), main="Predicted for 2015/2016")#
draw.map("world", yields$region, yields$diff.pred, position="bottomleft", digits=2, add=T)
par(mfrow=c(2, 1))#
#
## Map Before#
colors <- brewer.pal(9, colorscheme)#
brks <- classIntervals(values, n=9, style="quantile")#
brks <- brks$brks#
map("world", ylim=c(-30, 30), main="ICO Report from 1997/1998")#
for (ii in 1:nrow(yields)) {#
    if (is.na(yields$diff.before[ii]))#
        next#
    map("world", yields$region[ii], col=colors[findInterval(yields$diff.before[ii], brks, all.inside=TRUE)], fill=T, mar=c(1, 2, 3, 0), add=T)#
}#
legend("bottomleft", legend=leglabs(round(brks, digits=2)), fill=colors, bty="n", cex=.5)#
#
map("world", ylim=c(-30, 30), main="Predicted for 2015/2016")#
draw.map("world", yields$region, yields$diff.pred, position="bottomleft", digits=2, add=T)
par(mfrow=c(2, 1))#
#
## Map Before#
colors <- brewer.pal(9, colorscheme)#
brks <- classIntervals(values, n=9, style="quantile")#
brks <- brks$brks#
map("world", ylim=c(-30, 30), main="ICO Report from 1997/1998")#
for (ii in 1:nrow(yields)) {#
    if (is.na(yields$diff.before[ii]))#
        next#
    map("world", yields$region[ii], col=colors[findInterval(yields$diff.before[ii], brks, all.inside=TRUE)], fill=T, mar=c(1, 2, 3, 0), add=T)#
}#
legend("bottomleft", legend=leglabs(round(brks, digits=2)), fill=colors, bty="n", cex=.5)#
#
map("world", ylim=c(-30, 30), main="Predicted for 2015/2016")#
draw.map("world", yields$region, yields$diff.pred, position="bottomleft", digits=2, add=T)
?map
par(mfrow=c(2, 1))#
#
## Map Before#
colors <- brewer.pal(9, colorscheme)#
brks <- classIntervals(values, n=9, style="quantile")#
brks <- brks$brks#
map("world", ylim=c(-30, 30))#
for (ii in 1:nrow(yields)) {#
    if (is.na(yields$diff.before[ii]))#
        next#
    map("world", yields$region[ii], col=colors[findInterval(yields$diff.before[ii], brks, all.inside=TRUE)], fill=T, mar=c(1, 2, 3, 0), add=T)#
}#
legend("bottomleft", legend=leglabs(round(brks, digits=2)), fill=colors, bty="n", cex=.5)#
#
map("world", ylim=c(-30, 30))#
draw.map("world", yields$region, yields$diff.pred, position="bottomleft", digits=2, add=T)
par(mfrow=c(2, 1))#
#
## Map Before#
colors <- brewer.pal(9, colorscheme)#
brks <- classIntervals(values, n=9, style="quantile")#
brks <- brks$brks#
map("world", ylim=c(-30, 30))#
for (ii in 1:nrow(yields)) {#
    if (is.na(yields$diff.before[ii]))#
        next#
    map("world", yields$region[ii], col=colors[findInterval(yields$diff.before[ii], brks, all.inside=TRUE)], fill=T, mar=c(1, 2, 3, 0), add=T)#
}#
legend("bottomleft", legend=leglabs(round(brks, digits=2)), fill=colors, bty="n", cex=.5)#
#
map("world", ylim=c(-30, 30))#
draw.map("world", yields$region, yields$diff.pred, position="bottomleft", digits=2, add=T)
par(mfrow=c(2, 1))#
#
## Map Before#
colors <- brewer.pal(9, colorscheme)#
brks <- classIntervals(values, n=9, style="quantile")#
brks <- brks$brks#
map("world", ylim=c(-30, 30), mar=c(1, 2, 1, 0))#
for (ii in 1:nrow(yields)) {#
    if (is.na(yields$diff.before[ii]))#
        next#
    map("world", yields$region[ii], col=colors[findInterval(yields$diff.before[ii], brks, all.inside=TRUE)], fill=T, add=T)#
}#
legend("bottomleft", legend=leglabs(round(brks, digits=2)), fill=colors, bty="n", cex=.5)#
#
map("world", ylim=c(-30, 30), mar=c(1, 2, 1, 0))#
draw.map("world", yields$region, yields$diff.pred, position="bottomleft", digits=2, add=T)
par(mfrow=c(2, 1))#
#
## Map Before#
colors <- brewer.pal(9, colorscheme)#
brks <- classIntervals(values, n=9, style="quantile")#
brks <- brks$brks#
map("world", ylim=c(-30, 30), mar=c(0, 0, 0, 0))#
for (ii in 1:nrow(yields)) {#
    if (is.na(yields$diff.before[ii]))#
        next#
    map("world", yields$region[ii], col=colors[findInterval(yields$diff.before[ii], brks, all.inside=TRUE)], fill=T, add=T)#
}#
legend("bottomleft", legend=leglabs(round(brks, digits=2)), fill=colors, bty="n", cex=.5)#
#
map("world", ylim=c(-30, 30), mar=c(0, 0, 0, 0))#
draw.map("world", yields$region, yields$diff.pred, position="bottomleft", digits=2, add=T)
par(mfrow=c(2, 1))#
#
## Map Before#
colors <- brewer.pal(9, colorscheme)#
brks <- classIntervals(values, n=9, style="quantile")#
brks <- brks$brks#
map("world", ylim=c(-30, 30), mar=c(0, 0, 0, 0))#
for (ii in 1:nrow(yields)) {#
    if (is.na(yields$diff.before[ii]))#
        next#
    map("world", yields$region[ii], col=colors[findInterval(yields$diff.before[ii], brks, all.inside=TRUE)], fill=T, add=T)#
}#
legend("bottomleft", legend=leglabs(round(brks, digits=2)), fill=colors, bty="n", cex=.5)#
#
map("world", ylim=c(-30, 30), mar=c(0, 0, 0, 0))#
draw.map("world", yields$region, yields$diff.pred, position="bottomleft", digits=2, add=T)
yields
pca
map("world", rownames(pca$rotation)[61:168], col=colors[findInterval(pca$rotation[61:168,2], brks,all.inside=TRUE)], fill=T, mar=c(1, 2, 3, 0))#
#
plot(pca$rotation[1:12,2], type='l', ylim=c(min(pca$rotation[1:60,2]), max(pca$rotation[1:60,2])), col=2, xlab="Month")#
lines(c(1, 12), c(0, 0))#
lines(pca$rotation[1:12 + 12,2], col=3)#
lines(pca$rotation[1:12 + 24,2], col=4)#
lines(pca$rotation[1:12 + 36,2], col=5)#
lines(pca$rotation[1:12 + 48,2], col=6)#
#
legend("bottomright", c("NINO 3.4", "NAO", "SOI", "PDO", "AMO"), col=2:6, lty=1)
par(mfrow=c(2, 1), c(1, 2, 3, 0))
map("world", rownames(pca$rotation)[61:168], col=colors[findInterval(pca$rotation[61:168,2], brks,all.inside=TRUE)], fill=T, mar=c(1, 2, 3, 0))#
#
plot(pca$rotation[1:12,2], type='l', ylim=c(min(pca$rotation[1:60,2]), max(pca$rotation[1:60,2])), col=2, xlab="Month")#
lines(c(1, 12), c(0, 0))#
lines(pca$rotation[1:12 + 12,2], col=3)#
lines(pca$rotation[1:12 + 24,2], col=4)#
lines(pca$rotation[1:12 + 36,2], col=5)#
lines(pca$rotation[1:12 + 48,2], col=6)#
#
legend("bottomright", c("NINO 3.4", "NAO", "SOI", "PDO", "AMO"), col=2:6, lty=1)
library(RColorBrewer)#
colors <- brewer.pal(9, "RdYlGn")#
#
library(classInt)#
brks<-classIntervals(pca$rotation[61:168,1], n=9, style="quantile")#
brks<- brks$brks
map("world", rownames(pca$rotation)[61:168], col=colors[findInterval(-pca$rotation[61:168,2], brks,all.inside=TRUE)], fill=T, mar=c(1, 2, 3, 0))#
#
plot(-pca$rotation[1:12,2], type='l', ylim=c(min(-pca$rotation[1:60,2]), max(-pca$rotation[1:60,2])), col=2, xlab="Month")#
lines(c(1, 12), c(0, 0))#
lines(-pca$rotation[1:12 + 12,2], col=3)#
lines(-pca$rotation[1:12 + 24,2], col=4)#
lines(-pca$rotation[1:12 + 36,2], col=5)#
lines(-pca$rotation[1:12 + 48,2], col=6)#
#
legend("bottomright", c("NINO 3.4", "NAO", "SOI", "PDO", "AMO"), col=2:6, lty=1)
map("world", rownames(pca$rotation)[61:168], col=colors[findInterval(-pca$rotation[61:168,2], brks,all.inside=TRUE)], fill=T, mar=c(1, 2, 3, 0))
map("world", rownames(pca$rotation)[61:168], col=colors[findInterval(pca$rotation[61:168,2], brks,all.inside=TRUE)], fill=T, mar=c(1, 2, 3, 0))
as.numeric(pca$rotation[61:168,])
abs(as.numeric(pca$rotation[61:168,]))
brks<-classIntervals(c(-abs(as.numeric(pca$rotation[61:168,])), abs(as.numeric(pca$rotation[61:168,]))), n=9, style="quantile")#
brks<- brks$brks
map("world", rownames(pca$rotation)[61:168], col=colors[findInterval(-pca$rotation[61:168,2], brks,all.inside=TRUE)], fill=T, mar=c(1, 2, 3, 0))#
#
plot(-pca$rotation[1:12,2], type='l', ylim=c(min(-pca$rotation[1:60,2]), max(-pca$rotation[1:60,2])), col=2, xlab="Month")#
lines(c(1, 12), c(0, 0))#
lines(-pca$rotation[1:12 + 12,2], col=3)#
lines(-pca$rotation[1:12 + 24,2], col=4)#
lines(-pca$rotation[1:12 + 36,2], col=5)#
lines(-pca$rotation[1:12 + 48,2], col=6)#
#
legend("bottomright", c("NINO 3.4", "NAO", "SOI", "PDO", "AMO"), col=2:6, lty=1)
par(mfrow=c(2, 1), c(1, 2, 3, 0))#
#
map("world", rownames(pca$rotation)[61:168], col=colors[findInterval(pca$rotation[61:168,1], brks,all.inside=TRUE)], fill=T, mar=c(1, 2, 3, 0))#
#
plot(pca$rotation[1:12,1], type='l', ylim=c(min(pca$rotation[1:60,1]), max(pca$rotation[1:60,1])), col=2, xlab="Month")#
lines(c(1, 12), c(0, 0))#
lines(pca$rotation[1:12 + 12,1], col=3)#
lines(pca$rotation[1:12 + 24,1], col=4)#
lines(pca$rotation[1:12 + 36,1], col=5)#
lines(pca$rotation[1:12 + 48,1], col=6)
legend("bottomright", c("NINO 3.4", "NAO", "SOI", "PDO", "AMO"), col=2:6, lty=1)
map("world", rownames(pca$rotation)[61:168], col=colors[findInterval(-pca$rotation[61:168,2], brks,all.inside=TRUE)], fill=T, mar=c(1, 2, 3, 0))#
#
plot(-pca$rotation[1:12,2], type='l', ylim=c(min(-pca$rotation[1:60,2]), max(-pca$rotation[1:60,2])), col=2, xlab="Month")#
lines(c(1, 12), c(0, 0))#
lines(-pca$rotation[1:12 + 12,2], col=3)#
lines(-pca$rotation[1:12 + 24,2], col=4)#
lines(-pca$rotation[1:12 + 36,2], col=5)#
lines(-pca$rotation[1:12 + 48,2], col=6)#
#
legend("bottomright", c("NINO 3.4", "NAO", "SOI", "PDO", "AMO"), col=2:6, lty=1)
map("world", rownames(pca$rotation)[61:168], col=colors[findInterval(-pca$rotation[61:168,2], brks,all.inside=TRUE)], fill=T, mar=c(1, 2, 3, 0))#
#
plot(-pca$rotation[1:12,2], type='l', ylim=c(min(-pca$rotation[1:60,2]), max(-pca$rotation[1:60,2])), col=2, xlab="Month")#
lines(c(1, 12), c(0, 0))#
lines(-pca$rotation[1:12 + 12,2], col=3)#
lines(-pca$rotation[1:12 + 24,2], col=4)#
lines(-pca$rotation[1:12 + 36,2], col=5)#
lines(-pca$rotation[1:12 + 48,2], col=6)#
#
legend("bottomright", c("NINO 3.4", "NAO", "SOI", "PDO", "AMO"), col=2:6, lty=1)
par(mfrow=c(2, 1), c(1, 2, 3, 0))
map("world", rownames(pca$rotation)[61:168], col=colors[findInterval(-pca$rotation[61:168,2], brks,all.inside=TRUE)], fill=T, mar=c(1, 2, 3, 0))#
#
plot(-pca$rotation[1:12,2], type='l', ylim=c(min(-pca$rotation[1:60,2]), max(-pca$rotation[1:60,2])), col=2, xlab="Month")#
lines(c(1, 12), c(0, 0))#
lines(-pca$rotation[1:12 + 12,2], col=3)#
lines(-pca$rotation[1:12 + 24,2], col=4)#
lines(-pca$rotation[1:12 + 36,2], col=5)#
lines(-pca$rotation[1:12 + 48,2], col=6)#
#
legend("bottomright", c("NINO 3.4", "NAO", "SOI", "PDO", "AMO"), col=2:6, lty=1)
par(mfrow=c(2, 1), c(1, 2, 3, 0))
map("world", rownames(pca$rotation)[61:168], col=colors[findInterval(-pca$rotation[61:168,3], brks,all.inside=TRUE)], fill=T, mar=c(1, 2, 3, 0))#
#
plot(-pca$rotation[1:12,3], type='l', ylim=c(min(-pca$rotation[1:60,3]), max(-pca$rotation[1:60,3])), col=2, xlab="Month")#
lines(c(1, 12), c(0, 0))#
lines(-pca$rotation[1:12 + 12,3], col=3)#
lines(-pca$rotation[1:12 + 24,3], col=4)#
lines(-pca$rotation[1:12 + 36,3], col=5)#
lines(-pca$rotation[1:12 + 48,3], col=6)#
#
legend("bottomright", c("NINO 3.4", "NAO", "SOI", "PDO", "AMO"), col=2:6, lty=1)
plot(0, 1, xlim=c(-10, 10), ylim=c(-1, 1))#
require(graphics)#
rect(seq(-1, .8, length.out=10), -.9, seq(-.8, 1, length.out=10), -1,#
       col=brewer.pal(9, "RdYlGn"), border="light gray")
plot(0, 1, xlim=c(-1, 1), ylim=c(-1, 1))#
require(graphics)#
rect(seq(-1, .8, length.out=10), -.9, seq(-.8, 1, length.out=10), -1,#
       col=brewer.pal(9, "RdYlGn"), border="light gray")
rect(seq(-1, .8, length.out=9), -.9, seq(-.8, 1, length.out=9), -1,#
       col=brewer.pal(9, "RdYlGn"), border="light gray")
plot(0, 1, xlim=c(-1, 1), ylim=c(-1, 1))#
require(graphics)#
rect(seq(-1, .8, length.out=9), -.9, seq(-.8, 1, length.out=9), -1,#
       col=brewer.pal(9, "RdYlGn"), border="light gray")
brks
text(seq(-.9, .9, length.out=9), -.95, round((brks[-1] + brks[-10])/2, digits=2), cex=.5)
require(graphics)#
plot(0, 1, xlim=c(-1, 1), ylim=c(-1, 1))#
rect(seq(-1, .8, length.out=9), -.9, seq(-.8, 1, length.out=9), -1,#
       col=brewer.pal(9, "RdYlGn"), border="light gray")#
text(seq(-.9, .9, length.out=9), -.95, round((brks[-1] + brks[-10])/2, digits=2), cex=.8)
yields <- read.csv("yields2.csv") # yields.csv#
yields$region <- as.character(yields$region)#
yields$region[yields$region == "Venezuela (Bolivarian Republic of)"] <- "Venezuela"#
yields$region[yields$region == "Viet Nam"] <- "Vietnam"#
yields$region[yields$region == "Côte d'Ivoire"] <- "Cote d'Ivoire"#
#
yields$percent <- NA
percent1997 = list("Mexico"=-6.96, "Guatemala"=-22.63, "El Salvador"=5.65, "Costa Rica"=21.24, "Honduras"=14.77, "Nicaragua"=40.61, "Brazil"=-31.63, "Colombia"=-3.43, "Ecuador"=-12.09, "Peru"=4.88, "Venezuela"=-20.35, "Indonesia"=-17.21, "Papua New Guinea"=-18.46, "Vietnam"=2.24, "India"=9.54, "Thailand"=-11.84, "Philippines"=5.06, "Cote d'Ivoire"=3.13, "Cameroon"=-1.05, "Uganda"=-6.04, "Kenya"=-11.72, "Ethiopia"=17.25, "Madagascar"=-5.88, "Angola"=83.10)#
for (name in names(percent1997)) {#
    if (!(name %in% yields$region)) {#
        print(paste("Cannot find", name))#
        next#
    }#
#
    yields$percent[yields$region == name] <- percent1997[[name]]#
}#
#
source("~/projects/coffee/lib/production.R")#
faostat <- load.faostat()
yields$yield1996 <- NA#
#
for (country in unique(faostat$Country)) {#
    mycountry <- country#
    if (country == "Côte d'Ivoire")#
        mycountry <- "Cote d'Ivoire"#
    if (country == "Venezuela (Bolivarian Republic of)")#
        mycountry <- "Venezuela"#
    if (country == "Viet Nam")#
        mycountry <- "Vietnam"#
#
    if (!(mycountry %in% yields$region)) {#
        print(paste("Cannot find", country))#
        next#
    }#
#
    valid <- faostat$Country == country & faostat$Year == 1996#
    if (sum(valid) == 0)#
        next#
#
    yields$yield1996[yields$region == mycountry] <- faostat$CorrectedYield[valid]#
}
yields$diff.before <- yields$yield1996 * (1 + yields$percent / 100) - yields$yield1996#
yields$diff.pred <- yields$yield2016 - yields$yield2015#
yields$region[yields$region == "Bolivia (Plurinational State of)"] <- "Bolivia"#
yields$region[yields$region == "Cote d'Ivoire"] <- "Ivory Coast"
par(mfrow=c(2, 1))#
#
## Map Before#
colors <- brewer.pal(9, colorscheme)#
brks <- classIntervals(values, n=9, style="quantile")#
brks <- brks$brks#
map("world", ylim=c(-30, 30), mar=c(1, 2, 1, 0))#
for (ii in 1:nrow(yields)) {#
    if (is.na(yields$diff.before[ii]))#
        next#
    map("world", yields$region[ii], col=colors[findInterval(yields$diff.before[ii], brks, all.inside=TRUE)], fill=T, add=T)#
}#
legend("bottomleft", legend=leglabs(round(brks, digits=2)), fill=colors, bty="n", cex=.5)#
#
map("world", ylim=c(-30, 30), mar=c(1, 2, 1, 0))#
draw.map("world", yields$region, yields$diff.pred, position="bottomleft", digits=2, add=T)
yields
values <- c(yields$diff.before, yields$diff.pred)
## Use all values for colors#
values <- c(yields$diff.before, yields$diff.pred)#
#
## Map Before#
colors <- brewer.pal(9, colorscheme)#
brks <- classIntervals(values, n=9, style="quantile")#
brks <- brks$brks
par(mfrow=c(2, 1))#
#
map("world", ylim=c(-30, 30), mar=c(1, 2, 1, 0))#
for (ii in 1:nrow(yields)) {#
    if (is.na(yields$diff.before[ii]))#
        next#
    map("world", yields$region[ii], col=colors[findInterval(yields$diff.before[ii], brks, all.inside=TRUE)], fill=T, add=T)#
}#
legend("bottomleft", legend=leglabs(round(brks, digits=2)), fill=colors, bty="n", cex=.5)#
#
map("world", ylim=c(-30, 30), mar=c(1, 2, 1, 0))#
for (ii in 1:nrow(yields)) {#
    if (is.na(yields$diff.pred[ii]))#
        next#
    map("world", yields$region[ii], col=colors[findInterval(yields$diff.pred[ii], brks, all.inside=TRUE)], fill=T, add=T)#
}#
legend("bottomleft", legend=leglabs(round(brks, digits=2)), fill=colors, bty="n", cex=.5)
ii
yields$region[ii]
map("world", ylim=c(-30, 30), mar=c(1, 2, 1, 0))#
for (ii in 1:nrow(yields)) {#
    if (is.na(yields$diff.pred[ii]))#
        next#
    tryCatch({#
        map("world", yields$region[ii], col=colors[findInterval(yields$diff.pred[ii], brks, all.inside=TRUE)], fill=T, add=T)#
    })#
}
?tryCatch
map("world", ylim=c(-30, 30), mar=c(1, 2, 1, 0))#
for (ii in 1:nrow(yields)) {#
    if (is.na(yields$diff.pred[ii]))#
        next#
    tryCatch({#
        map("world", yields$region[ii], col=colors[findInterval(yields$diff.pred[ii], brks, all.inside=TRUE)], fill=T, add=T)#
    }, finally=function() {})#
}#
legend("bottomleft", legend=leglabs(round(brks, digits=2)), fill=colors, bty="n", cex=.5)
ii
tryCatch({#
        map("world", yields$region[ii], col=colors[findInterval(yields$diff.pred[ii], brks, all.inside=TRUE)], fill=T, add=T)#
    }, finally=function() {})
tryCatch({#
        map("world", yields$region[ii], col=colors[findInterval(yields$diff.pred[ii], brks, all.inside=TRUE)], fill=T, add=T)#
    }, error=function() {})
tryCatch({#
        map("world", yields$region[ii], col=colors[findInterval(yields$diff.pred[ii], brks, all.inside=TRUE)], fill=T, add=T)#
    }, error=function(cond) {})
map("world", ylim=c(-30, 30), mar=c(1, 2, 1, 0))#
for (ii in 1:nrow(yields)) {#
    if (is.na(yields$diff.pred[ii]))#
        next#
    tryCatch({#
        map("world", yields$region[ii], col=colors[findInterval(yields$diff.pred[ii], brks, all.inside=TRUE)], fill=T, add=T)#
    }, error=function(cond) {})#
}#
legend("bottomleft", legend=leglabs(round(brks, digits=2)), fill=colors, bty="n", cex=.5)
par(mfrow=c(2, 1))#
#
map("world", ylim=c(-30, 30), mar=c(1, 2, 1, 0))#
for (ii in 1:nrow(yields)) {#
    if (is.na(yields$diff.before[ii]))#
        next#
    map("world", yields$region[ii], col=colors[findInterval(yields$diff.before[ii], brks, all.inside=TRUE)], fill=T, add=T)#
}#
legend("bottomleft", legend=leglabs(round(brks, digits=2)), fill=colors, bty="n", cex=.5)#
#
map("world", ylim=c(-30, 30), mar=c(1, 2, 1, 0))#
for (ii in 1:nrow(yields)) {#
    if (is.na(yields$diff.pred[ii]))#
        next#
    tryCatch({#
        map("world", yields$region[ii], col=colors[findInterval(yields$diff.pred[ii], brks, all.inside=TRUE)], fill=T, add=T)#
    }, error=function(cond) {})#
}#
legend("bottomleft", legend=leglabs(round(brks, digits=2)), fill=colors, bty="n", cex=.5)
