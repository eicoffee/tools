y ~ a + b | b ~ c | z ~ c + d
y ~ A a + B b | B b ~ C c | z ~ c + d
y ~ a + b | b - c | z ~ c + d
terms(y ~ a + b | b - c | z ~ c + d)
as.character(y ~ a + b | b - c | z ~ c + d)
?grepl
#' Combine two formulas in hierlm-format#
#'#
#' Return the left and right side of a new combined formula.#
#' Left formula must be a standard formula.  Right formula may take the following forms:#
#' y ~ ... : an lm-style formula; the left-hand-side variables much match#
#' a - b : A requirement that two variables be close together (typically one is a factor)#
#' TODO:#
#' a + B : A requirement that the factors in 'a' are similar to eachother by smoothness 'B'#
#'#
#' @param formula1 an lm-style formula#
#' @param formula2 an additional formula or hierlm term#
#' @return Augmented formula#
#' @examples#
#' combine.formulae(combine.formulae(y ~ a + b, "b - c"), y ~ c + d)#
#
combine.formulae <- function(formula1, formula2) {#
    chunks1 <- as.character(formula1)#
#
    if (is.character(formula2))#
        if (grepl("~", formula2))#
            formula2 <- as.formula(formula2)#
#
    if (is.formula(formula2)) {#
        chunks2 <- as.character(formula2)#
        if (chunks2[2] != chunks1[2])#
            error("Left-hand-side variables do not match.")#
#
        terms1 <- get.formula.terms(formula1)#
        terms2 <- get.formula.terms(formula2)#
    } else {#
        terms2 <- strsplit(formula2, "-")[[1]]#
        terms2 <- gsub("^\\s+|\\s+$", "", terms2)#
#
        terms1 <- get.formula.terms(formula1)#
    }#
#
    for (term in terms2)#
        if (!(term %in% terms1))#
            terms1 <- c(terms1, term)#
#
    as.formula(paste(chunks[2], "~", paste(terms1, collapse=" + ")))#
}
combine.formulae(combine.formulae(y ~ a + b, "b - c"), y ~ c + d)
?formula
class(y ~ x)
#' Combine two formulas in hierlm-format#
#'#
#' Return the left and right side of a new combined formula.#
#' Left formula must be a standard formula.  Right formula may take the following forms:#
#' y ~ ... : an lm-style formula; the left-hand-side variables much match#
#' a - b : A requirement that two variables be close together (typically one is a factor)#
#' TODO:#
#' a + B : A requirement that the factors in 'a' are similar to eachother by smoothness 'B'#
#'#
#' @param formula1 an lm-style formula#
#' @param formula2 an additional formula or hierlm term#
#' @return Augmented formula#
#' @examples#
#' combine.formulae(combine.formulae(y ~ a + b, "b - c"), y ~ c + d)#
#
combine.formulae <- function(formula1, formula2) {#
    chunks1 <- as.character(formula1)#
#
    if (is.character(formula2))#
        if (grepl("~", formula2))#
            formula2 <- as.formula(formula2)#
#
    if (class(formula2) == "formula") {#
        chunks2 <- as.character(formula2)#
        if (chunks2[2] != chunks1[2])#
            error("Left-hand-side variables do not match.")#
#
        terms1 <- get.formula.terms(formula1)#
        terms2 <- get.formula.terms(formula2)#
    } else {#
        terms2 <- strsplit(formula2, "-")[[1]]#
        terms2 <- gsub("^\\s+|\\s+$", "", terms2)#
#
        terms1 <- get.formula.terms(formula1)#
    }#
#
    for (term in terms2)#
        if (!(term %in% terms1))#
            terms1 <- c(terms1, term)#
#
    as.formula(paste(chunks[2], "~", paste(terms1, collapse=" + ")))#
}
combine.formulae(combine.formulae(y ~ a + b, "b - c"), y ~ c + d)
#' Extract the terms from an lm formula#
#'#
#' Return a list of terms in an lm formula, in the order they appear#
#'#
#' @param formula lm-style formula#
#' @return Vector of the terms in the lm formula#
#' @examples#
#' get.formula.terms(Sepal.Length ~ Petal.Length + Species + Sepal.Width : Species)#
#
get.formula.terms <- function(formula) {#
    terms <- strsplit(as.character(formula)[3], "\\+")[[1]]#
    gsub("^\\s+|\\s+$", "", terms)#
}
combine.formulae(combine.formulae(y ~ a + b, "b - c"), y ~ c + d)
#' Combine two formulas in hierlm-format#
#'#
#' Return the left and right side of a new combined formula.#
#' Left formula must be a standard formula.  Right formula may take the following forms:#
#' y ~ ... : an lm-style formula; the left-hand-side variables much match#
#' a - b : A requirement that two variables be close together (typically one is a factor)#
#' TODO:#
#' a + B : A requirement that the factors in 'a' are similar to eachother by smoothness 'B'#
#'#
#' @param formula1 an lm-style formula#
#' @param formula2 an additional formula or hierlm term#
#' @return Augmented formula#
#' @examples#
#' combine.formulae(combine.formulae(y ~ a + b, "b - c"), y ~ c + d)#
#
combine.formulae <- function(formula1, formula2) {#
    chunks1 <- as.character(formula1)#
#
    if (is.character(formula2))#
        if (grepl("~", formula2))#
            formula2 <- as.formula(formula2)#
#
    if (class(formula2) == "formula") {#
        chunks2 <- as.character(formula2)#
        if (chunks2[2] != chunks1[2])#
            error("Left-hand-side variables do not match.")#
#
        terms1 <- get.formula.terms(formula1)#
        terms2 <- get.formula.terms(formula2)#
    } else {#
        terms2 <- strsplit(formula2, "-")[[1]]#
        terms2 <- gsub("^\\s+|\\s+$", "", terms2)#
#
        terms1 <- get.formula.terms(formula1)#
    }#
#
    for (term in terms2)#
        if (!(term %in% terms1))#
            terms1 <- c(terms1, term)#
#
    as.formula(paste(chunks1[2], "~", paste(terms1, collapse=" + ")))#
}
combine.formulae(combine.formulae(y ~ a + b, "b - c"), y ~ c + d)
?as.formula
?env
terms(y ~ a)
attr(y ~ a, '.Environment')
#' Combine two formulas in hierlm-format#
#'#
#' Return the left and right side of a new combined formula.#
#' Left formula must be a standard formula.  Right formula may take the following forms:#
#' y ~ ... : an lm-style formula; the left-hand-side variables much match#
#' a - b : A requirement that two variables be close together (typically one is a factor)#
#' TODO:#
#' a + B : A requirement that the factors in 'a' are similar to eachother by smoothness 'B'#
#'#
#' @param formula1 an lm-style formula#
#' @param formula2 an additional formula or hierlm term#
#' @return Augmented formula#
#' @examples#
#' combine.formulae(combine.formulae(y ~ a + b, "b - c"), y ~ c + d)#
#
combine.formulae <- function(formula1, formula2) {#
    chunks1 <- as.character(formula1)#
#
    if (is.character(formula2))#
        if (grepl("~", formula2))#
            formula2 <- as.formula(formula2)#
#
    if (class(formula2) == "formula") {#
        chunks2 <- as.character(formula2)#
        if (chunks2[2] != chunks1[2])#
            error("Left-hand-side variables do not match.")#
#
        terms1 <- get.formula.terms(formula1)#
        terms2 <- get.formula.terms(formula2)#
    } else {#
        terms2 <- strsplit(formula2, "-")[[1]]#
        terms2 <- gsub("^\\s+|\\s+$", "", terms2)#
#
        terms1 <- get.formula.terms(formula1)#
    }#
#
    for (term in terms2)#
        if (!(term %in% terms1))#
            terms1 <- c(terms1, term)#
#
    as.formula(paste(chunks1[2], "~", paste(terms1, collapse=" + ")),#
               env=attr(formula1, '.Environment'))#
}
combine.formulae(combine.formulae(y ~ a + b, "b - c"), y ~ c + d)
#' Combine two formulas in hierlm-format#
#'#
#' Return the left and right side of a new combined formula.#
#' Left formula must be a standard formula.  Right formula may take the following forms:#
#' y ~ ... : an lm-style formula; the left-hand-side variables much match#
#' a - b : A requirement that two variables be close together (typically one is a factor)#
#' TODO:#
#' a + B : A requirement that the factors in 'a' are similar to eachother by smoothness 'B'#
#'#
#' @param formula1 an lm-style formula#
#' @param formula2 an additional formula or hierlm term#
#' @return Augmented formula#
#' @examples#
#' combine.formulae(combine.formulae(y ~ a + b, "b - c"), y ~ c + d)#
#
combine.formulae <- function(formula1, formula2) {#
    chunks1 <- as.character(formula1)#
#
    if (is.character(formula2))#
        if (grepl("~", formula2))#
            formula2 <- as.formula(formula2)#
#
    if (class(formula2) == "formula") {#
        chunks2 <- as.character(formula2)#
        if (chunks2[2] != chunks1[2])#
            error("Left-hand-side variables do not match.")#
#
        terms1 <- get.formula.terms(formula1)#
        terms2 <- get.formula.terms(formula2)#
    } else {#
        terms2 <- strsplit(formula2, "-")[[1]]#
        terms2 <- gsub("^\\s+|\\s+$", "", terms2)#
#
        terms1 <- get.formula.terms(formula1)#
        if (attr(terms(formula1), 'intercept') == 0) {#
            if (!("0" %in% terms1))#
                terms1 <- c("0", terms1)#
        } else {#
            if (!("0" %in% terms1 && "constant" %in% terms1))#
                terms1 <- c("0", "constant", terms1)#
        }#
    }#
#
    for (term in terms2)#
        if (!(term %in% terms1))#
            terms1 <- c(terms1, term)#
#
    as.formula(paste(chunks1[2], "~", paste(terms1, collapse=" + ")),#
               env=attr(formula1, '.Environment'))#
}
combine.formulae(combine.formulae(y ~ a + b, "b - c"), y ~ c + d)
Sepal.Length ~ Petal.Length + Species + Sepal.Width : Species | Species - . | Sepal.Width : Species - .
as.character(Sepal.Length ~ Petal.Length + Species + Sepal.Width : Species | Species - . | Sepal.Width : Species - .)
#' Combine two formulas in hierlm-format#
#'#
#' Return the left and right side of a new combined formula.#
#' Left formula must be a standard formula.  Right formula may take the following forms:#
#' y ~ ... : an lm-style formula; the left-hand-side variables much match#
#' f - b : A requirement that two variables be close together (typically one is a factor)#
#' f - . : A requirement that a variable (or set of factors) be close to a new hyper-variable#
#' a : f - [b or .] : A requirement that the results of an interaction be near a hyper-variable#
#' TODO:#
#' a + B : A requirement that the factors in 'a' are similar to eachother by smoothness 'B'#
#'#
#' @param formula1 an lm-style formula#
#' @param formula2 an additional formula or hierlm term#
#' @return Augmented formula#
#' @examples#
#' combine.formulae(combine.formulae(combine.formulae(y ~ a + b, "b - c"), y ~ c + d), "c : d - .")#
#
combine.formulae <- function(formula1, formula2, sep="") {#
    chunks1 <- as.character(formula1)#
#
    if (is.character(formula2))#
        if (grepl("~", formula2))#
            formula2 <- as.formula(formula2)#
#
    if (class(formula2) == "formula") {#
        chunks2 <- as.character(formula2)#
        if (chunks2[2] != chunks1[2])#
            error("Left-hand-side variables do not match.")#
#
        terms1 <- get.formula.terms(formula1)#
        terms2 <- get.formula.terms(formula2)#
    } else {#
        terms2 <- strsplit(formula2, "-")[[1]]#
        terms2 <- gsub("^\\s+|\\s+$", "", terms2)#
        if ("." %in% terms2) {#
            nonhyper <- terms2[terms2 != "."]#
            if (grepl(':', nonhyper)) {#
                subterms <- strsplit(nonhyper, ":")[[1]]#
                subterms <- gsub("^\\s+|\\s+$", "", subterms)#
                hyper <- paste("hyper", paste(subterms, collapse=sep), sep=sep)#
            } else {#
                hyper <- paste("hyper", nonhyper, sep=sep)#
            }#
            terms2 <- c(nonhyper, hyper)#
        }#
#
        terms1 <- get.formula.terms(formula1)#
        if (attr(terms(formula1), 'intercept') == 0) {#
            if (!("0" %in% terms1))#
                terms1 <- c("0", terms1)#
        } else {#
            if (!("0" %in% terms1 && "constant" %in% terms1))#
                terms1 <- c("0", "constant", terms1)#
        }#
    }#
#
    for (term in terms2)#
        if (!(term %in% terms1))#
            terms1 <- c(terms1, term)#
#
    as.formula(paste(chunks1[2], "~", paste(terms1, collapse=" + ")),#
               env=attr(formula1, '.Environment'))#
}
combine.formulae(combine.formulae(combine.formulae(y ~ a + b, "b - c"), y ~ c + d), "c : d - .")
#' Combine two formulas in hierlm-format#
#'#
#' Return the left and right side of a new combined formula.#
#' Left formula must be a standard formula.  Right formula may take the following forms:#
#' y ~ ... : an lm-style formula; the left-hand-side variables much match#
#' f - b : A requirement that two variables be close together (typically one is a factor)#
#' f - . : A requirement that a variable (or set of factors) be close to a new hyper-variable#
#' a : f - [b or .] : A requirement that the results of an interaction be near a hyper-variable#
#' TODO:#
#' a + B : A requirement that the factors in 'a' are similar to eachother by smoothness 'B'#
#'#
#' @param formula1 an lm-style formula#
#' @param formula2 an additional formula or hierlm term#
#' @return Augmented formula#
#' @examples#
#' combine.formulae(combine.formulae(combine.formulae(y ~ a + b, "b - c"), y ~ c + d), "c : d - .")#
#
combine.formulae <- function(formula1, formula2, sep="") {#
    chunks1 <- as.character(formula1)#
#
    if (is.character(formula2))#
        if (grepl("~", formula2))#
            formula2 <- as.formula(formula2)#
#
    if (class(formula2) == "formula") {#
        chunks2 <- as.character(formula2)#
        if (chunks2[2] != chunks1[2])#
            error("Left-hand-side variables do not match.")#
#
        terms1 <- get.formula.terms(formula1)#
        terms2 <- get.formula.terms(formula2)#
    } else {#
        terms2 <- get.hyper.terms(formula2)#
        if (length(terms2) != 3)#
            error(paste("Cannot understand expression:", formula2))#
#
        terms2 <- terms2[-3]#
#
        terms1 <- get.formula.terms(formula1)#
        if (attr(terms(formula1), 'intercept') == 0) {#
            if (!("0" %in% terms1))#
                terms1 <- c("0", terms1)#
        } else {#
            if (!("0" %in% terms1 && "constant" %in% terms1))#
                terms1 <- c("0", "constant", terms1)#
        }#
    }#
#
    for (term in terms2)#
        if (!(term %in% terms1))#
            terms1 <- c(terms1, term)#
#
    as.formula(paste(chunks1[2], "~", paste(terms1, collapse=" + ")),#
               env=attr(formula1, '.Environment'))#
}
combine.formulae(combine.formulae(combine.formulae(y ~ a + b, "b - c"), y ~ c + d), "c : d - .")
#' Get any new hyper terms from formula#
#'#
#' If the "a - b" formula requires the creation of a new hyper terms#
#' (one of a or b is .), return them.#
#'#
#' @param formula Single component of a hierlm formula#
#' @return Vector of c(nonhyper, hyper, is.interaction), if a new one was created;#
#'   or c(left, right, NA) if both terms are given;#
#'   or c() if not an "a - b" expression#
#' @examples#
#' get.formula.terms(Sepal.Length ~ Petal.Length + Species + Sepal.Width : Species)#
#
get.hyper.terms <- function(formula) {#
    if (class(formula) == "formula")#
        return(c())#
#
    terms <- strsplit(formula, "-")[[1]]#
    if (length(terms) != 2)#
        return(c())#
#
    terms <- gsub("^\\s+|\\s+$", "", terms)#
    if ("." %in% terms) {#
        nonhyper <- terms[terms != "."]#
        if (grepl(':', nonhyper)) {#
            subterms <- strsplit(nonhyper, ":")[[1]]#
            subterms <- gsub("^\\s+|\\s+$", "", subterms)#
            hyper <- paste("hyper", paste(subterms, collapse=sep), sep=sep)#
            return(c(nonhyper, hyper, T))#
        } else {#
            hyper <- paste("hyper", nonhyper, sep=sep)#
            return(c(nonhyper, hyper, F))#
        }#
    }#
    return(c(terms, NA))#
}
combine.formulae(combine.formulae(combine.formulae(y ~ a + b, "b - c"), y ~ c + d), "c : d - .")
#' Combine two formulas in hierlm-format#
#'#
#' Return the left and right side of a new combined formula.#
#' Left formula must be a standard formula.  Right formula may take the following forms:#
#' y ~ ... : an lm-style formula; the left-hand-side variables much match#
#' f - b : A requirement that two variables be close together (typically one is a factor)#
#' f - . : A requirement that a variable (or set of factors) be close to a new hyper-variable#
#' a : f - [b or .] : A requirement that the results of an interaction be near a hyper-variable#
#' TODO:#
#' a + B : A requirement that the factors in 'a' are similar to eachother by smoothness 'B'#
#'#
#' @param formula1 an lm-style formula#
#' @param formula2 an additional formula or hierlm term#
#' @return Augmented formula#
#' @examples#
#' combine.formulae(combine.formulae(combine.formulae(y ~ a + b, "b - c"), y ~ c + d), "c : d - .")#
#
combine.formulae <- function(formula1, formula2, sep="") {#
    chunks1 <- as.character(formula1)#
#
    if (is.character(formula2))#
        if (grepl("~", formula2))#
            formula2 <- as.formula(formula2)#
#
    if (class(formula2) == "formula") {#
        chunks2 <- as.character(formula2)#
        if (chunks2[2] != chunks1[2])#
            error("Left-hand-side variables do not match.")#
#
        terms1 <- get.formula.terms(formula1)#
        terms2 <- get.formula.terms(formula2)#
    } else {#
        terms2 <- get.hyper.terms(formula2, sep=sep)#
        if (length(terms2) != 3)#
            error(paste("Cannot understand expression:", formula2))#
#
        terms2 <- terms2[-3]#
#
        terms1 <- get.formula.terms(formula1)#
        if (attr(terms(formula1), 'intercept') == 0) {#
            if (!("0" %in% terms1))#
                terms1 <- c("0", terms1)#
        } else {#
            if (!("0" %in% terms1 && "constant" %in% terms1))#
                terms1 <- c("0", "constant", terms1)#
        }#
    }#
#
    for (term in terms2)#
        if (!(term %in% terms1))#
            terms1 <- c(terms1, term)#
#
    as.formula(paste(chunks1[2], "~", paste(terms1, collapse=" + ")),#
               env=attr(formula1, '.Environment'))#
}
combine.formulae(combine.formulae(combine.formulae(y ~ a + b, "b - c"), y ~ c + d), "c : d - .")
#' Get any new hyper terms from formula#
#'#
#' If the "a - b" formula requires the creation of a new hyper terms#
#' (one of a or b is .), return them.#
#'#
#' @param formula Single component of a hierlm formula#
#' @return Vector of c(nonhyper, hyper, is.interaction), if a new one was created;#
#'   or c(left, right, NA) if both terms are given;#
#'   or c() if not an "a - b" expression#
#' @examples#
#' get.formula.terms(Sepal.Length ~ Petal.Length + Species + Sepal.Width : Species)#
#
get.hyper.terms <- function(formula, sep="") {#
    if (class(formula) == "formula")#
        return(c())#
#
    terms <- strsplit(formula, "-")[[1]]#
    if (length(terms) != 2)#
        return(c())#
#
    terms <- gsub("^\\s+|\\s+$", "", terms)#
    if ("." %in% terms) {#
        nonhyper <- terms[terms != "."]#
        if (grepl(':', nonhyper)) {#
            subterms <- strsplit(nonhyper, ":")[[1]]#
            subterms <- gsub("^\\s+|\\s+$", "", subterms)#
            hyper <- paste("hyper", paste(subterms, collapse=sep), sep=sep)#
            return(c(nonhyper, hyper, T))#
        } else {#
            hyper <- paste("hyper", nonhyper, sep=sep)#
            return(c(nonhyper, hyper, F))#
        }#
    }#
    return(c(terms, NA))#
}
combine.formulae(combine.formulae(combine.formulae(y ~ a + b, "b - c"), y ~ c + d), "c : d - .")
diag(3, 3)
diag(1, 3)
diag(2, 3)
#' Create fictional observations for a hyper relationship#
#'#
#' Return a data frame with fictional observations#
#'#
#' @param nonhyper name of the non-hyper column#
#' @param hyper name of the hyper column#
#' @param weight weight to be used in the rows#
#' @param data a data frame for inspecting levels#
#' @return Fictional observations in a data frame#
#' @examples#
#' make.hyper.noninteract("Species", "hyperSpecies", 5, iris)#
#
make.hyper.noninteract <- function(nonhyper, hyper, weight, data, sep="") {#
    ## Construct extra from diagonal factor matrix#
    extras <- diag(weight, length(unique(data[, nonhyper])))#
    col.names(extras) <- paste(nonhyper, unique(data[, nonhyper]), sep=sep)#
    extras <- as.data.frame(extras)#
#
    ## Add in the hyper column#
    extras[, hyper] <- -weight#
}
make.hyper.noninteract("Species", "hyperSpecies", 5, iris)
class(diag(3))
?matrix
names(diag(3))
names(diag(3)) = c(1, 2, 3)
#' Create fictional observations for a hyper relationship#
#'#
#' Return a data frame with fictional observations#
#'#
#' @param nonhyper name of the non-hyper column#
#' @param hyper name of the hyper column#
#' @param weight weight to be used in the rows#
#' @param data a data frame for inspecting levels#
#' @return Fictional observations in a data frame#
#' @examples#
#' make.hyper.noninteract("Species", "hyperSpecies", 5, iris)#
#
make.hyper.noninteract <- function(nonhyper, hyper, weight, data, sep="") {#
    ## Construct extra from diagonal factor matrix#
    extras <- diag(weight, length(unique(data[, nonhyper])))#
    extras <- as.data.frame(extras)#
#
    names(extras) <- paste(nonhyper, unique(data[, nonhyper]), sep=sep)#
#
    ## Add in the hyper column#
    extras[, hyper] <- -weight#
}
make.hyper.noninteract("Species", "hyperSpecies", 5, iris)
#' Create fictional observations for a hyper relationship#
#'#
#' Return a data frame with fictional observations#
#'#
#' @param nonhyper name of the non-hyper column#
#' @param hyper name of the hyper column#
#' @param weight weight to be used in the rows#
#' @param data a data frame for inspecting levels#
#' @return Fictional observations in a data frame#
#' @examples#
#' make.hyper.noninteract("Species", "hyperSpecies", 5, iris)#
#
make.hyper.noninteract <- function(nonhyper, hyper, weight, data, sep="") {#
    ## Construct extra from diagonal factor matrix#
    extras <- diag(weight, length(unique(data[, nonhyper])))#
    extras <- as.data.frame(extras)#
#
    names(extras) <- paste(nonhyper, unique(data[, nonhyper]), sep=sep)#
#
    ## Add in the hyper column#
    extras[, hyper] <- -weight#
#
    extras#
}
make.hyper.noninteract("Species", "hyperSpecies", 5, iris)
#' Calculate Fictional Observation Weights#
#'#
#' Determines the coeffiicients for terms in the fictional observations,#
#' to ensure a given weight relative to the normal observations.#
#'#
#' @param formula lm-style formula#
#' @param label the term to be used in fictional observations#
#' @param ratio desired ratio of observed and fictional data#
#' @param data optional data frame#
#' @return Coefficients for fictional observations#
#' @examples#
#' calc.fo.weights(Sepal.Length ~ Petal.Length + Sepal.Width : Species, "Sepal.WidthSpecies", 5, data=iris)#
#
calc.fo.weights <- function(formula, label, ratio, data) {#
    mod.lm <- lm(formula, data)#
    sumerr <- sum(mod.lm$residuals^2)#
#
    ## Collect the beta values for all of these#
    dummies <- substr(names(mod.lm$coefficients), 1, nchar(label)) == label#
    betas <- mod.lm$coefficients[dummies]#
#
    sumerr / (ratio * sum(dummies) * var(betas))#
}
calc.fo.weights(Sepal.Length ~ Petal.Length + Sepal.Width : Species, "Sepal.WidthSpecies", 5, data=iris)
lm(Sepal.Length ~ Petal.Length + Sepal.Width : Species, data=iris)
calc.fo.weights(Sepal.Length ~ Petal.Length + Sepal.Width : Species, "Sepal.Width:Species", 5, data=iris)
#' Create fictional observations for a hyper relationship#
#'#
#' Return a data frame with fictional observations#
#'#
#' @param nonhyper name of the non-hyper column#
#' @param hyper name of the hyper column#
#' @param weight weight to be used in the rows#
#' @param data a data frame for inspecting levels#
#' @return Fictional observations in a data frame#
#' @examples#
#' make.hyper.rows("Species", "hyperSpecies", 5, iris)#
#
make.hyper.rows <- function(nonhyper, hyper, weight, data, sep="") {#
    ## Construct extra from diagonal factor matrix#
    extras <- diag(weight, length(unique(data[, nonhyper])))#
    extras <- as.data.frame(extras)#
#
    names(extras) <- paste(nonhyper, unique(data[, nonhyper]), sep=sep)#
#
    ## Add in the hyper column#
    extras[, hyper] <- -weight#
#
    extras#
}
make.hyper.rows("Species", "hyperSpecies", 5, iris)
#' Fit an hierarchical model#
#'#
#' Interpret a hierarchical formula and fit it with the given data and weight ratios.#
#'#
#' @param formula an hierlm-style formula#
#' @param datas a data frame or a list of data frames, for each lm-style formula contained in the hierlm#
#' @param ratios a vector a ratios for the effect of fictional#
#'   observations, with length as large as the number of hyper#
#'   expressions.#
#' @return A fitted lm model#
#' @examples#
#' hierlm(Sepal.Length ~ Petal.Length + Species + Sepal.Width : Species | Species - ., iris, 1)#
#' hierlm(Sepal.Length ~ Petal.Length + Species + Sepal.Width : Species | Species - . | Sepal.Width : Species - ., iris, c(1, 2))#
#
hierlm <- function(formula, datas, ratios, sep="") {#
    if (is.data.frame(datas))#
        datas <- list(datas)#
#
    data.ii <- 1#
    ratio.ii <- 1#
#
    data <- datas[data.ii]#
#
    ## Split the formula by |#
    labels <- attr(terms(formula), 'term.labels')#
    if (length(labels) == 1) { # otherwise it's just an lm formula#
        chunks <- strsplit(labels, "\\|")[[1]]#
        formula <- as.formula(chunks[1], env=attr(formula1, '.Environment'))#
        for (chunk in chunks[-1]) {#
            formula <- combine.formulae(formula, chunk)#
            terms <- get.hyper.terms(chunk)#
            if (length(terms) == 3) {#
                ## Build the new relationship#
                weight <- calc.fo.weights(formula, terms[1], ratios[ratio.ii], datas[[data.ii]]) # use original data#
                extras <- make.hyper.rows(terms[1], terms[2], weight, datas[[data.ii]])#
#
                ## Done with this ratio#
                ratio.ii <- ratio.ii + 1#
#
                ## Create indicators for nonhyper, if not already done#
                if (terms[1] %in% data)#
                    data <- replace.factor(terms[1], data, 1, sep=sep)#
#
                data <- combine.data.frames(data, extras)#
            } else {#
                ## Add in the next formula#
                data.ii <- data.ii + 1#
                data <- combine.data.frame(data, datas[[data.ii]])#
            }#
        }#
    }#
#
    lm(formula, data=data)#
}
hierlm(Sepal.Length ~ Petal.Length + Species + Sepal.Width : Species | Species - ., iris, 1)
iris
formula = Sepal.Length ~ Petal.Length + Species + Sepal.Width : Species | Species - .
data = iris
ratios = 1
if (is.data.frame(datas))#
        datas <- list(datas)#
#
    data.ii <- 1#
    ratio.ii <- 1#
#
    data <- datas[data.ii]
datas = iris
if (is.data.frame(datas))#
        datas <- list(datas)#
#
    data.ii <- 1#
    ratio.ii <- 1#
#
    data <- datas[data.ii]
## Split the formula by |#
    labels <- attr(terms(formula), 'term.labels')#
    if (length(labels) == 1) { # otherwise it's just an lm formula#
        chunks <- strsplit(labels, "\\|")[[1]]#
        formula <- as.formula(chunks[1], env=attr(formula1, '.Environment'))#
        for (chunk in chunks[-1]) {#
            formula <- combine.formulae(formula, chunk)#
            terms <- get.hyper.terms(chunk)#
            if (length(terms) == 3) {#
                ## Build the new relationship#
                weight <- calc.fo.weights(formula, terms[1], ratios[ratio.ii], datas[[data.ii]]) # use original data#
                extras <- make.hyper.rows(terms[1], terms[2], weight, datas[[data.ii]])#
#
                ## Done with this ratio#
                ratio.ii <- ratio.ii + 1#
#
                ## Create indicators for nonhyper, if not already done#
                if (terms[1] %in% data)#
                    data <- replace.factor(terms[1], data, 1, sep=sep)#
#
                data <- combine.data.frames(data, extras)#
            } else {#
                ## Add in the next formula#
                data.ii <- data.ii + 1#
                data <- combine.data.frame(data, datas[[data.ii]])#
            }#
        }#
    }
#' Fit an hierarchical model#
#'#
#' Interpret a hierarchical formula and fit it with the given data and weight ratios.#
#'#
#' @param formula an hierlm-style formula#
#' @param datas a data frame or a list of data frames, for each lm-style formula contained in the hierlm#
#' @param ratios a vector a ratios for the effect of fictional#
#'   observations, with length as large as the number of hyper#
#'   expressions.#
#' @return A fitted lm model#
#' @examples#
#' hierlm(Sepal.Length ~ Petal.Length + Species + Sepal.Width : Species | Species - ., iris, 1)#
#' hierlm(Sepal.Length ~ Petal.Length + Species + Sepal.Width : Species | Species - . | Sepal.Width : Species - ., iris, c(1, 2))#
#
hierlm <- function(formula, datas, ratios, sep="") {#
    if (is.data.frame(datas))#
        datas <- list(datas)#
#
    data.ii <- 1#
    ratio.ii <- 1#
#
    data <- datas[data.ii]#
#
    ## Split the formula by |#
    labels <- attr(terms(formula), 'term.labels')#
    if (length(labels) == 1) { # otherwise it's just an lm formula#
        chunks <- strsplit(labels, "\\|")[[1]]#
        formula <- as.formula(chunks[1], env=attr(formula1, '.Environment'))#
        for (chunk in chunks[-1]) {#
            print(chunk)#
            formula <- combine.formulae(formula, chunk)#
            terms <- get.hyper.terms(chunk)#
            if (length(terms) == 3) {#
                ## Build the new relationship#
                weight <- calc.fo.weights(formula, terms[1], ratios[ratio.ii], datas[[data.ii]]) # use original data#
                extras <- make.hyper.rows(terms[1], terms[2], weight, datas[[data.ii]])#
#
                ## Done with this ratio#
                ratio.ii <- ratio.ii + 1#
#
                ## Create indicators for nonhyper, if not already done#
                if (terms[1] %in% data)#
                    data <- replace.factor(terms[1], data, 1, sep=sep)#
#
                data <- combine.data.frames(data, extras)#
            } else {#
                ## Add in the next formula#
                data.ii <- data.ii + 1#
                data <- combine.data.frame(data, datas[[data.ii]])#
            }#
        }#
    }#
#
    lm(formula, data=data)#
}
formula = Sepal.Length ~ Petal.Length + Species + Sepal.Width : Species | Species - .
hierlm(Sepal.Length ~ Petal.Length + Species + Sepal.Width : Species | Species - ., iris, 1)
#' Fit an hierarchical model#
#'#
#' Interpret a hierarchical formula and fit it with the given data and weight ratios.#
#'#
#' @param formula an hierlm-style formula#
#' @param datas a data frame or a list of data frames, for each lm-style formula contained in the hierlm#
#' @param ratios a vector a ratios for the effect of fictional#
#'   observations, with length as large as the number of hyper#
#'   expressions.#
#' @return A fitted lm model#
#' @examples#
#' hierlm(Sepal.Length ~ Petal.Length + Species + Sepal.Width : Species | Species - ., iris, 1)#
#' hierlm(Sepal.Length ~ Petal.Length + Species + Sepal.Width : Species | Species - . | Sepal.Width : Species - ., iris, c(1, 2))#
#
hierlm <- function(formula, datas, ratios, sep="") {#
    if (is.data.frame(datas))#
        datas <- list(datas)#
#
    data.ii <- 1#
    ratio.ii <- 1#
#
    data <- datas[data.ii]#
#
    ## Split the formula by |#
    labels <- attr(terms(formula), 'term.labels')#
    if (length(labels) == 1) { # otherwise it's just an lm formula#
        chunks <- strsplit(labels, "\\|")[[1]]#
        print(chunks)#
        formula <- as.formula(chunks[1], env=attr(formula1, '.Environment'))#
        for (chunk in chunks[-1]) {#
            print(chunk)#
            formula <- combine.formulae(formula, chunk)#
            terms <- get.hyper.terms(chunk)#
            if (length(terms) == 3) {#
                ## Build the new relationship#
                weight <- calc.fo.weights(formula, terms[1], ratios[ratio.ii], datas[[data.ii]]) # use original data#
                extras <- make.hyper.rows(terms[1], terms[2], weight, datas[[data.ii]])#
#
                ## Done with this ratio#
                ratio.ii <- ratio.ii + 1#
#
                ## Create indicators for nonhyper, if not already done#
                if (terms[1] %in% data)#
                    data <- replace.factor(terms[1], data, 1, sep=sep)#
#
                data <- combine.data.frames(data, extras)#
            } else {#
                ## Add in the next formula#
                data.ii <- data.ii + 1#
                data <- combine.data.frame(data, datas[[data.ii]])#
            }#
        }#
    }#
#
    lm(formula, data=data)#
}
hierlm(Sepal.Length ~ Petal.Length + Species + Sepal.Width : Species | Species - ., iris, 1)
#' Fit an hierarchical model#
#'#
#' Interpret a hierarchical formula and fit it with the given data and weight ratios.#
#'#
#' @param formula an hierlm-style formula#
#' @param datas a data frame or a list of data frames, for each lm-style formula contained in the hierlm#
#' @param ratios a vector a ratios for the effect of fictional#
#'   observations, with length as large as the number of hyper#
#'   expressions.#
#' @return A fitted lm model#
#' @examples#
#' hierlm(Sepal.Length ~ Petal.Length + Species + Sepal.Width : Species | Species - ., iris, 1)#
#' hierlm(Sepal.Length ~ Petal.Length + Species + Sepal.Width : Species | Species - . | Sepal.Width : Species - ., iris, c(1, 2))#
#
hierlm <- function(formula, datas, ratios, sep="") {#
    if (is.data.frame(datas))#
        datas <- list(datas)#
#
    data.ii <- 1#
    ratio.ii <- 1#
#
    data <- datas[data.ii]#
#
    ## Split the formula by |#
    labels <- attr(terms(formula), 'term.labels')#
    if (length(labels) == 1) { # otherwise it's just an lm formula#
        chunks <- strsplit(labels, "\\|")[[1]]#
        print(chunks)#
        formula <- as.formula(chunks[1], env=attr(formula, '.Environment'))#
        for (chunk in chunks[-1]) {#
            print(chunk)#
            formula <- combine.formulae(formula, chunk)#
            terms <- get.hyper.terms(chunk)#
            if (length(terms) == 3) {#
                ## Build the new relationship#
                weight <- calc.fo.weights(formula, terms[1], ratios[ratio.ii], datas[[data.ii]]) # use original data#
                extras <- make.hyper.rows(terms[1], terms[2], weight, datas[[data.ii]])#
#
                ## Done with this ratio#
                ratio.ii <- ratio.ii + 1#
#
                ## Create indicators for nonhyper, if not already done#
                if (terms[1] %in% data)#
                    data <- replace.factor(terms[1], data, 1, sep=sep)#
#
                data <- combine.data.frames(data, extras)#
            } else {#
                ## Add in the next formula#
                data.ii <- data.ii + 1#
                data <- combine.data.frame(data, datas[[data.ii]])#
            }#
        }#
    }#
#
    lm(formula, data=data)#
}
hierlm(Sepal.Length ~ Petal.Length + Species + Sepal.Width : Species | Species - ., iris, 1)
Sepal.Length ~ Petal.Length + Species + Sepal.Width : Species | Species - .
datas
if (is.data.frame(datas))#
        datas <- list(datas)#
#
    data.ii <- 1#
    ratio.ii <- 1#
#
    data <- datas[data.ii]#
#
    ## Split the formula by |#
    labels <- attr(terms(formula), 'term.labels')
labels
chunks <- strsplit(labels, "\\|")[[1]]
formula <- as.formula(chunks[1], env=attr(formula, '.Environment'))
as.formula(chunks[1])
formula
Sepal.Length ~ Petal.Length + Species + Sepal.Width:Species
as.formula(Sepal.Length ~ Petal.Length + Species + Sepal.Width:Species)
as.formula(Sepal.Length ~ Petal.Length + Species + Sepal.Width:Species, env=attr(formula, '.Environment'))
as.formula("Sepal.Length ~ Petal.Length + Species + Sepal.Width:Species", env=attr(formula, '.Environment'))
as.formula(chunks[1], env=attr(formula, '.Environment'))
chunks[1]
labels
terms(formula)
length(labels)
#' Fit an hierarchical model#
#'#
#' Interpret a hierarchical formula and fit it with the given data and weight ratios.#
#'#
#' @param formula an hierlm-style formula#
#' @param datas a data frame or a list of data frames, for each lm-style formula contained in the hierlm#
#' @param ratios a vector a ratios for the effect of fictional#
#'   observations, with length as large as the number of hyper#
#'   expressions.#
#' @return A fitted lm model#
#' @examples#
#' hierlm(Sepal.Length ~ Petal.Length + Species + Sepal.Width : Species | Species - ., iris, 1)#
#' hierlm(Sepal.Length ~ Petal.Length + Species + Sepal.Width : Species | Species - . | Sepal.Width : Species - ., iris, c(1, 2))#
#
hierlm <- function(formula, datas, ratios, sep="") {#
    if (is.data.frame(datas))#
        datas <- list(datas)#
#
    data.ii <- 1#
    ratio.ii <- 1#
#
    data <- datas[data.ii]#
#
    ## Split the formula by |#
    labels <- attr(terms(formula), 'term.labels')#
    if (length(labels) == 1) { # otherwise it's just an lm formula#
        lhs <- as.character(formula)[2]#
        chunks <- strsplit(labels, "\\|")[[1]]#
        formula <- as.formula(paste(lhs, "~", chunks[1]), env=attr(formula, '.Environment'))#
        for (chunk in chunks[-1]) {#
            print(chunk)#
            formula <- combine.formulae(formula, chunk)#
            terms <- get.hyper.terms(chunk)#
            if (length(terms) == 3) {#
                ## Build the new relationship#
                weight <- calc.fo.weights(formula, terms[1], ratios[ratio.ii], datas[[data.ii]]) # use original data#
                extras <- make.hyper.rows(terms[1], terms[2], weight, datas[[data.ii]])#
#
                ## Done with this ratio#
                ratio.ii <- ratio.ii + 1#
#
                ## Create indicators for nonhyper, if not already done#
                if (terms[1] %in% data)#
                    data <- replace.factor(terms[1], data, 1, sep=sep)#
#
                data <- combine.data.frames(data, extras)#
            } else {#
                ## Add in the next formula#
                data.ii <- data.ii + 1#
                data <- combine.data.frame(data, datas[[data.ii]])#
            }#
        }#
    }#
#
    lm(formula, data=data)#
}
hierlm(Sepal.Length ~ Petal.Length + Species + Sepal.Width : Species | Species - ., iris, 1)
#' Fit an hierarchical model#
#'#
#' Interpret a hierarchical formula and fit it with the given data and weight ratios.#
#'#
#' @param formula an hierlm-style formula#
#' @param datas a data frame or a list of data frames, for each lm-style formula contained in the hierlm#
#' @param ratios a vector a ratios for the effect of fictional#
#'   observations, with length as large as the number of hyper#
#'   expressions.#
#' @return A fitted lm model#
#' @examples#
#' hierlm(Sepal.Length ~ Petal.Length + Species + Sepal.Width : Species | Species - ., iris, 1)#
#' hierlm(Sepal.Length ~ Petal.Length + Species + Sepal.Width : Species | Species - . | Sepal.Width : Species - ., iris, c(1, 2))#
#
hierlm <- function(formula, datas, ratios, sep="") {#
    if (is.data.frame(datas))#
        datas <- list(datas)#
#
    data.ii <- 1#
    ratio.ii <- 1#
#
    data <- datas[data.ii]#
#
    ## Split the formula by |#
    labels <- attr(terms(formula), 'term.labels')#
    if (length(labels) == 1) { # otherwise it's just an lm formula#
        lhs <- as.character(formula)[2]#
        chunks <- strsplit(labels, "\\|")[[1]]#
        formula <- as.formula(paste(lhs, "~", chunks[1]), env=attr(formula, '.Environment'))#
        for (chunk in chunks[-1]) {#
            formula <- combine.formulae(formula, chunk)#
            terms <- get.hyper.terms(chunk)#
            if (length(terms) == 3) {#
                ## Build the new relationship#
                weight <- calc.fo.weights(formula, terms[1], ratios[ratio.ii], datas[[data.ii]]) # use original data#
                extras <- make.hyper.rows(terms[1], terms[2], weight, datas[[data.ii]])#
#
                ## Done with this ratio#
                ratio.ii <- ratio.ii + 1#
#
                ## Create indicators for nonhyper, if not already done#
                if (terms[1] %in% data)#
                    data <- replace.factor(terms[1], data, 1, sep=sep)#
#
                data <- combine.data.frames(data, extras)#
            } else {#
                ## Add in the next formula#
                data.ii <- data.ii + 1#
                data <- combine.data.frame(data, datas[[data.ii]])#
            }#
        }#
    }#
#
    print(formula)#
    lm(formula, data=data)#
}
hierlm(Sepal.Length ~ Petal.Length + Species + Sepal.Width : Species | Species - ., iris, 1)
formula
labels <- attr(terms(formula), 'term.labels')#
    if (length(labels) == 1) { # otherwise it's just an lm formula#
        lhs <- as.character(formula)[2]#
        chunks <- strsplit(labels, "\\|")[[1]]#
        formula <- as.formula(paste(lhs, "~", chunks[1]), env=attr(formula, '.Environment'))#
        for (chunk in chunks[-1]) {#
            formula <- combine.formulae(formula, chunk)#
            terms <- get.hyper.terms(chunk)#
            if (length(terms) == 3) {#
                ## Build the new relationship#
                weight <- calc.fo.weights(formula, terms[1], ratios[ratio.ii], datas[[data.ii]]) # use original data#
                extras <- make.hyper.rows(terms[1], terms[2], weight, datas[[data.ii]])#
#
                ## Done with this ratio#
                ratio.ii <- ratio.ii + 1#
#
                ## Create indicators for nonhyper, if not already done#
                if (terms[1] %in% data)#
                    data <- replace.factor(terms[1], data, 1, sep=sep)#
#
                data <- combine.data.frames(data, extras)#
            } else {#
                ## Add in the next formula#
                data.ii <- data.ii + 1#
                data <- combine.data.frame(data, datas[[data.ii]])#
            }#
        }#
    }
formula
terms
extras
weight
#' Fit an hierarchical model#
#'#
#' Interpret a hierarchical formula and fit it with the given data and weight ratios.#
#'#
#' @param formula an hierlm-style formula#
#' @param datas a data frame or a list of data frames, for each lm-style formula contained in the hierlm#
#' @param ratios a vector a ratios for the effect of fictional#
#'   observations, with length as large as the number of hyper#
#'   expressions.#
#' @return A fitted lm model#
#' @examples#
#' hierlm(Sepal.Length ~ Petal.Length + Species + Sepal.Width : Species | Species - ., iris, 1)#
#' hierlm(Sepal.Length ~ Petal.Length + Species + Sepal.Width : Species | Species - . | Sepal.Width : Species - ., iris, c(1, 2))#
#
hierlm <- function(formula, datas, ratios, sep="") {#
    if (is.data.frame(datas))#
        datas <- list(datas)#
#
    data.ii <- 1#
    ratio.ii <- 1#
#
    data <- datas[data.ii]#
#
    ## Split the formula by |#
    labels <- attr(terms(formula), 'term.labels')#
    if (length(labels) == 1) { # otherwise it's just an lm formula#
        lhs <- as.character(formula)[2]#
        chunks <- strsplit(labels, "\\|")[[1]]#
        formula <- as.formula(paste(lhs, "~", chunks[1]), env=attr(formula, '.Environment'))#
        for (chunk in chunks[-1]) {#
            # Make the new formula#
            oldformula <- formula#
            formula <- combine.formulae(formula, chunk)#
            if (!("constant" %in% names(data)) && "constant" %in% get.formula.terms(formula))#
                data$constant <- 1#
#
            terms <- get.hyper.terms(chunk)#
            if (length(terms) == 3) {#
                ## Build the new relationship#
                weight <- calc.fo.weights(oldformula, terms[1], ratios[ratio.ii], datas[[data.ii]]) # use original data#
                extras <- make.hyper.rows(terms[1], terms[2], weight, datas[[data.ii]])#
#
                ## Done with this ratio#
                ratio.ii <- ratio.ii + 1#
#
                ## Create indicators for nonhyper, if not already done#
                if (terms[1] %in% data)#
                    data <- replace.factor(terms[1], data, 1, sep=sep)#
#
                data <- combine.data.frames(data, extras)#
#
            } else {#
                ## Add in the next formula#
                data.ii <- data.ii + 1#
                data <- combine.data.frame(data, datas[[data.ii]])#
            }#
        }#
    }#
#
    print(formula)#
    lm(formula, data=data)#
}
hierlm(Sepal.Length ~ Petal.Length + Species + Sepal.Width : Species | Species - ., iris, 1)
#' Fit an hierarchical model#
#'#
#' Interpret a hierarchical formula and fit it with the given data and weight ratios.#
#'#
#' @param formula an hierlm-style formula#
#' @param datas a data frame or a list of data frames, for each lm-style formula contained in the hierlm#
#' @param ratios a vector a ratios for the effect of fictional#
#'   observations, with length as large as the number of hyper#
#'   expressions.#
#' @return A fitted lm model#
#' @examples#
#' hierlm(Sepal.Length ~ Petal.Length + Species + Sepal.Width : Species | Species - ., iris, 1)#
#' hierlm(Sepal.Length ~ Petal.Length + Species + Sepal.Width : Species | Species - . | Sepal.Width : Species - ., iris, c(1, 2))#
#
hierlm <- function(formula, datas, ratios, sep="") {#
    if (is.data.frame(datas))#
        datas <- list(datas)#
#
    data.ii <- 1#
    ratio.ii <- 1#
#
    data <- datas[data.ii]#
#
    ## Split the formula by |#
    labels <- attr(terms(formula), 'term.labels')#
    if (length(labels) == 1) { # otherwise it's just an lm formula#
        lhs <- as.character(formula)[2]#
        chunks <- strsplit(labels, "\\|")[[1]]#
        formula <- as.formula(paste(lhs, "~", chunks[1]), env=attr(formula, '.Environment'))#
        for (chunk in chunks[-1]) {#
            # Make the new formula#
            oldformula <- formula#
            formula <- combine.formulae(formula, chunk)#
            if (!("constant" %in% names(data)) && "constant" %in% get.formula.terms(formula))#
                data$constant <- 1#
#
            terms <- get.hyper.terms(chunk)#
            if (length(terms) == 3) {#
                ## Build the new relationship#
                weight <- calc.fo.weights(oldformula, terms[1], ratios[ratio.ii], datas[[data.ii]]) # use original data#
                extras <- make.hyper.rows(terms[1], terms[2], weight, datas[[data.ii]])#
#
                ## Done with this ratio#
                ratio.ii <- ratio.ii + 1#
#
                ## Create indicators for nonhyper, if not already done#
                if (terms[1] %in% data)#
                    data <- replace.factor(terms[1], data, 1, sep=sep)#
#
                print(data)#
                data <- combine.data.frames(data, extras)#
#
            } else {#
                ## Add in the next formula#
                data.ii <- data.ii + 1#
                data <- combine.data.frame(data, datas[[data.ii]])#
            }#
        }#
    }#
#
    print(formula)#
    lm(formula, data=data)#
}
hierlm(Sepal.Length ~ Petal.Length + Species + Sepal.Width : Species | Species - ., iris, 1)
#' Fit an hierarchical model#
#'#
#' Interpret a hierarchical formula and fit it with the given data and weight ratios.#
#'#
#' @param formula an hierlm-style formula#
#' @param datas a data frame or a list of data frames, for each lm-style formula contained in the hierlm#
#' @param ratios a vector a ratios for the effect of fictional#
#'   observations, with length as large as the number of hyper#
#'   expressions.#
#' @return A fitted lm model#
#' @examples#
#' hierlm(Sepal.Length ~ Petal.Length + Species + Sepal.Width : Species | Species - ., iris, 1)#
#' hierlm(Sepal.Length ~ Petal.Length + Species + Sepal.Width : Species | Species - . | Sepal.Width : Species - ., iris, c(1, 2))#
#
hierlm <- function(formula, datas, ratios, sep="") {#
    if (is.data.frame(datas))#
        datas <- list(datas)#
#
    data.ii <- 1#
    ratio.ii <- 1#
#
    data <- datas[[data.ii]]#
#
    ## Split the formula by |#
    labels <- attr(terms(formula), 'term.labels')#
    if (length(labels) == 1) { # otherwise it's just an lm formula#
        lhs <- as.character(formula)[2]#
        chunks <- strsplit(labels, "\\|")[[1]]#
        formula <- as.formula(paste(lhs, "~", chunks[1]), env=attr(formula, '.Environment'))#
        for (chunk in chunks[-1]) {#
            # Make the new formula#
            oldformula <- formula#
            formula <- combine.formulae(formula, chunk)#
            if (!("constant" %in% names(data)) && "constant" %in% get.formula.terms(formula))#
                data$constant <- 1#
#
            terms <- get.hyper.terms(chunk)#
            if (length(terms) == 3) {#
                ## Build the new relationship#
                weight <- calc.fo.weights(oldformula, terms[1], ratios[ratio.ii], datas[[data.ii]]) # use original data#
                extras <- make.hyper.rows(terms[1], terms[2], weight, datas[[data.ii]])#
#
                ## Done with this ratio#
                ratio.ii <- ratio.ii + 1#
#
                ## Create indicators for nonhyper, if not already done#
                if (terms[1] %in% data)#
                    data <- replace.factor(terms[1], data, 1, sep=sep)#
#
                data <- combine.data.frames(data, extras)#
            } else {#
                ## Add in the next formula#
                data.ii <- data.ii + 1#
                data <- combine.data.frame(data, datas[[data.ii]])#
            }#
        }#
    }#
#
    print(formula)#
    lm(formula, data=data)#
}
hierlm(Sepal.Length ~ Petal.Length + Species + Sepal.Width : Species | Species - ., iris, 1)
#' Fit an hierarchical model#
#'#
#' Interpret a hierarchical formula and fit it with the given data and weight ratios.#
#'#
#' @param formula an hierlm-style formula#
#' @param datas a data frame or a list of data frames, for each lm-style formula contained in the hierlm#
#' @param ratios a vector a ratios for the effect of fictional#
#'   observations, with length as large as the number of hyper#
#'   expressions.#
#' @return A fitted lm model#
#' @examples#
#' hierlm(Sepal.Length ~ Petal.Length + Species + Sepal.Width : Species | Species - ., iris, 1)#
#' hierlm(Sepal.Length ~ Petal.Length + Species + Sepal.Width : Species | Species - . | Sepal.Width : Species - ., iris, c(1, 2))#
#
hierlm <- function(formula, datas, ratios, sep="") {#
    if (is.data.frame(datas))#
        datas <- list(datas)#
#
    data.ii <- 1#
    ratio.ii <- 1#
#
    data <- datas[[data.ii]]#
#
    ## Split the formula by |#
    labels <- attr(terms(formula), 'term.labels')#
    if (length(labels) == 1) { # otherwise it's just an lm formula#
        lhs <- as.character(formula)[2]#
        chunks <- strsplit(labels, "\\|")[[1]]#
        formula <- as.formula(paste(lhs, "~", chunks[1]), env=attr(formula, '.Environment'))#
        for (chunk in chunks[-1]) {#
            # Make the new formula#
            oldformula <- formula#
            formula <- combine.formulae(formula, chunk)#
            if (!("constant" %in% names(data)) && "constant" %in% get.formula.terms(formula))#
                data$constant <- 1#
#
            terms <- get.hyper.terms(chunk)#
            if (length(terms) == 3) {#
                ## Build the new relationship#
                weight <- calc.fo.weights(oldformula, terms[1], ratios[ratio.ii], datas[[data.ii]]) # use original data#
                extras <- make.hyper.rows(terms[1], terms[2], weight, datas[[data.ii]])#
#
                ## Done with this ratio#
                ratio.ii <- ratio.ii + 1#
#
                ## Create indicators for nonhyper, if not already done#
                if (terms[1] %in% data)#
                    data <- replace.factor(terms[1], data, 1, sep=sep)#
#
                data <- combine.data.frames(data, extras)#
            } else {#
                ## Add in the next formula#
                data.ii <- data.ii + 1#
                data <- combine.data.frame(data, datas[[data.ii]])#
            }#
        }#
    }#
#
    print(head(data))#
    print(formula)#
    lm(formula, data=data)#
}
hierlm(Sepal.Length ~ Petal.Length + Species + Sepal.Width : Species | Species - ., iris, 1)
#' Fit an hierarchical model#
#'#
#' Interpret a hierarchical formula and fit it with the given data and weight ratios.#
#'#
#' @param formula an hierlm-style formula#
#' @param datas a data frame or a list of data frames, for each lm-style formula contained in the hierlm#
#' @param ratios a vector a ratios for the effect of fictional#
#'   observations, with length as large as the number of hyper#
#'   expressions.#
#' @return A fitted lm model#
#' @examples#
#' hierlm(Sepal.Length ~ Petal.Length + Species + Sepal.Width : Species | Species - ., iris, 1)#
#' hierlm(Sepal.Length ~ Petal.Length + Species + Sepal.Width : Species | Species - . | Sepal.Width : Species - ., iris, c(1, 2))#
#
hierlm <- function(formula, datas, ratios, sep="") {#
    if (is.data.frame(datas))#
        datas <- list(datas)#
#
    data.ii <- 1#
    ratio.ii <- 1#
#
    data <- datas[[data.ii]]#
#
    ## Split the formula by |#
    labels <- attr(terms(formula), 'term.labels')#
    if (length(labels) == 1) { # otherwise it's just an lm formula#
        lhs <- as.character(formula)[2]#
        chunks <- strsplit(labels, "\\|")[[1]]#
        formula <- as.formula(paste(lhs, "~", chunks[1]), env=attr(formula, '.Environment'))#
        for (chunk in chunks[-1]) {#
            # Make the new formula#
            oldformula <- formula#
            formula <- combine.formulae(formula, chunk)#
            if (!("constant" %in% names(data)) && "constant" %in% get.formula.terms(formula))#
                data$constant <- 1#
#
            terms <- get.hyper.terms(chunk)#
            if (length(terms) == 3) {#
                ## Build the new relationship#
                weight <- calc.fo.weights(oldformula, terms[1], ratios[ratio.ii], datas[[data.ii]]) # use original data#
                extras <- make.hyper.rows(terms[1], terms[2], weight, datas[[data.ii]])#
#
                ## Done with this ratio#
                ratio.ii <- ratio.ii + 1#
#
                ## Create indicators for nonhyper, if not already done#
                if (terms[1] %in% data)#
                    data <- replace.factor(terms[1], data, 1, sep=sep)#
#
                print(extras)#
                data <- combine.data.frames(data, extras)#
            } else {#
                ## Add in the next formula#
                data.ii <- data.ii + 1#
                data <- combine.data.frame(data, datas[[data.ii]])#
            }#
        }#
    }#
#
    print(head(data))#
    print(formula)#
    lm(formula, data=data)#
}
hierlm(Sepal.Length ~ Petal.Length + Species + Sepal.Width : Species | Species - ., iris, 1)
#' Fit an hierarchical model#
#'#
#' Interpret a hierarchical formula and fit it with the given data and weight ratios.#
#'#
#' @param formula an hierlm-style formula#
#' @param datas a data frame or a list of data frames, for each lm-style formula contained in the hierlm#
#' @param ratios a vector a ratios for the effect of fictional#
#'   observations, with length as large as the number of hyper#
#'   expressions.#
#' @return A fitted lm model#
#' @examples#
#' hierlm(Sepal.Length ~ Petal.Length + Species + Sepal.Width : Species | Species - ., iris, 1)#
#' hierlm(Sepal.Length ~ Petal.Length + Species + Sepal.Width : Species | Species - . | Sepal.Width : Species - ., iris, c(1, 2))#
#
hierlm <- function(formula, datas, ratios, sep="") {#
    if (is.data.frame(datas))#
        datas <- list(datas)#
#
    data.ii <- 1#
    ratio.ii <- 1#
#
    data <- datas[[data.ii]]#
#
    ## Split the formula by |#
    labels <- attr(terms(formula), 'term.labels')#
    if (length(labels) == 1) { # otherwise it's just an lm formula#
        lhs <- as.character(formula)[2]#
        chunks <- strsplit(labels, "\\|")[[1]]#
        formula <- as.formula(paste(lhs, "~", chunks[1]), env=attr(formula, '.Environment'))#
        for (chunk in chunks[-1]) {#
            # Make the new formula#
            oldformula <- formula#
            formula <- combine.formulae(formula, chunk)#
            if (!("constant" %in% names(data)) && "constant" %in% get.formula.terms(formula))#
                data$constant <- 1#
#
            terms <- get.hyper.terms(chunk)#
            if (length(terms) == 3) {#
                ## Build the new relationship#
                weight <- calc.fo.weights(oldformula, terms[1], ratios[ratio.ii], datas[[data.ii]]) # use original data#
                extras <- make.hyper.rows(terms[1], terms[2], weight, datas[[data.ii]])#
#
                ## Done with this ratio#
                ratio.ii <- ratio.ii + 1#
#
                ## Create indicators for nonhyper, if not already done#
                if (terms[1] %in% data)#
                    data <- replace.factor(terms[1], data, 1, sep=sep)#
#
                data <- combine.data.frames(data, extras)#
            } else {#
                ## Add in the next formula#
                data.ii <- data.ii + 1#
                data <- combine.data.frame(data, datas[[data.ii]])#
            }#
        }#
    }#
#
    print(head(data))#
    print(tail(data))#
    print(formula)#
    lm(formula, data=data)#
}
hierlm(Sepal.Length ~ Petal.Length + Species + Sepal.Width : Species | Species - ., iris, 1)
formula = Sepal.Length ~ Petal.Length : Species
get.formula.terms(formula)
#' Fit an hierarchical model#
#'#
#' Interpret a hierarchical formula and fit it with the given data and weight ratios.#
#'#
#' @param formula an hierlm-style formula#
#' @param datas a data frame or a list of data frames, for each lm-style formula contained in the hierlm#
#' @param ratios a vector a ratios for the effect of fictional#
#'   observations, with length as large as the number of hyper#
#'   expressions.#
#' @return A fitted lm model#
#' @examples#
#' hierlm(Sepal.Length ~ Petal.Length + Species + Sepal.Width : Species | Species - ., iris, 1)#
#' hierlm(Sepal.Length ~ Petal.Length + Species + Sepal.Width : Species | Species - . | Sepal.Width : Species - ., iris, c(1, 2))#
#
hierlm <- function(formula, datas, ratios, sep="") {#
    if (is.data.frame(datas))#
        datas <- list(datas)#
#
    data.ii <- 1#
    ratio.ii <- 1#
#
    data <- datas[[data.ii]]#
#
    ## Split the formula by |#
    labels <- attr(terms(formula), 'term.labels')#
    if (length(labels) == 1) { # otherwise it's just an lm formula#
        lhs <- as.character(formula)[2]#
        chunks <- strsplit(labels, "\\|")[[1]]#
        formula <- as.formula(paste(lhs, "~", chunks[1]), env=attr(formula, '.Environment'))#
        for (chunk in chunks[-1]) {#
            ## Keep these around#
            oldformula <- formula#
            olddata <- data#
#
            ## Make the new formula#
            formula <- combine.formulae(formula, chunk)#
            if (!("constant" %in% names(data)) && "constant" %in% get.formula.terms(formula))#
                data$constant <- 1#
#
            terms <- get.hyper.terms(chunk)#
            if (length(terms) == 3) {#
                ## Build the new relationship#
                weight <- calc.fo.weights(oldformula, terms[1], ratios[ratio.ii], datas[[data.ii]]) # use original data#
                extras <- make.hyper.rows(terms[1], terms[2], weight, datas[[data.ii]])#
#
                ## Done with this ratio#
                ratio.ii <- ratio.ii + 1#
#
                ## Create indicators for nonhyper, if not already done#
                if (terms[1] %in% data)#
                    data <- replace.factor(terms[1], data, 1, sep=sep)#
#
                data <- combine.data.frames(data, extras)#
            } else {#
                ## Add in the next formula#
                data.ii <- data.ii + 1#
                data <- combine.data.frame(data, datas[[data.ii]])#
            }#
#
            ## Have any of the terms in the formula been factorized?#
            checks <- get.formula.terms(formula)#
            for (check in checks) {#
                if (is.factor(olddata[, check]))#
                    formula <- replace.factor.formula(check, formula, data)#
            }#
        }#
    }#
#
    print(head(data))#
    print(tail(data))#
    print(formula)#
    lm(formula, data=data)#
}
hierlm(Sepal.Length ~ Petal.Length + Species + Sepal.Width : Species | Species - ., iris, 1)
#' Fit an hierarchical model#
#'#
#' Interpret a hierarchical formula and fit it with the given data and weight ratios.#
#'#
#' @param formula an hierlm-style formula#
#' @param datas a data frame or a list of data frames, for each lm-style formula contained in the hierlm#
#' @param ratios a vector a ratios for the effect of fictional#
#'   observations, with length as large as the number of hyper#
#'   expressions.#
#' @return A fitted lm model#
#' @examples#
#' hierlm(Sepal.Length ~ Petal.Length + Species + Sepal.Width : Species | Species - ., iris, 1)#
#' hierlm(Sepal.Length ~ Petal.Length + Species + Sepal.Width : Species | Species - . | Sepal.Width : Species - ., iris, c(1, 2))#
#
hierlm <- function(formula, datas, ratios, sep="") {#
    if (is.data.frame(datas))#
        datas <- list(datas)#
#
    data.ii <- 1#
    ratio.ii <- 1#
#
    data <- datas[[data.ii]]#
#
    ## Split the formula by |#
    labels <- attr(terms(formula), 'term.labels')#
    if (length(labels) == 1) { # otherwise it's just an lm formula#
        lhs <- as.character(formula)[2]#
        chunks <- strsplit(labels, "\\|")[[1]]#
        formula <- as.formula(paste(lhs, "~", chunks[1]), env=attr(formula, '.Environment'))#
        for (chunk in chunks[-1]) {#
            ## Keep these around#
            oldformula <- formula#
            olddata <- data#
#
            ## Make the new formula#
            formula <- combine.formulae(formula, chunk)#
            if (!("constant" %in% names(data)) && "constant" %in% get.formula.terms(formula))#
                data$constant <- 1#
#
            terms <- get.hyper.terms(chunk)#
            if (length(terms) == 3) {#
                ## Build the new relationship#
                weight <- calc.fo.weights(oldformula, terms[1], ratios[ratio.ii], datas[[data.ii]]) # use original data#
                extras <- make.hyper.rows(terms[1], terms[2], weight, datas[[data.ii]])#
#
                ## Done with this ratio#
                ratio.ii <- ratio.ii + 1#
#
                ## Create indicators for nonhyper, if not already done#
                if (terms[1] %in% data)#
                    data <- replace.factor(terms[1], data, 1, sep=sep)#
#
                data <- combine.data.frames(data, extras)#
            } else {#
                ## Add in the next formula#
                data.ii <- data.ii + 1#
                data <- combine.data.frame(data, datas[[data.ii]])#
            }#
#
            ## Have any of the terms in the formula been factorized?#
            checks <- get.formula.terms(formula)#
            for (check in checks) {#
                print(check)#
                if (is.factor(olddata[, check]))#
                    formula <- replace.factor.formula(check, formula, data)#
            }#
        }#
    }#
#
    print(head(data))#
    print(tail(data))#
    print(formula)#
    lm(formula, data=data)#
}
hierlm(Sepal.Length ~ Petal.Length + Species + Sepal.Width : Species | Species - ., iris, 1)
#' Fit an hierarchical model#
#'#
#' Interpret a hierarchical formula and fit it with the given data and weight ratios.#
#'#
#' @param formula an hierlm-style formula#
#' @param datas a data frame or a list of data frames, for each lm-style formula contained in the hierlm#
#' @param ratios a vector a ratios for the effect of fictional#
#'   observations, with length as large as the number of hyper#
#'   expressions.#
#' @return A fitted lm model#
#' @examples#
#' hierlm(Sepal.Length ~ Petal.Length + Species + Sepal.Width : Species | Species - ., iris, 1)#
#' hierlm(Sepal.Length ~ Petal.Length + Species + Sepal.Width : Species | Species - . | Sepal.Width : Species - ., iris, c(1, 2))#
#
hierlm <- function(formula, datas, ratios, sep="") {#
    if (is.data.frame(datas))#
        datas <- list(datas)#
#
    data.ii <- 1#
    ratio.ii <- 1#
#
    data <- datas[[data.ii]]#
#
    ## Split the formula by |#
    labels <- attr(terms(formula), 'term.labels')#
    if (length(labels) == 1) { # otherwise it's just an lm formula#
        lhs <- as.character(formula)[2]#
        chunks <- strsplit(labels, "\\|")[[1]]#
        formula <- as.formula(paste(lhs, "~", chunks[1]), env=attr(formula, '.Environment'))#
        for (chunk in chunks[-1]) {#
            ## Keep these around#
            oldformula <- formula#
            olddata <- data#
#
            ## Make the new formula#
            formula <- combine.formulae(formula, chunk)#
            if (!("constant" %in% names(data)) && "constant" %in% get.formula.terms(formula))#
                data$constant <- 1#
#
            terms <- get.hyper.terms(chunk)#
            if (length(terms) == 3) {#
                ## Build the new relationship#
                weight <- calc.fo.weights(oldformula, terms[1], ratios[ratio.ii], datas[[data.ii]]) # use original data#
                extras <- make.hyper.rows(terms[1], terms[2], weight, datas[[data.ii]])#
#
                ## Done with this ratio#
                ratio.ii <- ratio.ii + 1#
#
                ## Create indicators for nonhyper, if not already done#
                if (terms[1] %in% data)#
                    data <- replace.factor(terms[1], data, 1, sep=sep)#
#
                data <- combine.data.frames(data, extras)#
            } else {#
                ## Add in the next formula#
                data.ii <- data.ii + 1#
                data <- combine.data.frame(data, datas[[data.ii]])#
            }#
#
            ## Have any of the terms in the formula been factorized?#
            checks <- get.formula.terms(formula)#
            for (check in checks) {#
                if (check %in% names(olddata) && is.factor(olddata[, check]))#
                    formula <- replace.factor.formula(check, formula, data)#
            }#
        }#
    }#
#
    print(head(data))#
    print(tail(data))#
    print(formula)#
    lm(formula, data=data)#
}
hierlm(Sepal.Length ~ Petal.Length + Species + Sepal.Width : Species | Species - ., iris, 1)
#' Replace a factor term#
#'#
#' Constructs indicator terms for a factor variable.#
#'#
#' @param name term name#
#' @param formula formula#
#' @param sep paste sep used to construct factor names#
#' @return Modified formula#
#' @examples#
#' replace.factor.formula("Species", Sepal.Length ~ Species)#
#' replace.factor.formula("Species", Sepal.Length ~ Petal.Length : Species)#
#
replace.factor.formula <- function(name, formula, data, sep="") {#
    terms <- c()#
#
    for (term in get.formula.terms(formula)) {#
        if (term == name) {#
            terms <- c(terms, make.factor.names(name, data))#
        } else if (grepl(':', term)) {#
            subterms <- split.interaction.term(term)#
            if (subterms[1] == name) {#
                terms <- c(terms, paste(make.factor.names(subterms[1], data), subterms[2], sep=':'))#
            } else if (subterms[2] == name) {#
                terms <- c(terms, paste(subterms[1], make.factor.names(subterms[2], data), sep=':'))#
            } else {#
                terms <- c(terms, term)#
            }#
        } else {#
            terms <- c(terms, term)#
        }#
    }#
#
    chunks <- as.character(formula)#
    paste(chunks[2], paste(terms, collapse=" + "), sep=" ~ ")#
}
hierlm(Sepal.Length ~ Petal.Length + Species + Sepal.Width : Species | Species - ., iris, 1)
#' Make a factor name#
#'#
#' Construct a factor name for each level#
#'#
#' @param name the factor to be decomposed#
#' @param data data frame with that as a column#
#' @return Vector of the factor names#
#' @examples#
#' make.factor.names("Species", iris)#
#
make.factor.names <- function(name, data, sep="") {#
    paste(name, unique(data[, name]), sep=sep)#
}
hierlm(Sepal.Length ~ Petal.Length + Species + Sepal.Width : Species | Species - ., iris, 1)
#' Make a factor name#
#'#
#' Construct a factor name for each level#
#'#
#' @param name the factor to be decomposed#
#' @param data data frame with that as a column#
#' @return Vector of the factor names#
#' @examples#
#' make.factor.names("Species", iris)#
#
make.factor.names <- function(name, data, sep="") {#
    print(1)#
    x = paste(name, unique(data[, name]), sep=sep)#
    print(2)#
    x#
}
hierlm(Sepal.Length ~ Petal.Length + Species + Sepal.Width : Species | Species - ., iris, 1)
#' Make a factor name#
#'#
#' Construct a factor name for each level#
#'#
#' @param name the factor to be decomposed#
#' @param data data frame with that as a column#
#' @return Vector of the factor names#
#' @examples#
#' make.factor.names("Species", iris)#
#
make.factor.names <- function(name, data, sep="") {#
    print(names(data))#
    x = paste(name, unique(data[, name]), sep=sep)#
    print(2)#
    x#
}
hierlm(Sepal.Length ~ Petal.Length + Species + Sepal.Width : Species | Species - ., iris, 1)
#' Make a factor name#
#'#
#' Construct a factor name for each level#
#'#
#' @param name the factor to be decomposed#
#' @param data data frame with that as a column#
#' @return Vector of the factor names#
#' @examples#
#' make.factor.names("Species", iris)#
#
make.factor.names <- function(name, data, sep="") {#
    print(name)#
    print(names(data))#
    x = paste(name, unique(data[, name]), sep=sep)#
    print(2)#
    x#
}
hierlm(Sepal.Length ~ Petal.Length + Species + Sepal.Width : Species | Species - ., iris, 1)
#' Replace a factor term#
#'#
#' Constructs indicator terms for a factor variable.#
#'#
#' @param name term name#
#' @param formula formula#
#' @param sep paste sep used to construct factor names#
#' @return Modified formula#
#' @examples#
#' replace.factor.formula("Species", Sepal.Length ~ Species)#
#' replace.factor.formula("Species", Sepal.Length ~ Petal.Length : Species)#
#
replace.factor.formula <- function(name, formula, data, sep="") {#
    print(1)#
    terms <- c()#
#
    for (term in get.formula.terms(formula)) {#
        if (term == name) {#
            terms <- c(terms, make.factor.names(name, data))#
        } else if (grepl(':', term)) {#
            subterms <- split.interaction.term(term)#
            if (subterms[1] == name) {#
                terms <- c(terms, paste(make.factor.names(subterms[1], data), subterms[2], sep=':'))#
            } else if (subterms[2] == name) {#
                terms <- c(terms, paste(subterms[1], make.factor.names(subterms[2], data), sep=':'))#
            } else {#
                terms <- c(terms, term)#
            }#
        } else {#
            terms <- c(terms, term)#
        }#
    }#
#
    chunks <- as.character(formula)#
    print(2)#
    paste(chunks[2], paste(terms, collapse=" + "), sep=" ~ ")#
}
hierlm(Sepal.Length ~ Petal.Length + Species + Sepal.Width : Species | Species - ., iris, 1)
#' Replace a factor term#
#'#
#' Constructs indicator terms for a factor variable.#
#'#
#' @param name term name#
#' @param formula formula#
#' @param sep paste sep used to construct factor names#
#' @return Modified formula#
#' @examples#
#' replace.factor.formula("Species", Sepal.Length ~ Species)#
#' replace.factor.formula("Species", Sepal.Length ~ Petal.Length : Species)#
#
replace.factor.formula <- function(name, formula, data, sep="") {#
    print(1)#
    print(names(data))#
    terms <- c()#
#
    for (term in get.formula.terms(formula)) {#
        if (term == name) {#
            terms <- c(terms, make.factor.names(name, data))#
        } else if (grepl(':', term)) {#
            subterms <- split.interaction.term(term)#
            if (subterms[1] == name) {#
                terms <- c(terms, paste(make.factor.names(subterms[1], data), subterms[2], sep=':'))#
            } else if (subterms[2] == name) {#
                terms <- c(terms, paste(subterms[1], make.factor.names(subterms[2], data), sep=':'))#
            } else {#
                terms <- c(terms, term)#
            }#
        } else {#
            terms <- c(terms, term)#
        }#
    }#
#
    chunks <- as.character(formula)#
    print(2)#
    paste(chunks[2], paste(terms, collapse=" + "), sep=" ~ ")#
}
hierlm(Sepal.Length ~ Petal.Length + Species + Sepal.Width : Species | Species - ., iris, 1)
#' Make a factor name#
#'#
#' Construct a factor name for each level#
#'#
#' @param name the factor to be decomposed#
#' @param data data frame with that as a column#
#' @return Vector of the factor names#
#' @examples#
#' make.factor.names("Species", iris)#
#
make.factor.names <- function(name, data, sep="") {#
    paste(name, unique(data[, name]), sep=sep)#
}
#' Fit an hierarchical model#
#'#
#' Interpret a hierarchical formula and fit it with the given data and weight ratios.#
#'#
#' @param formula an hierlm-style formula#
#' @param datas a data frame or a list of data frames, for each lm-style formula contained in the hierlm#
#' @param ratios a vector a ratios for the effect of fictional#
#'   observations, with length as large as the number of hyper#
#'   expressions.#
#' @return A fitted lm model#
#' @examples#
#' hierlm(Sepal.Length ~ Petal.Length + Species + Sepal.Width : Species | Species - ., iris, 1)#
#' hierlm(Sepal.Length ~ Petal.Length + Species + Sepal.Width : Species | Species - . | Sepal.Width : Species - ., iris, c(1, 2))#
#
hierlm <- function(formula, datas, ratios, sep="") {#
    if (is.data.frame(datas))#
        datas <- list(datas)#
#
    data.ii <- 1#
    ratio.ii <- 1#
#
    data <- datas[[data.ii]]#
#
    ## Split the formula by |#
    labels <- attr(terms(formula), 'term.labels')#
    if (length(labels) == 1) { # otherwise it's just an lm formula#
        lhs <- as.character(formula)[2]#
        chunks <- strsplit(labels, "\\|")[[1]]#
        formula <- as.formula(paste(lhs, "~", chunks[1]), env=attr(formula, '.Environment'))#
        for (chunk in chunks[-1]) {#
            ## Keep these around#
            oldformula <- formula#
            olddata <- data#
#
            ## Make the new formula#
            formula <- combine.formulae(formula, chunk)#
            if (!("constant" %in% names(data)) && "constant" %in% get.formula.terms(formula))#
                data$constant <- 1#
#
            terms <- get.hyper.terms(chunk)#
            if (length(terms) == 3) {#
                ## Build the new relationship#
                weight <- calc.fo.weights(oldformula, terms[1], ratios[ratio.ii], datas[[data.ii]]) # use original data#
                extras <- make.hyper.rows(terms[1], terms[2], weight, datas[[data.ii]])#
#
                ## Done with this ratio#
                ratio.ii <- ratio.ii + 1#
#
                ## Create indicators for nonhyper, if not already done#
                if (terms[1] %in% data)#
                    data <- replace.factor(terms[1], data, 1, sep=sep)#
#
                data <- combine.data.frames(data, extras)#
            } else {#
                ## Add in the next formula#
                data.ii <- data.ii + 1#
                data <- combine.data.frame(data, datas[[data.ii]])#
            }#
#
            ## Have any of the terms in the formula been factorized?#
            checks <- get.formula.terms(formula)#
            for (check in checks) {#
                if (check %in% names(olddata) && is.factor(olddata[, check]))#
                    formula <- replace.factor.formula(check, formula, olddata)#
            }#
        }#
    }#
#
    print(head(data))#
    print(tail(data))#
    print(formula)#
    lm(formula, data=data)#
}
hierlm(Sepal.Length ~ Petal.Length + Species + Sepal.Width : Species | Species - ., iris, 1)
#' Replace a factor term#
#'#
#' Constructs indicator terms for a factor variable.#
#'#
#' @param name term name#
#' @param formula formula#
#' @param sep paste sep used to construct factor names#
#' @return Modified formula#
#' @examples#
#' replace.factor.formula("Species", Sepal.Length ~ Species)#
#' replace.factor.formula("Species", Sepal.Length ~ Petal.Length : Species)#
#
replace.factor.formula <- function(name, formula, data, sep="") {#
    terms <- c()#
#
    for (term in get.formula.terms(formula)) {#
        if (term == name) {#
            terms <- c(terms, make.factor.names(name, data))#
        } else if (grepl(':', term)) {#
            subterms <- split.interaction.term(term)#
            if (subterms[1] == name) {#
                terms <- c(terms, paste(make.factor.names(subterms[1], data), subterms[2], sep=':'))#
            } else if (subterms[2] == name) {#
                terms <- c(terms, paste(subterms[1], make.factor.names(subterms[2], data), sep=':'))#
            } else {#
                terms <- c(terms, term)#
            }#
        } else {#
            terms <- c(terms, term)#
        }#
    }#
#
    chunks <- as.character(formula)#
    paste(chunks[2], paste(terms, collapse=" + "), sep=" ~ ")#
}
hierlm(Sepal.Length ~ Petal.Length + Species + Sepal.Width : Species | Species - ., iris, 1)
#' Split an Interaction Term#
#'#
#' Extract the two pieces of an interaction term#
#'#
#' @param term An interaction (a:b) term#
#' @return Vector of the subterms (c(a, b))#
#' @examples#
#' split.interaction.term("Petal.Length : Species")#
#
split.interaction.term <- function(term) {#
    subterms <- strsplit(term, ":")[[1]]#
    gsub("^\\s+|\\s+$", "", subterms)#
}
hierlm(Sepal.Length ~ Petal.Length + Species + Sepal.Width : Species | Species - ., iris, 1)
summary(hierlm(Sepal.Length ~ Petal.Length + Species + Sepal.Width : Species | Species - ., iris, 1))
summary(hierlm(Sepal.Length ~ 0 + Petal.Length + Species + Sepal.Width : Species | Species - ., iris, 1))
hierlm(Sepal.Length ~ 0 + Petal.Length + Species + Sepal.Width : Species | Species - . | Sepal.Width : Species - ., iris, c(1, 2))
formula = Sepal.Length ~ 0 + Petal.Length + Species + Sepal.Width : Species | Species - . | Sepal.Width : Species - .
datas = iris
ratios = c(1, 2)
if (is.data.frame(datas))#
        datas <- list(datas)#
#
    data.ii <- 1#
    ratio.ii <- 1#
#
    data <- datas[[data.ii]]#
#
    ## Split the formula by |#
    labels <- attr(terms(formula), 'term.labels')#
    if (length(labels) == 1) { # otherwise it's just an lm formula#
        lhs <- as.character(formula)[2]#
        chunks <- strsplit(labels, "\\|")[[1]]#
        formula <- as.formula(paste(lhs, "~", chunks[1]), env=attr(formula, '.Environment'))#
        for (chunk in chunks[-1]) {#
            ## Keep these around#
            oldformula <- formula#
            olddata <- data#
#
            ## Make the new formula#
            formula <- combine.formulae(formula, chunk)#
            if (!("constant" %in% names(data)) && "constant" %in% get.formula.terms(formula))#
                data$constant <- 1#
#
            terms <- get.hyper.terms(chunk)#
            if (length(terms) == 3) {#
                ## Build the new relationship#
                weight <- calc.fo.weights(oldformula, terms[1], ratios[ratio.ii], datas[[data.ii]]) # use original data#
                extras <- make.hyper.rows(terms[1], terms[2], weight, datas[[data.ii]])#
#
                ## Done with this ratio#
                ratio.ii <- ratio.ii + 1#
#
                ## Create indicators for nonhyper, if not already done#
                if (terms[1] %in% data)#
                    data <- replace.factor(terms[1], data, 1, sep=sep)#
#
                data <- combine.data.frames(data, extras)#
            } else {#
                ## Add in the next formula#
                data.ii <- data.ii + 1#
                data <- combine.data.frame(data, datas[[data.ii]])#
            }#
#
            ## Have any of the terms in the formula been factorized?#
            checks <- get.formula.terms(formula)#
            for (check in checks) {#
                if (check %in% names(olddata) && is.factor(olddata[, check]))#
                    formula <- replace.factor.formula(check, formula, olddata)#
            }#
        }#
    }#
#
    print(head(data))#
    print(tail(data))#
    print(formula)#
    lm(formula, data=data)
#' Fit an hierarchical model#
#'#
#' Interpret a hierarchical formula and fit it with the given data and weight ratios.#
#'#
#' @param formula an hierlm-style formula#
#' @param datas a data frame or a list of data frames, for each lm-style formula contained in the hierlm#
#' @param ratios a vector a ratios for the effect of fictional#
#'   observations, with length as large as the number of hyper#
#'   expressions.#
#' @return A fitted lm model#
#' @examples#
#' hierlm(Sepal.Length ~ 0 + Petal.Length + Species + Sepal.Width : Species | Species - ., iris, 1)#
#' hierlm(Sepal.Length ~ 0 + Petal.Length + Species + Sepal.Width : Species | Species - . | Sepal.Width : Species - ., iris, c(1, 2))#
#
hierlm <- function(formula, datas, ratios, sep="") {#
    if (is.data.frame(datas))#
        datas <- list(datas)#
#
    data.ii <- 1#
    ratio.ii <- 1#
#
    data <- datas[[data.ii]]#
#
    ## Split the formula by |#
    labels <- attr(terms(formula), 'term.labels')#
    if (length(labels) == 1) { # otherwise it's just an lm formula#
        lhs <- as.character(formula)[2]#
        chunks <- strsplit(labels, "\\|")[[1]]#
        formula <- as.formula(paste(lhs, "~", chunks[1]), env=attr(formula, '.Environment'))#
        for (chunk in chunks[-1]) {#
            ## Keep these around#
            oldformula <- formula#
            olddata <- data#
#
            ## Make the new formula#
            formula <- combine.formulae(formula, chunk)#
            if (!("constant" %in% names(data)) && "constant" %in% get.formula.terms(formula))#
                data$constant <- 1#
#
            terms <- get.hyper.terms(chunk)#
            if (length(terms) == 3) {#
                ## Build the new relationship#
                weight <- calc.fo.weights(oldformula, terms[1], ratios[ratio.ii], datas[[data.ii]]) # use original data#
                extras <- make.hyper.rows(terms[1], terms[2], weight, datas[[data.ii]])#
#
                ## Done with this ratio#
                ratio.ii <- ratio.ii + 1#
#
                ## Create indicators for nonhyper, if not already done#
                if (terms[1] %in% data)#
                    data <- replace.factor(terms[1], data, 1, sep=sep)#
#
                data <- combine.data.frames(data, extras)#
            } else {#
                ## Add in the next formula#
                data.ii <- data.ii + 1#
                data <- combine.data.frame(data, datas[[data.ii]])#
            }#
#
            ## Have any of the terms in the formula been factorized?#
            checks <- get.formula.terms(formula)#
            for (check in checks) {#
                if (check %in% names(olddata) && is.factor(olddata[, check]))#
                    formula <- replace.factor.formula(check, formula, olddata)#
            }#
        }#
    }#
#
    print(head(data))#
    print(tail(data))#
    print(formula)#
    lm(formula, data=data)#
}
hierlm(Sepal.Length ~ 0 + Petal.Length + Species + Sepal.Width : Species | Species - . | Sepal.Width : Species - ., iris, c(1, 2))
#' Fit an hierarchical model#
#'#
#' Interpret a hierarchical formula and fit it with the given data and weight ratios.#
#'#
#' @param formula an hierlm-style formula#
#' @param datas a data frame or a list of data frames, for each lm-style formula contained in the hierlm#
#' @param ratios a vector a ratios for the effect of fictional#
#'   observations, with length as large as the number of hyper#
#'   expressions.#
#' @return A fitted lm model#
#' @examples#
#' hierlm(Sepal.Length ~ 0 + Petal.Length + Species + Sepal.Width : Species | Species - ., iris, 1)#
#' hierlm(Sepal.Length ~ 0 + Petal.Length + Species + Sepal.Width : Species | Species - . | Sepal.Width : Species - ., iris, c(1, 2))#
#
hierlm <- function(formula, datas, ratios, sep="") {#
    if (is.data.frame(datas))#
        datas <- list(datas)#
#
    data.ii <- 1#
    ratio.ii <- 1#
#
    data <- datas[[data.ii]]#
#
    ## Split the formula by |#
    labels <- attr(terms(formula), 'term.labels')#
    if (length(labels) == 1) { # otherwise it's just an lm formula#
        lhs <- as.character(formula)[2]#
        chunks <- strsplit(labels, "\\|")[[1]]#
        formula <- as.formula(paste(lhs, "~", chunks[1]), env=attr(formula, '.Environment'))#
        for (chunk in chunks[-1]) {#
            print(chunk)#
            ## Keep these around#
            oldformula <- formula#
            olddata <- data#
#
            ## Make the new formula#
            formula <- combine.formulae(formula, chunk)#
            if (!("constant" %in% names(data)) && "constant" %in% get.formula.terms(formula))#
                data$constant <- 1#
#
            terms <- get.hyper.terms(chunk)#
            if (length(terms) == 3) {#
                ## Build the new relationship#
                weight <- calc.fo.weights(oldformula, terms[1], ratios[ratio.ii], datas[[data.ii]]) # use original data#
                extras <- make.hyper.rows(terms[1], terms[2], weight, datas[[data.ii]])#
#
                ## Done with this ratio#
                ratio.ii <- ratio.ii + 1#
#
                ## Create indicators for nonhyper, if not already done#
                if (terms[1] %in% data)#
                    data <- replace.factor(terms[1], data, 1, sep=sep)#
#
                data <- combine.data.frames(data, extras)#
            } else {#
                ## Add in the next formula#
                data.ii <- data.ii + 1#
                data <- combine.data.frame(data, datas[[data.ii]])#
            }#
#
            ## Have any of the terms in the formula been factorized?#
            checks <- get.formula.terms(formula)#
            for (check in checks) {#
                if (check %in% names(olddata) && is.factor(olddata[, check]))#
                    formula <- replace.factor.formula(check, formula, olddata)#
            }#
        }#
    }#
#
    print(head(data))#
    print(tail(data))#
    print(formula)#
    lm(formula, data=data)#
}
hierlm(Sepal.Length ~ 0 + Petal.Length + Species + Sepal.Width : Species | Species - . | Sepal.Width : Species - ., iris, c(1, 2))
#' Fit an hierarchical model#
#'#
#' Interpret a hierarchical formula and fit it with the given data and weight ratios.#
#'#
#' @param formula an hierlm-style formula#
#' @param datas a data frame or a list of data frames, for each lm-style formula contained in the hierlm#
#' @param ratios a vector a ratios for the effect of fictional#
#'   observations, with length as large as the number of hyper#
#'   expressions.#
#' @return A fitted lm model#
#' @examples#
#' hierlm(Sepal.Length ~ 0 + Petal.Length + Species + Sepal.Width : Species | Species - ., iris, 1)#
#' hierlm(Sepal.Length ~ 0 + Petal.Length + Species + Sepal.Width : Species | Species - . | Sepal.Width : Species - ., iris, c(1, 2))#
#
hierlm <- function(formula, datas, ratios, sep="") {#
    if (is.data.frame(datas))#
        datas <- list(datas)#
#
    data.ii <- 1#
    ratio.ii <- 1#
#
    data <- datas[[data.ii]]#
#
    ## Split the formula by |#
    labels <- attr(terms(formula), 'term.labels')#
    if (length(labels) == 1) { # otherwise it's just an lm formula#
        lhs <- as.character(formula)[2]#
        chunks <- strsplit(labels, "\\|")[[1]]#
        formula <- as.formula(paste(lhs, "~", chunks[1]), env=attr(formula, '.Environment'))#
        for (chunk in chunks[-1]) {#
            print(chunk)#
            ## Keep these around#
            oldformula <- formula#
            olddata <- data#
#
            ## Make the new formula#
            formula <- combine.formulae(formula, chunk)#
            if (!("constant" %in% names(data)) && "constant" %in% get.formula.terms(formula))#
                data$constant <- 1#
#
            terms <- get.hyper.terms(chunk)#
            if (length(terms) == 3) {#
                ## Build the new relationship#
                weight <- calc.fo.weights(oldformula, terms[1], ratios[ratio.ii], datas[[data.ii]]) # use original data#
                print("ao")#
                extras <- make.hyper.rows(terms[1], terms[2], weight, datas[[data.ii]])#
#
                ## Done with this ratio#
                ratio.ii <- ratio.ii + 1#
#
                ## Create indicators for nonhyper, if not already done#
                if (terms[1] %in% data)#
                    data <- replace.factor(terms[1], data, 1, sep=sep)#
#
                data <- combine.data.frames(data, extras)#
            } else {#
                ## Add in the next formula#
                data.ii <- data.ii + 1#
                data <- combine.data.frame(data, datas[[data.ii]])#
            }#
#
            ## Have any of the terms in the formula been factorized?#
            checks <- get.formula.terms(formula)#
            for (check in checks) {#
                if (check %in% names(olddata) && is.factor(olddata[, check]))#
                    formula <- replace.factor.formula(check, formula, olddata)#
            }#
        }#
    }#
#
    print(head(data))#
    print(tail(data))#
    print(formula)#
    lm(formula, data=data)#
}
hierlm(Sepal.Length ~ 0 + Petal.Length + Species + Sepal.Width : Species | Species - . | Sepal.Width : Species - ., iris, c(1, 2))
#' Fit an hierarchical model#
#'#
#' Interpret a hierarchical formula and fit it with the given data and weight ratios.#
#'#
#' @param formula an hierlm-style formula#
#' @param datas a data frame or a list of data frames, for each lm-style formula contained in the hierlm#
#' @param ratios a vector a ratios for the effect of fictional#
#'   observations, with length as large as the number of hyper#
#'   expressions.#
#' @return A fitted lm model#
#' @examples#
#' hierlm(Sepal.Length ~ 0 + Petal.Length + Species + Sepal.Width : Species | Species - ., iris, 1)#
#' hierlm(Sepal.Length ~ 0 + Petal.Length + Species + Sepal.Width : Species | Species - . | Sepal.Width : Species - ., iris, c(1, 2))#
#
hierlm <- function(formula, datas, ratios, sep="") {#
    if (is.data.frame(datas))#
        datas <- list(datas)#
#
    data.ii <- 1#
    ratio.ii <- 1#
#
    data <- datas[[data.ii]]#
#
    ## Split the formula by |#
    labels <- attr(terms(formula), 'term.labels')#
    if (length(labels) == 1) { # otherwise it's just an lm formula#
        lhs <- as.character(formula)[2]#
        chunks <- strsplit(labels, "\\|")[[1]]#
        formula <- as.formula(paste(lhs, "~", chunks[1]), env=attr(formula, '.Environment'))#
        for (chunk in chunks[-1]) {#
            print(chunk)#
            ## Keep these around#
            oldformula <- formula#
            olddata <- data#
#
            ## Make the new formula#
            formula <- combine.formulae(formula, chunk)#
            if (!("constant" %in% names(data)) && "constant" %in% get.formula.terms(formula))#
                data$constant <- 1#
#
            terms <- get.hyper.terms(chunk)#
            if (length(terms) == 3) {#
                print("ab")#
                ## Build the new relationship#
                weight <- calc.fo.weights(oldformula, terms[1], ratios[ratio.ii], datas[[data.ii]]) # use original data#
                print("ao")#
                extras <- make.hyper.rows(terms[1], terms[2], weight, datas[[data.ii]])#
#
                ## Done with this ratio#
                ratio.ii <- ratio.ii + 1#
#
                ## Create indicators for nonhyper, if not already done#
                if (terms[1] %in% data)#
                    data <- replace.factor(terms[1], data, 1, sep=sep)#
#
                data <- combine.data.frames(data, extras)#
            } else {#
                ## Add in the next formula#
                data.ii <- data.ii + 1#
                data <- combine.data.frame(data, datas[[data.ii]])#
            }#
#
            ## Have any of the terms in the formula been factorized?#
            checks <- get.formula.terms(formula)#
            for (check in checks) {#
                if (check %in% names(olddata) && is.factor(olddata[, check]))#
                    formula <- replace.factor.formula(check, formula, olddata)#
            }#
        }#
    }#
#
    print(head(data))#
    print(tail(data))#
    print(formula)#
    lm(formula, data=data)#
}
hierlm(Sepal.Length ~ 0 + Petal.Length + Species + Sepal.Width : Species | Species - . | Sepal.Width : Species - ., iris, c(1, 2))
#' Fit an hierarchical model#
#'#
#' Interpret a hierarchical formula and fit it with the given data and weight ratios.#
#'#
#' @param formula an hierlm-style formula#
#' @param datas a data frame or a list of data frames, for each lm-style formula contained in the hierlm#
#' @param ratios a vector a ratios for the effect of fictional#
#'   observations, with length as large as the number of hyper#
#'   expressions.#
#' @return A fitted lm model#
#' @examples#
#' hierlm(Sepal.Length ~ 0 + Petal.Length + Species + Sepal.Width : Species | Species - ., iris, 1)#
#' hierlm(Sepal.Length ~ 0 + Petal.Length + Species + Sepal.Width : Species | Species - . | Sepal.Width : Species - ., iris, c(1, 2))#
#
hierlm <- function(formula, datas, ratios, sep="") {#
    if (is.data.frame(datas))#
        datas <- list(datas)#
#
    data.ii <- 1#
    ratio.ii <- 1#
#
    data <- datas[[data.ii]]#
#
    ## Split the formula by |#
    labels <- attr(terms(formula), 'term.labels')#
    if (length(labels) == 1) { # otherwise it's just an lm formula#
        lhs <- as.character(formula)[2]#
        chunks <- strsplit(labels, "\\|")[[1]]#
        formula <- as.formula(paste(lhs, "~", chunks[1]), env=attr(formula, '.Environment'))#
        for (chunk in chunks[-1]) {#
            print(chunk)#
            ## Keep these around#
            oldformula <- formula#
            olddata <- data#
#
            ## Make the new formula#
            formula <- combine.formulae(formula, chunk)#
            if (!("constant" %in% names(data)) && "constant" %in% get.formula.terms(formula))#
                data$constant <- 1#
#
            print("xx")#
            terms <- get.hyper.terms(chunk)#
            if (length(terms) == 3) {#
                print("ab")#
                ## Build the new relationship#
                weight <- calc.fo.weights(oldformula, terms[1], ratios[ratio.ii], datas[[data.ii]]) # use original data#
                print("ao")#
                extras <- make.hyper.rows(terms[1], terms[2], weight, datas[[data.ii]])#
#
                ## Done with this ratio#
                ratio.ii <- ratio.ii + 1#
#
                ## Create indicators for nonhyper, if not already done#
                if (terms[1] %in% data)#
                    data <- replace.factor(terms[1], data, 1, sep=sep)#
#
                data <- combine.data.frames(data, extras)#
            } else {#
                ## Add in the next formula#
                data.ii <- data.ii + 1#
                data <- combine.data.frame(data, datas[[data.ii]])#
            }#
#
            ## Have any of the terms in the formula been factorized?#
            checks <- get.formula.terms(formula)#
            for (check in checks) {#
                if (check %in% names(olddata) && is.factor(olddata[, check]))#
                    formula <- replace.factor.formula(check, formula, olddata)#
            }#
        }#
    }#
#
    print(head(data))#
    print(tail(data))#
    print(formula)#
    lm(formula, data=data)#
}
hierlm(Sepal.Length ~ 0 + Petal.Length + Species + Sepal.Width : Species | Species - . | Sepal.Width : Species - ., iris, c(1, 2))
#' Fit an hierarchical model#
#'#
#' Interpret a hierarchical formula and fit it with the given data and weight ratios.#
#'#
#' @param formula an hierlm-style formula#
#' @param datas a data frame or a list of data frames, for each lm-style formula contained in the hierlm#
#' @param ratios a vector a ratios for the effect of fictional#
#'   observations, with length as large as the number of hyper#
#'   expressions.#
#' @return A fitted lm model#
#' @examples#
#' hierlm(Sepal.Length ~ 0 + Petal.Length + Species + Sepal.Width : Species | Species - ., iris, 1)#
#' hierlm(Sepal.Length ~ 0 + Petal.Length + Species + Sepal.Width : Species | Species - . | Sepal.Width : Species - ., iris, c(1, 2))#
#
hierlm <- function(formula, datas, ratios, sep="") {#
    if (is.data.frame(datas))#
        datas <- list(datas)#
#
    data.ii <- 1#
    ratio.ii <- 1#
#
    data <- datas[[data.ii]]#
#
    ## Split the formula by |#
    labels <- attr(terms(formula), 'term.labels')#
    if (length(labels) == 1) { # otherwise it's just an lm formula#
        lhs <- as.character(formula)[2]#
        chunks <- strsplit(labels, "\\|")[[1]]#
        formula <- as.formula(paste(lhs, "~", chunks[1]), env=attr(formula, '.Environment'))#
        for (chunk in chunks[-1]) {#
            print(chunk)#
            ## Keep these around#
            oldformula <- formula#
            olddata <- data#
#
            ## Make the new formula#
            formula <- combine.formulae(formula, chunk)#
            print("vv")#
            if (!("constant" %in% names(data)) && "constant" %in% get.formula.terms(formula))#
                data$constant <- 1#
#
            print("xx")#
            terms <- get.hyper.terms(chunk)#
            if (length(terms) == 3) {#
                print("ab")#
                ## Build the new relationship#
                weight <- calc.fo.weights(oldformula, terms[1], ratios[ratio.ii], datas[[data.ii]]) # use original data#
                print("ao")#
                extras <- make.hyper.rows(terms[1], terms[2], weight, datas[[data.ii]])#
#
                ## Done with this ratio#
                ratio.ii <- ratio.ii + 1#
#
                ## Create indicators for nonhyper, if not already done#
                if (terms[1] %in% data)#
                    data <- replace.factor(terms[1], data, 1, sep=sep)#
#
                data <- combine.data.frames(data, extras)#
            } else {#
                ## Add in the next formula#
                data.ii <- data.ii + 1#
                data <- combine.data.frame(data, datas[[data.ii]])#
            }#
#
            ## Have any of the terms in the formula been factorized?#
            checks <- get.formula.terms(formula)#
            for (check in checks) {#
                if (check %in% names(olddata) && is.factor(olddata[, check]))#
                    formula <- replace.factor.formula(check, formula, olddata)#
            }#
        }#
    }#
#
    print(head(data))#
    print(tail(data))#
    print(formula)#
    lm(formula, data=data)#
}
hierlm(Sepal.Length ~ 0 + Petal.Length + Species + Sepal.Width : Species | Species - . | Sepal.Width : Species - ., iris, c(1, 2))
#' Combine two formulas in hierlm-format#
#'#
#' Return the left and right side of a new combined formula.#
#' Left formula must be a standard formula.  Right formula may take the following forms:#
#' y ~ ... : an lm-style formula; the left-hand-side variables much match#
#' f - b : A requirement that two variables be close together (typically one is a factor)#
#' f - . : A requirement that a variable (or set of factors) be close to a new hyper-variable#
#' a : f - [b or .] : A requirement that the results of an interaction be near a hyper-variable#
#' TODO:#
#' a + B : A requirement that the factors in 'a' are similar to eachother by smoothness 'B'#
#'#
#' @param formula1 an lm-style formula#
#' @param formula2 an additional formula or hierlm term#
#' @return Augmented formula#
#' @examples#
#' combine.formulae(combine.formulae(combine.formulae(y ~ a + b, "b - c"), y ~ c + d), "c : d - .")#
#
combine.formulae <- function(formula1, formula2, sep="") {#
    chunks1 <- as.character(formula1)#
#
    if (is.character(formula2))#
        if (grepl("~", formula2))#
            formula2 <- as.formula(formula2)#
#
    if (class(formula2) == "formula") {#
        chunks2 <- as.character(formula2)#
        if (chunks2[2] != chunks1[2])#
            error("Left-hand-side variables do not match.")#
#
        terms1 <- get.formula.terms(formula1)#
        terms2 <- get.formula.terms(formula2)#
    } else {#
        print("yy")#
        terms2 <- get.hyper.terms(formula2, sep=sep)#
        if (length(terms2) != 3)#
            error(paste("Cannot understand expression:", formula2))#
#
        terms2 <- terms2[-3]#
#
        terms1 <- get.formula.terms(formula1)#
        if (attr(terms(formula1), 'intercept') == 0) {#
            if (!("0" %in% terms1))#
                terms1 <- c("0", terms1)#
        } else {#
            if (!("0" %in% terms1 && "constant" %in% terms1))#
                terms1 <- c("0", "constant", terms1)#
        }#
    }#
#
    for (term in terms2)#
        if (!(term %in% terms1))#
            terms1 <- c(terms1, term)#
#
    as.formula(paste(chunks1[2], "~", paste(terms1, collapse=" + ")),#
               env=attr(formula1, '.Environment'))#
}
hierlm(Sepal.Length ~ 0 + Petal.Length + Species + Sepal.Width : Species | Species - . | Sepal.Width : Species - ., iris, c(1, 2))
#' Combine two formulas in hierlm-format#
#'#
#' Return the left and right side of a new combined formula.#
#' Left formula must be a standard formula.  Right formula may take the following forms:#
#' y ~ ... : an lm-style formula; the left-hand-side variables much match#
#' f - b : A requirement that two variables be close together (typically one is a factor)#
#' f - . : A requirement that a variable (or set of factors) be close to a new hyper-variable#
#' a : f - [b or .] : A requirement that the results of an interaction be near a hyper-variable#
#' TODO:#
#' a + B : A requirement that the factors in 'a' are similar to eachother by smoothness 'B'#
#'#
#' @param formula1 an lm-style formula#
#' @param formula2 an additional formula or hierlm term#
#' @return Augmented formula#
#' @examples#
#' combine.formulae(combine.formulae(combine.formulae(y ~ a + b, "b - c"), y ~ c + d), "c : d - .")#
#
combine.formulae <- function(formula1, formula2, sep="") {#
    chunks1 <- as.character(formula1)#
#
    if (is.character(formula2))#
        if (grepl("~", formula2))#
            formula2 <- as.formula(formula2)#
#
    if (class(formula2) == "formula") {#
        chunks2 <- as.character(formula2)#
        if (chunks2[2] != chunks1[2])#
            error("Left-hand-side variables do not match.")#
#
        terms1 <- get.formula.terms(formula1)#
        terms2 <- get.formula.terms(formula2)#
    } else {#
        print("yy")#
        terms2 <- get.hyper.terms(formula2, sep=sep)#
        if (length(terms2) != 3)#
            error(paste("Cannot understand expression:", formula2))#
#
        terms2 <- terms2[-3]#
#
        terms1 <- get.formula.terms(formula1)#
        print("uu")#
        if (attr(terms(formula1), 'intercept') == 0) {#
            if (!("0" %in% terms1))#
                terms1 <- c("0", terms1)#
        } else {#
            if (!("0" %in% terms1 && "constant" %in% terms1))#
                terms1 <- c("0", "constant", terms1)#
        }#
    }#
#
    for (term in terms2)#
        if (!(term %in% terms1))#
            terms1 <- c(terms1, term)#
#
    as.formula(paste(chunks1[2], "~", paste(terms1, collapse=" + ")),#
               env=attr(formula1, '.Environment'))#
}
hierlm(Sepal.Length ~ 0 + Petal.Length + Species + Sepal.Width : Species | Species - . | Sepal.Width : Species - ., iris, c(1, 2))
#' Combine two formulas in hierlm-format#
#'#
#' Return the left and right side of a new combined formula.#
#' Left formula must be a standard formula.  Right formula may take the following forms:#
#' y ~ ... : an lm-style formula; the left-hand-side variables much match#
#' f - b : A requirement that two variables be close together (typically one is a factor)#
#' f - . : A requirement that a variable (or set of factors) be close to a new hyper-variable#
#' a : f - [b or .] : A requirement that the results of an interaction be near a hyper-variable#
#' TODO:#
#' a + B : A requirement that the factors in 'a' are similar to eachother by smoothness 'B'#
#'#
#' @param formula1 an lm-style formula#
#' @param formula2 an additional formula or hierlm term#
#' @return Augmented formula#
#' @examples#
#' combine.formulae(combine.formulae(combine.formulae(y ~ a + b, "b - c"), y ~ c + d), "c : d - .")#
#
combine.formulae <- function(formula1, formula2, sep="") {#
    chunks1 <- as.character(formula1)#
#
    if (is.character(formula2))#
        if (grepl("~", formula2))#
            formula2 <- as.formula(formula2)#
#
    if (class(formula2) == "formula") {#
        chunks2 <- as.character(formula2)#
        if (chunks2[2] != chunks1[2])#
            error("Left-hand-side variables do not match.")#
#
        terms1 <- get.formula.terms(formula1)#
        terms2 <- get.formula.terms(formula2)#
    } else {#
        print("yy")#
        terms2 <- get.hyper.terms(formula2, sep=sep)#
        if (length(terms2) != 3)#
            error(paste("Cannot understand expression:", formula2))#
#
        terms2 <- terms2[-3]#
#
        terms1 <- get.formula.terms(formula1)#
        print("uu")#
        if (attr(terms(formula1), 'intercept') == 0) {#
            if (!("0" %in% terms1))#
                terms1 <- c("0", terms1)#
        } else {#
            if (!("0" %in% terms1 && "constant" %in% terms1))#
                terms1 <- c("0", "constant", terms1)#
        }#
    }#
#
    print("tt")#
    for (term in terms2)#
        if (!(term %in% terms1))#
            terms1 <- c(terms1, term)#
#
    as.formula(paste(chunks1[2], "~", paste(terms1, collapse=" + ")),#
               env=attr(formula1, '.Environment'))#
}
hierlm(Sepal.Length ~ 0 + Petal.Length + Species + Sepal.Width : Species | Species - . | Sepal.Width : Species - ., iris, c(1, 2))
#' Combine two formulas in hierlm-format#
#'#
#' Return the left and right side of a new combined formula.#
#' Left formula must be a standard formula.  Right formula may take the following forms:#
#' y ~ ... : an lm-style formula; the left-hand-side variables much match#
#' f - b : A requirement that two variables be close together (typically one is a factor)#
#' f - . : A requirement that a variable (or set of factors) be close to a new hyper-variable#
#' a : f - [b or .] : A requirement that the results of an interaction be near a hyper-variable#
#' TODO:#
#' a + B : A requirement that the factors in 'a' are similar to eachother by smoothness 'B'#
#'#
#' @param formula1 an lm-style formula#
#' @param formula2 an additional formula or hierlm term#
#' @return Augmented formula#
#' @examples#
#' combine.formulae(combine.formulae(combine.formulae(y ~ a + b, "b - c"), y ~ c + d), "c : d - .")#
#
combine.formulae <- function(formula1, formula2, sep="") {#
    chunks1 <- as.character(formula1)#
#
    if (is.character(formula2))#
        if (grepl("~", formula2))#
            formula2 <- as.formula(formula2)#
#
    if (class(formula2) == "formula") {#
        chunks2 <- as.character(formula2)#
        if (chunks2[2] != chunks1[2])#
            error("Left-hand-side variables do not match.")#
#
        terms1 <- get.formula.terms(formula1)#
        terms2 <- get.formula.terms(formula2)#
    } else {#
        print("yy")#
        terms2 <- get.hyper.terms(formula2, sep=sep)#
        if (length(terms2) != 3)#
            error(paste("Cannot understand expression:", formula2))#
#
        terms2 <- terms2[-3]#
#
        terms1 <- get.formula.terms(formula1)#
        print("uu")#
        if (attr(terms(formula1), 'intercept') == 0) {#
            print("ss")#
            if (!("0" %in% terms1))#
                terms1 <- c("0", terms1)#
        } else {#
            if (!("0" %in% terms1 && "constant" %in% terms1))#
                terms1 <- c("0", "constant", terms1)#
        }#
    }#
#
    print("tt")#
    for (term in terms2)#
        if (!(term %in% terms1))#
            terms1 <- c(terms1, term)#
#
    as.formula(paste(chunks1[2], "~", paste(terms1, collapse=" + ")),#
               env=attr(formula1, '.Environment'))#
}
hierlm(Sepal.Length ~ 0 + Petal.Length + Species + Sepal.Width : Species | Species - . | Sepal.Width : Species - ., iris, c(1, 2))
#' Combine two formulas in hierlm-format#
#'#
#' Return the left and right side of a new combined formula.#
#' Left formula must be a standard formula.  Right formula may take the following forms:#
#' y ~ ... : an lm-style formula; the left-hand-side variables much match#
#' f - b : A requirement that two variables be close together (typically one is a factor)#
#' f - . : A requirement that a variable (or set of factors) be close to a new hyper-variable#
#' a : f - [b or .] : A requirement that the results of an interaction be near a hyper-variable#
#' TODO:#
#' a + B : A requirement that the factors in 'a' are similar to eachother by smoothness 'B'#
#'#
#' @param formula1 an lm-style formula#
#' @param formula2 an additional formula or hierlm term#
#' @return Augmented formula#
#' @examples#
#' combine.formulae(combine.formulae(combine.formulae(y ~ a + b, "b - c"), y ~ c + d), "c : d - .")#
#
combine.formulae <- function(formula1, formula2, sep="") {#
    chunks1 <- as.character(formula1)#
#
    if (is.character(formula2))#
        if (grepl("~", formula2))#
            formula2 <- as.formula(formula2)#
#
    if (class(formula2) == "formula") {#
        chunks2 <- as.character(formula2)#
        if (chunks2[2] != chunks1[2])#
            error("Left-hand-side variables do not match.")#
#
        terms1 <- get.formula.terms(formula1)#
        terms2 <- get.formula.terms(formula2)#
    } else {#
        print("yy")#
        terms2 <- get.hyper.terms(formula2, sep=sep)#
        if (length(terms2) != 3)#
            error(paste("Cannot understand expression:", formula2))#
#
        terms2 <- terms2[-3]#
#
        terms1 <- get.formula.terms(formula1)#
        print("uu")#
        print(attr(terms(formula1), 'intercept'))#
        if (attr(terms(formula1), 'intercept') == 0) {#
            print("ss")#
            if (!("0" %in% terms1))#
                terms1 <- c("0", terms1)#
        } else {#
            if (!("0" %in% terms1 && "constant" %in% terms1))#
                terms1 <- c("0", "constant", terms1)#
        }#
    }#
#
    print("tt")#
    for (term in terms2)#
        if (!(term %in% terms1))#
            terms1 <- c(terms1, term)#
#
    as.formula(paste(chunks1[2], "~", paste(terms1, collapse=" + ")),#
               env=attr(formula1, '.Environment'))#
}
hierlm(Sepal.Length ~ 0 + Petal.Length + Species + Sepal.Width : Species | Species - . | Sepal.Width : Species - ., iris, c(1, 2))
#' Combine two formulas in hierlm-format#
#'#
#' Return the left and right side of a new combined formula.#
#' Left formula must be a standard formula.  Right formula may take the following forms:#
#' y ~ ... : an lm-style formula; the left-hand-side variables much match#
#' f - b : A requirement that two variables be close together (typically one is a factor)#
#' f - . : A requirement that a variable (or set of factors) be close to a new hyper-variable#
#' a : f - [b or .] : A requirement that the results of an interaction be near a hyper-variable#
#' TODO:#
#' a + B : A requirement that the factors in 'a' are similar to eachother by smoothness 'B'#
#'#
#' @param formula1 an lm-style formula#
#' @param formula2 an additional formula or hierlm term#
#' @return Augmented formula#
#' @examples#
#' combine.formulae(combine.formulae(combine.formulae(y ~ a + b, "b - c"), y ~ c + d), "c : d - .")#
#
combine.formulae <- function(formula1, formula2, sep="") {#
    chunks1 <- as.character(formula1)#
#
    if (is.character(formula2))#
        if (grepl("~", formula2))#
            formula2 <- as.formula(formula2)#
#
    if (class(formula2) == "formula") {#
        chunks2 <- as.character(formula2)#
        if (chunks2[2] != chunks1[2])#
            error("Left-hand-side variables do not match.")#
#
        terms1 <- get.formula.terms(formula1)#
        terms2 <- get.formula.terms(formula2)#
    } else {#
        print("yy")#
        terms2 <- get.hyper.terms(formula2, sep=sep)#
        if (length(terms2) != 3)#
            error(paste("Cannot understand expression:", formula2))#
#
        terms2 <- terms2[-3]#
#
        terms1 <- get.formula.terms(formula1)#
        print("uu")#
        print(formula1)#
        print(attr(terms(formula1), 'intercept'))#
        if (attr(terms(formula1), 'intercept') == 0) {#
            print("ss")#
            if (!("0" %in% terms1))#
                terms1 <- c("0", terms1)#
        } else {#
            if (!("0" %in% terms1 && "constant" %in% terms1))#
                terms1 <- c("0", "constant", terms1)#
        }#
    }#
#
    print("tt")#
    for (term in terms2)#
        if (!(term %in% terms1))#
            terms1 <- c(terms1, term)#
#
    as.formula(paste(chunks1[2], "~", paste(terms1, collapse=" + ")),#
               env=attr(formula1, '.Environment'))#
}
hierlm(Sepal.Length ~ 0 + Petal.Length + Species + Sepal.Width : Species | Species - . | Sepal.Width : Species - ., iris, c(1, 2))
#' Combine two formulas in hierlm-format#
#'#
#' Return the left and right side of a new combined formula.#
#' Left formula must be a standard formula.  Right formula may take the following forms:#
#' y ~ ... : an lm-style formula; the left-hand-side variables much match#
#' f - b : A requirement that two variables be close together (typically one is a factor)#
#' f - . : A requirement that a variable (or set of factors) be close to a new hyper-variable#
#' a : f - [b or .] : A requirement that the results of an interaction be near a hyper-variable#
#' TODO:#
#' a + B : A requirement that the factors in 'a' are similar to eachother by smoothness 'B'#
#'#
#' @param formula1 an lm-style formula#
#' @param formula2 an additional formula or hierlm term#
#' @return Augmented formula#
#' @examples#
#' combine.formulae(combine.formulae(combine.formulae(y ~ a + b, "b - c"), y ~ c + d), "c : d - .")#
#
combine.formulae <- function(formula1, formula2, sep="") {#
    chunks1 <- as.character(formula1)#
#
    if (is.character(formula2))#
        if (grepl("~", formula2))#
            formula2 <- as.formula(formula2)#
#
    if (class(formula2) == "formula") {#
        chunks2 <- as.character(formula2)#
        if (chunks2[2] != chunks1[2])#
            error("Left-hand-side variables do not match.")#
#
        terms1 <- get.formula.terms(formula1)#
        terms2 <- get.formula.terms(formula2)#
    } else {#
        print("yy")#
        terms2 <- get.hyper.terms(formula2, sep=sep)#
        if (length(terms2) != 3)#
            error(paste("Cannot understand expression:", formula2))#
#
        terms2 <- terms2[-3]#
#
        terms1 <- get.formula.terms(formula1)#
        print("uu")#
        print(class(formula1))#
        print(attr(terms(formula1), 'intercept'))#
        if (attr(terms(formula1), 'intercept') == 0) {#
            print("ss")#
            if (!("0" %in% terms1))#
                terms1 <- c("0", terms1)#
        } else {#
            if (!("0" %in% terms1 && "constant" %in% terms1))#
                terms1 <- c("0", "constant", terms1)#
        }#
    }#
#
    print("tt")#
    for (term in terms2)#
        if (!(term %in% terms1))#
            terms1 <- c(terms1, term)#
#
    as.formula(paste(chunks1[2], "~", paste(terms1, collapse=" + ")),#
               env=attr(formula1, '.Environment'))#
}
hierlm(Sepal.Length ~ 0 + Petal.Length + Species + Sepal.Width : Species | Species - . | Sepal.Width : Species - ., iris, c(1, 2))
#' Replace a factor term#
#'#
#' Constructs indicator terms for a factor variable.#
#'#
#' @param name term name#
#' @param formula formula#
#' @param sep paste sep used to construct factor names#
#' @return Modified formula#
#' @examples#
#' replace.factor.formula("Species", Sepal.Length ~ Species)#
#' replace.factor.formula("Species", Sepal.Length ~ Petal.Length : Species)#
#
replace.factor.formula <- function(name, formula, data, sep="") {#
    terms <- c()#
#
    for (term in get.formula.terms(formula)) {#
        if (term == name) {#
            terms <- c(terms, make.factor.names(name, data))#
        } else if (grepl(':', term)) {#
            subterms <- split.interaction.term(term)#
            if (subterms[1] == name) {#
                terms <- c(terms, paste(make.factor.names(subterms[1], data), subterms[2], sep=':'))#
            } else if (subterms[2] == name) {#
                terms <- c(terms, paste(subterms[1], make.factor.names(subterms[2], data), sep=':'))#
            } else {#
                terms <- c(terms, term)#
            }#
        } else {#
            terms <- c(terms, term)#
        }#
    }#
#
    chunks <- as.character(formula)#
    as.formula(paste(chunks[2], paste(terms, collapse=" + "), sep=" ~ "))#
}
hierlm(Sepal.Length ~ 0 + Petal.Length + Species + Sepal.Width : Species | Species - . | Sepal.Width : Species - ., iris, c(1, 2))
#' Combine two formulas in hierlm-format#
#'#
#' Return the left and right side of a new combined formula.#
#' Left formula must be a standard formula.  Right formula may take the following forms:#
#' y ~ ... : an lm-style formula; the left-hand-side variables much match#
#' f - b : A requirement that two variables be close together (typically one is a factor)#
#' f - . : A requirement that a variable (or set of factors) be close to a new hyper-variable#
#' a : f - [b or .] : A requirement that the results of an interaction be near a hyper-variable#
#' TODO:#
#' a + B : A requirement that the factors in 'a' are similar to eachother by smoothness 'B'#
#'#
#' @param formula1 an lm-style formula#
#' @param formula2 an additional formula or hierlm term#
#' @return Augmented formula#
#' @examples#
#' combine.formulae(combine.formulae(combine.formulae(y ~ a + b, "b - c"), y ~ c + d), "c : d - .")#
#
combine.formulae <- function(formula1, formula2, sep="") {#
    chunks1 <- as.character(formula1)#
#
    if (is.character(formula2))#
        if (grepl("~", formula2))#
            formula2 <- as.formula(formula2)#
#
    if (class(formula2) == "formula") {#
        chunks2 <- as.character(formula2)#
        if (chunks2[2] != chunks1[2])#
            error("Left-hand-side variables do not match.")#
#
        terms1 <- get.formula.terms(formula1)#
        terms2 <- get.formula.terms(formula2)#
    } else {#
        terms2 <- get.hyper.terms(formula2, sep=sep)#
        if (length(terms2) != 3)#
            error(paste("Cannot understand expression:", formula2))#
#
        terms2 <- terms2[-3]#
#
        terms1 <- get.formula.terms(formula1)#
        if (attr(terms(formula1), 'intercept') == 0) {#
            if (!("0" %in% terms1))#
                terms1 <- c("0", terms1)#
        } else {#
            if (!("0" %in% terms1 && "constant" %in% terms1))#
                terms1 <- c("0", "constant", terms1)#
        }#
    }#
#
    for (term in terms2)#
        if (!(term %in% terms1))#
            terms1 <- c(terms1, term)#
#
    as.formula(paste(chunks1[2], "~", paste(terms1, collapse=" + ")),#
               env=attr(formula1, '.Environment'))#
}
hierlm(Sepal.Length ~ 0 + Petal.Length + Species + Sepal.Width : Species | Species - . | Sepal.Width : Species - ., iris, c(1, 2))
#' Fit an hierarchical model#
#'#
#' Interpret a hierarchical formula and fit it with the given data and weight ratios.#
#'#
#' @param formula an hierlm-style formula#
#' @param datas a data frame or a list of data frames, for each lm-style formula contained in the hierlm#
#' @param ratios a vector a ratios for the effect of fictional#
#'   observations, with length as large as the number of hyper#
#'   expressions.#
#' @return A fitted lm model#
#' @examples#
#' hierlm(Sepal.Length ~ 0 + Petal.Length + Species + Sepal.Width : Species | Species - ., iris, 1)#
#' hierlm(Sepal.Length ~ 0 + Petal.Length + Species + Sepal.Width : Species | Species - . | Sepal.Width : Species - ., iris, c(1, 2))#
#
hierlm <- function(formula, datas, ratios, sep="") {#
    if (is.data.frame(datas))#
        datas <- list(datas)#
#
    data.ii <- 1#
    ratio.ii <- 1#
#
    data <- datas[[data.ii]]#
#
    ## Split the formula by |#
    labels <- attr(terms(formula), 'term.labels')#
    if (length(labels) == 1) { # otherwise it's just an lm formula#
        lhs <- as.character(formula)[2]#
        chunks <- strsplit(labels, "\\|")[[1]]#
        formula <- as.formula(paste(lhs, "~", chunks[1]), env=attr(formula, '.Environment'))#
        ## Keep this for weight calculations#
        oldformula <- formula#
        for (chunk in chunks[-1]) {#
            print(chunk)#
            ## Keep these around#
            olddata <- data#
#
            ## Make the new formula#
            formula <- combine.formulae(formula, chunk)#
            print("vv")#
            if (!("constant" %in% names(data)) && "constant" %in% get.formula.terms(formula))#
                data$constant <- 1#
#
            print("xx")#
#
            terms <- get.hyper.terms(chunk)#
            if (length(terms) == 3) {#
                print("ab")#
                ## Build the new relationship#
                weight <- calc.fo.weights(oldformula, terms[1], ratios[ratio.ii], datas[[data.ii]]) # use original data#
                print("ao")#
                extras <- make.hyper.rows(terms[1], terms[2], weight, datas[[data.ii]])#
#
                ## Done with this ratio#
                ratio.ii <- ratio.ii + 1#
#
                ## Create indicators for nonhyper, if not already done#
                if (terms[1] %in% data)#
                    data <- replace.factor(terms[1], data, 1, sep=sep)#
#
                data <- combine.data.frames(data, extras)#
            } else {#
                ## Add in the next formula#
                data.ii <- data.ii + 1#
                data <- combine.data.frame(data, datas[[data.ii]])#
            }#
#
            ## Have any of the terms in the formula been factorized?#
            checks <- get.formula.terms(formula)#
            for (check in checks) {#
                if (check %in% names(olddata) && is.factor(olddata[, check]))#
                    formula <- replace.factor.formula(check, formula, olddata)#
            }#
        }#
    }#
#
    print(head(data))#
    print(tail(data))#
    print(formula)#
    lm(formula, data=data)#
}
hierlm(Sepal.Length ~ 0 + Petal.Length + Species + Sepal.Width : Species | Species - . | Sepal.Width : Species - ., iris, c(1, 2))
#' Fit an hierarchical model#
#'#
#' Interpret a hierarchical formula and fit it with the given data and weight ratios.#
#'#
#' @param formula an hierlm-style formula#
#' @param datas a data frame or a list of data frames, for each lm-style formula contained in the hierlm#
#' @param ratios a vector a ratios for the effect of fictional#
#'   observations, with length as large as the number of hyper#
#'   expressions.#
#' @return A fitted lm model#
#' @examples#
#' hierlm(Sepal.Length ~ 0 + Petal.Length + Species + Sepal.Width : Species | Species - ., iris, 1)#
#' hierlm(Sepal.Length ~ 0 + Petal.Length + Species + Sepal.Width : Species | Species - . | Sepal.Width : Species - ., iris, c(1, 2))#
#
hierlm <- function(formula, datas, ratios, sep="") {#
    if (is.data.frame(datas))#
        datas <- list(datas)#
#
    data.ii <- 1#
    ratio.ii <- 1#
#
    data <- datas[[data.ii]]#
#
    ## Split the formula by |#
    labels <- attr(terms(formula), 'term.labels')#
    if (length(labels) == 1) { # otherwise it's just an lm formula#
        lhs <- as.character(formula)[2]#
        chunks <- strsplit(labels, "\\|")[[1]]#
        formula <- as.formula(paste(lhs, "~", chunks[1]), env=attr(formula, '.Environment'))#
        ## Keep this for weight calculations#
        oldformula <- formula#
        for (chunk in chunks[-1]) {#
            print(chunk)#
            ## Keep these around#
            olddata <- data#
#
            ## Make the new formula#
            formula <- combine.formulae(formula, chunk)#
            print("vv")#
            if (!("constant" %in% names(data)) && "constant" %in% get.formula.terms(formula))#
                data$constant <- 1#
#
            print("xx")#
#
            terms <- get.hyper.terms(chunk)#
            if (length(terms) == 3) {#
                print("ab")#
                ## Build the new relationship#
                weight <- calc.fo.weights(oldformula, terms[1], ratios[ratio.ii], datas[[data.ii]]) # use original data#
                print("ao")#
                print(terms)#
                extras <- make.hyper.rows(terms[1], terms[2], weight, datas[[data.ii]])#
#
                ## Done with this ratio#
                ratio.ii <- ratio.ii + 1#
#
                ## Create indicators for nonhyper, if not already done#
                if (terms[1] %in% data)#
                    data <- replace.factor(terms[1], data, 1, sep=sep)#
#
                data <- combine.data.frames(data, extras)#
            } else {#
                ## Add in the next formula#
                data.ii <- data.ii + 1#
                data <- combine.data.frame(data, datas[[data.ii]])#
            }#
#
            ## Have any of the terms in the formula been factorized?#
            checks <- get.formula.terms(formula)#
            for (check in checks) {#
                if (check %in% names(olddata) && is.factor(olddata[, check]))#
                    formula <- replace.factor.formula(check, formula, olddata)#
            }#
        }#
    }#
#
    print(head(data))#
    print(tail(data))#
    print(formula)#
    lm(formula, data=data)#
}
hierlm(Sepal.Length ~ 0 + Petal.Length + Species + Sepal.Width : Species | Species - . | Sepal.Width : Species - ., iris, c(1, 2))
make.hyper.rows("Species", "hyperSpecies", 5, iris)
#' Get any new hyper terms from formula#
#'#
#' If the "a - b" formula requires the creation of a new hyper terms#
#' (one of a or b is .), return them.#
#'#
#' @param formula Single component of a hierlm formula#
#' @return Vector of c(nonhyper, hyper, is.interaction), if a new one was created;#
#'   or c(left, right, NA) if both terms are given;#
#'   or c() if not an "a - b" expression#
#' @examples#
#' get.hyper.terms(Sepal.Length ~ Petal.Length + Species + Sepal.Width : Species)#
#
get.hyper.terms <- function(formula, sep="") {#
    if (class(formula) == "formula")#
        return(c())#
#
    terms <- strsplit(formula, "-")[[1]]#
    if (length(terms) != 2)#
        return(c())#
#
    terms <- gsub("^\\s+|\\s+$", "", terms)#
    if ("." %in% terms) {#
        nonhyper <- terms[terms != "."]#
        if (grepl(':', nonhyper)) {#
            subterms <- split.interaction.term(nonhyper)#
            hyper <- paste("hyper", paste(subterms, collapse=sep), sep=sep)#
            return(c(nonhyper, hyper, T))#
        } else {#
            hyper <- paste("hyper", nonhyper, sep=sep)#
            return(c(nonhyper, hyper, F))#
        }#
    }#
    return(c(terms, NA))#
}
get.hyper.terms(Sepal.Length ~ Petal.Length + Species + Sepal.Width : Species)
#' Create fictional observations for a hyper relationship#
#'#
#' Return a data frame with fictional observations#
#'#
#' @param nonhyper name of the non-hyper column#
#' @param hyper name of the hyper column#
#' @param weight weight to be used in the rows#
#' @param data a data frame for inspecting levels#
#' @return Fictional observations in a data frame#
#' @examples#
#' make.hyper.rows("Species", "hyperSpecies", 5, iris)#
#
make.hyper.rows <- function(nonhyper, hyper, weight, data, sep="") {#
    if (grepl(':', nonhyper)) {#
        for (subterm in split.interaction.term(nonhyper)) {#
            if (!is.numeric(data[, subterm]))#
                return(make.hyper.rows(subterm, hyper))#
        }#
    } else {#
        ## Construct extra from diagonal factor matrix#
        extras <- diag(weight, length(unique(data[, nonhyper])))#
        extras <- as.data.frame(extras)#
#
        names(extras) <- paste(nonhyper, unique(data[, nonhyper]), sep=sep)#
#
        ## Add in the hyper column#
        extras[, hyper] <- -weight#
#
        extras#
    }#
}
hierlm(Sepal.Length ~ 0 + Petal.Length + Species + Sepal.Width : Species | Species - . | Sepal.Width : Species - ., iris, c(1, 2))
#' Create fictional observations for a hyper relationship#
#'#
#' Return a data frame with fictional observations#
#'#
#' @param nonhyper name of the non-hyper column#
#' @param hyper name of the hyper column#
#' @param weight weight to be used in the rows#
#' @param data a data frame for inspecting levels#
#' @return Fictional observations in a data frame#
#' @examples#
#' make.hyper.rows("Species", "hyperSpecies", 5, iris)#
#
make.hyper.rows <- function(nonhyper, hyper, weight, data, sep="") {#
    if (grepl(':', nonhyper)) {#
        for (subterm in split.interaction.term(nonhyper)) {#
            if (!is.numeric(data[, subterm]))#
                return(make.hyper.rows(subterm, hyper, weight, data))#
        }#
    } else {#
        ## Construct extra from diagonal factor matrix#
        extras <- diag(weight, length(unique(data[, nonhyper])))#
        extras <- as.data.frame(extras)#
#
        names(extras) <- paste(nonhyper, unique(data[, nonhyper]), sep=sep)#
#
        ## Add in the hyper column#
        extras[, hyper] <- -weight#
#
        extras#
    }#
}
hierlm(Sepal.Length ~ 0 + Petal.Length + Species + Sepal.Width : Species | Species - . | Sepal.Width : Species - ., iris, c(1, 2))
#' Fit an hierarchical model#
#'#
#' Interpret a hierarchical formula and fit it with the given data and weight ratios.#
#'#
#' @param formula an hierlm-style formula#
#' @param datas a data frame or a list of data frames, for each lm-style formula contained in the hierlm#
#' @param ratios a vector a ratios for the effect of fictional#
#'   observations, with length as large as the number of hyper#
#'   expressions.#
#' @return A fitted lm model#
#' @examples#
#' hierlm(Sepal.Length ~ 0 + Petal.Length + Species + Sepal.Width : Species | Species - ., iris, 1)#
#' hierlm(Sepal.Length ~ 0 + Petal.Length + Species + Sepal.Width : Species | Species - . | Sepal.Width : Species - ., iris, c(1, 2))#
#
hierlm <- function(formula, datas, ratios, sep="") {#
    if (is.data.frame(datas))#
        datas <- list(datas)#
#
    data.ii <- 1#
    ratio.ii <- 1#
#
    data <- datas[[data.ii]]#
#
    ## Split the formula by |#
    labels <- attr(terms(formula), 'term.labels')#
    if (length(labels) == 1) { # otherwise it's just an lm formula#
        lhs <- as.character(formula)[2]#
        chunks <- strsplit(labels, "\\|")[[1]]#
        formula <- as.formula(paste(lhs, "~", chunks[1]), env=attr(formula, '.Environment'))#
        ## Keep this for weight calculations#
        oldformula <- formula#
        for (chunk in chunks[-1]) {#
            print(chunk)#
            ## Keep these around#
            olddata <- data#
#
            ## Make the new formula#
            formula <- combine.formulae(formula, chunk)#
            print("vv")#
            if (!("constant" %in% names(data)) && "constant" %in% get.formula.terms(formula))#
                data$constant <- 1#
#
            print("xx")#
#
            terms <- get.hyper.terms(chunk)#
            if (length(terms) == 3) {#
                print("ab")#
                ## Build the new relationship#
                weight <- calc.fo.weights(oldformula, terms[1], ratios[ratio.ii], datas[[data.ii]]) # use original data#
                print("ao")#
                print(terms)#
                extras <- make.hyper.rows(terms[1], terms[2], weight, datas[[data.ii]])#
#
                ## Done with this ratio#
                ratio.ii <- ratio.ii + 1#
#
                ## Create indicators for nonhyper, if not already done#
                if (terms[1] %in% data)#
                    data <- replace.factor(terms[1], data, 1, sep=sep)#
#
                data <- combine.data.frames(data, extras)#
            } else {#
                ## Add in the next formula#
                data.ii <- data.ii + 1#
                data <- combine.data.frame(data, datas[[data.ii]])#
            }#
#
            ## Have any of the terms in the formula been factorized?#
            checks <- get.formula.terms(formula)#
            for (check in checks) {#
                if (check %in% names(olddata) && !is.character(olddata[, check]))#
                    formula <- replace.factor.formula(check, formula, olddata)#
            }#
        }#
    }#
#
    print(head(data))#
    print(tail(data))#
    print(formula)#
    lm(formula, data=data)#
}
hierlm(Sepal.Length ~ 0 + Petal.Length + Species + Sepal.Width : Species | Species - . | Sepal.Width : Species - ., iris, c(1, 2))
#' Fit an hierarchical model#
#'#
#' Interpret a hierarchical formula and fit it with the given data and weight ratios.#
#'#
#' @param formula an hierlm-style formula#
#' @param datas a data frame or a list of data frames, for each lm-style formula contained in the hierlm#
#' @param ratios a vector a ratios for the effect of fictional#
#'   observations, with length as large as the number of hyper#
#'   expressions.#
#' @return A fitted lm model#
#' @examples#
#' hierlm(Sepal.Length ~ 0 + Petal.Length + Species + Sepal.Width : Species | Species - ., iris, 1)#
#' hierlm(Sepal.Length ~ 0 + Petal.Length + Species + Sepal.Width : Species | Species - . | Sepal.Width : Species - ., iris, c(1, 2))#
#
hierlm <- function(formula, datas, ratios, sep="") {#
    if (is.data.frame(datas))#
        datas <- list(datas)#
#
    data.ii <- 1#
    ratio.ii <- 1#
#
    data <- datas[[data.ii]]#
#
    ## Split the formula by |#
    labels <- attr(terms(formula), 'term.labels')#
    if (length(labels) == 1) { # otherwise it's just an lm formula#
        lhs <- as.character(formula)[2]#
        chunks <- strsplit(labels, "\\|")[[1]]#
        formula <- as.formula(paste(lhs, "~", chunks[1]), env=attr(formula, '.Environment'))#
        ## Keep this for weight calculations#
        oldformula <- formula#
        for (chunk in chunks[-1]) {#
            print(chunk)#
            ## Keep these around#
            olddata <- data#
#
            ## Make the new formula#
            formula <- combine.formulae(formula, chunk)#
            print("vv")#
            if (!("constant" %in% names(data)) && "constant" %in% get.formula.terms(formula))#
                data$constant <- 1#
#
            print("xx")#
#
            terms <- get.hyper.terms(chunk)#
            if (length(terms) == 3) {#
                print("ab")#
                ## Build the new relationship#
                weight <- calc.fo.weights(oldformula, terms[1], ratios[ratio.ii], datas[[data.ii]]) # use original data#
                print("ao")#
                print(terms)#
                extras <- make.hyper.rows(terms[1], terms[2], weight, datas[[data.ii]])#
#
                ## Done with this ratio#
                ratio.ii <- ratio.ii + 1#
#
                ## Create indicators for nonhyper, if not already done#
                if (terms[1] %in% data)#
                    data <- replace.factor(terms[1], data, 1, sep=sep)#
#
                data <- combine.data.frames(data, extras)#
            } else {#
                ## Add in the next formula#
                data.ii <- data.ii + 1#
                data <- combine.data.frame(data, datas[[data.ii]])#
            }#
#
            ## Have any of the terms in the formula been factorized?#
            checks <- get.formula.terms(formula)#
            for (check in checks) {#
                if (check %in% names(olddata) && !is.numeric(olddata[, check]))#
                    formula <- replace.factor.formula(check, formula, olddata)#
            }#
        }#
    }#
#
    print(head(data))#
    print(tail(data))#
    print(formula)#
    lm(formula, data=data)#
}
hierlm(Sepal.Length ~ 0 + Petal.Length + Species + Sepal.Width : Species | Species - . | Sepal.Width : Species - ., iris, c(1, 2))
#' Fit an hierarchical model#
#'#
#' Interpret a hierarchical formula and fit it with the given data and weight ratios.#
#'#
#' @param formula an hierlm-style formula#
#' @param datas a data frame or a list of data frames, for each lm-style formula contained in the hierlm#
#' @param ratios a vector a ratios for the effect of fictional#
#'   observations, with length as large as the number of hyper#
#'   expressions.#
#' @return A fitted lm model#
#' @examples#
#' hierlm(Sepal.Length ~ 0 + Petal.Length + Species + Sepal.Width : Species | Species - ., iris, 1)#
#' hierlm(Sepal.Length ~ 0 + Petal.Length + Species + Sepal.Width : Species | Species - . | Sepal.Width : Species - ., iris, c(1, 2))#
#
hierlm <- function(formula, datas, ratios, sep="") {#
    if (is.data.frame(datas))#
        datas <- list(datas)#
#
    data.ii <- 1#
    ratio.ii <- 1#
#
    data <- datas[[data.ii]]#
#
    ## Split the formula by |#
    labels <- attr(terms(formula), 'term.labels')#
    if (length(labels) == 1) { # otherwise it's just an lm formula#
        lhs <- as.character(formula)[2]#
        chunks <- strsplit(labels, "\\|")[[1]]#
        formula <- as.formula(paste(lhs, "~", chunks[1]), env=attr(formula, '.Environment'))#
        ## Keep this for weight calculations#
        oldformula <- formula#
        for (chunk in chunks[-1]) {#
            print(chunk)#
            ## Keep these around#
            olddata <- data#
#
            ## Make the new formula#
            formula <- combine.formulae(formula, chunk)#
            print("vv")#
            if (!("constant" %in% names(data)) && "constant" %in% get.formula.terms(formula))#
                data$constant <- 1#
#
            print("xx")#
#
            terms <- get.hyper.terms(chunk)#
            if (length(terms) == 3) {#
                print("ab")#
                ## Build the new relationship#
                weight <- calc.fo.weights(oldformula, terms[1], ratios[ratio.ii], datas[[data.ii]]) # use original data#
                print("ao")#
                print(terms)#
                extras <- make.hyper.rows(terms[1], terms[2], weight, datas[[data.ii]])#
#
                ## Done with this ratio#
                ratio.ii <- ratio.ii + 1#
#
                ## Create indicators for nonhyper, if not already done#
                if (terms[1] %in% data)#
                    data <- replace.factor(terms[1], data, 1, sep=sep)#
#
                data <- combine.data.frames(data, extras)#
            } else {#
                ## Add in the next formula#
                data.ii <- data.ii + 1#
                data <- combine.data.frame(data, datas[[data.ii]])#
            }#
#
            ## Have any of the terms in the formula been factorized?#
            checks <- get.formula.terms(formula)#
            for (check in checks) {#
                if (grepl(':', check)) {#
                    for (subterm in split.interaction.term(check))#
                        if (subterm %in% names(oldata) && !(subterm %in% names(data)) && !is.numeric(olddata[, check]))#
                            formula <- replace.factor.formula(subterm, formula, olddata)#
                } else {#
                    if (check %in% names(olddata) && !(check %in% names(data)) && !is.numeric(olddata[, check]))#
                        formula <- replace.factor.formula(check, formula, olddata)#
                }#
            }#
        }#
    }#
#
    print(head(data))#
    print(tail(data))#
    print(formula)#
    lm(formula, data=data)#
}
hierlm(Sepal.Length ~ 0 + Petal.Length + Species + Sepal.Width : Species | Species - . | Sepal.Width : Species - ., iris, c(1, 2))
#' Fit an hierarchical model#
#'#
#' Interpret a hierarchical formula and fit it with the given data and weight ratios.#
#'#
#' @param formula an hierlm-style formula#
#' @param datas a data frame or a list of data frames, for each lm-style formula contained in the hierlm#
#' @param ratios a vector a ratios for the effect of fictional#
#'   observations, with length as large as the number of hyper#
#'   expressions.#
#' @return A fitted lm model#
#' @examples#
#' hierlm(Sepal.Length ~ 0 + Petal.Length + Species + Sepal.Width : Species | Species - ., iris, 1)#
#' hierlm(Sepal.Length ~ 0 + Petal.Length + Species + Sepal.Width : Species | Species - . | Sepal.Width : Species - ., iris, c(1, 2))#
#
hierlm <- function(formula, datas, ratios, sep="") {#
    if (is.data.frame(datas))#
        datas <- list(datas)#
#
    data.ii <- 1#
    ratio.ii <- 1#
#
    data <- datas[[data.ii]]#
#
    ## Split the formula by |#
    labels <- attr(terms(formula), 'term.labels')#
    if (length(labels) == 1) { # otherwise it's just an lm formula#
        lhs <- as.character(formula)[2]#
        chunks <- strsplit(labels, "\\|")[[1]]#
        formula <- as.formula(paste(lhs, "~", chunks[1]), env=attr(formula, '.Environment'))#
        ## Keep this for weight calculations#
        oldformula <- formula#
        for (chunk in chunks[-1]) {#
            print(chunk)#
            ## Keep these around#
            olddata <- data#
#
            ## Make the new formula#
            formula <- combine.formulae(formula, chunk)#
            print("vv")#
            if (!("constant" %in% names(data)) && "constant" %in% get.formula.terms(formula))#
                data$constant <- 1#
#
            print("xx")#
#
            terms <- get.hyper.terms(chunk)#
            if (length(terms) == 3) {#
                print("ab")#
                ## Build the new relationship#
                weight <- calc.fo.weights(oldformula, terms[1], ratios[ratio.ii], datas[[data.ii]]) # use original data#
                print("ao")#
                print(terms)#
                extras <- make.hyper.rows(terms[1], terms[2], weight, datas[[data.ii]])#
#
                ## Done with this ratio#
                ratio.ii <- ratio.ii + 1#
#
                ## Create indicators for nonhyper, if not already done#
                if (terms[1] %in% data)#
                    data <- replace.factor(terms[1], data, 1, sep=sep)#
#
                data <- combine.data.frames(data, extras)#
            } else {#
                ## Add in the next formula#
                data.ii <- data.ii + 1#
                data <- combine.data.frame(data, datas[[data.ii]])#
            }#
#
            ## Have any of the terms in the formula been factorized?#
            checks <- get.formula.terms(formula)#
            for (check in checks) {#
                if (grepl(':', check)) {#
                    for (subterm in split.interaction.term(check))#
                        if (subterm %in% names(olddata) && !(subterm %in% names(data)) && !is.numeric(olddata[, check]))#
                            formula <- replace.factor.formula(subterm, formula, olddata)#
                } else {#
                    if (check %in% names(olddata) && !(check %in% names(data)) && !is.numeric(olddata[, check]))#
                        formula <- replace.factor.formula(check, formula, olddata)#
                }#
            }#
        }#
    }#
#
    print(head(data))#
    print(tail(data))#
    print(formula)#
    lm(formula, data=data)#
}
hierlm(Sepal.Length ~ 0 + Petal.Length + Species + Sepal.Width : Species | Species - . | Sepal.Width : Species - ., iris, c(1, 2))
#' Fit an hierarchical model#
#'#
#' Interpret a hierarchical formula and fit it with the given data and weight ratios.#
#'#
#' @param formula an hierlm-style formula#
#' @param datas a data frame or a list of data frames, for each lm-style formula contained in the hierlm#
#' @param ratios a vector a ratios for the effect of fictional#
#'   observations, with length as large as the number of hyper#
#'   expressions.#
#' @return A fitted lm model#
#' @examples#
#' hierlm(Sepal.Length ~ 0 + Petal.Length + Species + Sepal.Width : Species | Species - ., iris, 1)#
#' hierlm(Sepal.Length ~ 0 + Petal.Length + Species + Sepal.Width : Species | Species - . | Sepal.Width : Species - ., iris, c(1, 2))#
#
hierlm <- function(formula, datas, ratios, sep="") {#
    if (is.data.frame(datas))#
        datas <- list(datas)#
#
    data.ii <- 1#
    ratio.ii <- 1#
#
    data <- datas[[data.ii]]#
#
    ## Split the formula by |#
    labels <- attr(terms(formula), 'term.labels')#
    if (length(labels) == 1) { # otherwise it's just an lm formula#
        lhs <- as.character(formula)[2]#
        chunks <- strsplit(labels, "\\|")[[1]]#
        formula <- as.formula(paste(lhs, "~", chunks[1]), env=attr(formula, '.Environment'))#
        ## Keep this for weight calculations#
        oldformula <- formula#
        for (chunk in chunks[-1]) {#
            print(chunk)#
            ## Keep these around#
            olddata <- data#
#
            ## Make the new formula#
            formula <- combine.formulae(formula, chunk)#
            print("vv")#
            if (!("constant" %in% names(data)) && "constant" %in% get.formula.terms(formula))#
                data$constant <- 1#
#
            print("xx")#
#
            terms <- get.hyper.terms(chunk)#
            if (length(terms) == 3) {#
                print("ab")#
                ## Build the new relationship#
                weight <- calc.fo.weights(oldformula, terms[1], ratios[ratio.ii], datas[[data.ii]]) # use original data#
                print("ao")#
                print(terms)#
                extras <- make.hyper.rows(terms[1], terms[2], weight, datas[[data.ii]])#
#
                ## Done with this ratio#
                ratio.ii <- ratio.ii + 1#
#
                ## Create indicators for nonhyper, if not already done#
                if (terms[1] %in% data)#
                    data <- replace.factor(terms[1], data, 1, sep=sep)#
#
                data <- combine.data.frames(data, extras)#
            } else {#
                ## Add in the next formula#
                data.ii <- data.ii + 1#
                data <- combine.data.frame(data, datas[[data.ii]])#
            }#
#
            ## Have any of the terms in the formula been factorized?#
            checks <- get.formula.terms(formula)#
            for (check in checks) {#
                if (grepl(':', check)) {#
                    for (subterm in split.interaction.term(check))#
                        if (subterm %in% names(olddata) && !(subterm %in% names(data)) && !is.numeric(olddata[, subterm]))#
                            formula <- replace.factor.formula(subterm, formula, olddata)#
                } else {#
                    if (check %in% names(olddata) && !(check %in% names(data)) && !is.numeric(olddata[, check]))#
                        formula <- replace.factor.formula(check, formula, olddata)#
                }#
            }#
        }#
    }#
#
    print(head(data))#
    print(tail(data))#
    print(formula)#
    lm(formula, data=data)#
}
hierlm(Sepal.Length ~ 0 + Petal.Length + Species + Sepal.Width : Species | Species - . | Sepal.Width : Species - ., iris, c(1, 2))
#' Fit an hierarchical model#
#'#
#' Interpret a hierarchical formula and fit it with the given data and weight ratios.#
#'#
#' @param formula an hierlm-style formula#
#' @param datas a data frame or a list of data frames, for each lm-style formula contained in the hierlm#
#' @param ratios a vector a ratios for the effect of fictional#
#'   observations, with length as large as the number of hyper#
#'   expressions.#
#' @return A fitted lm model#
#' @examples#
#' hierlm(Sepal.Length ~ 0 + Petal.Length + Species + Sepal.Width : Species | Species - ., iris, 1)#
#' hierlm(Sepal.Length ~ 0 + Petal.Length + Species + Sepal.Width : Species | Species - . | Sepal.Width : Species - ., iris, c(1, 2))#
#
hierlm <- function(formula, datas, ratios, sep="") {#
    if (is.data.frame(datas))#
        datas <- list(datas)#
#
    data.ii <- 1#
    ratio.ii <- 1#
#
    data <- datas[[data.ii]]#
#
    ## Split the formula by |#
    labels <- attr(terms(formula), 'term.labels')#
    if (length(labels) == 1) { # otherwise it's just an lm formula#
        lhs <- as.character(formula)[2]#
        chunks <- strsplit(labels, "\\|")[[1]]#
        formula <- as.formula(paste(lhs, "~", chunks[1]), env=attr(formula, '.Environment'))#
        ## Keep this for weight calculations#
        oldformula <- formula#
        for (chunk in chunks[-1]) {#
            ## Keep these around#
            olddata <- data#
#
            ## Make the new formula#
            formula <- combine.formulae(formula, chunk)#
            if (!("constant" %in% names(data)) && "constant" %in% get.formula.terms(formula))#
                data$constant <- 1#
#
            terms <- get.hyper.terms(chunk)#
            if (length(terms) == 3) {#
                ## Build the new relationship#
                weight <- calc.fo.weights(oldformula, terms[1], ratios[ratio.ii], datas[[data.ii]]) # use original data#
                extras <- make.hyper.rows(terms[1], terms[2], weight, datas[[data.ii]])#
#
                ## Done with this ratio#
                ratio.ii <- ratio.ii + 1#
#
                ## Create indicators for nonhyper, if not already done#
                if (terms[1] %in% data)#
                    data <- replace.factor(terms[1], data, 1, sep=sep)#
#
                data <- combine.data.frames(data, extras)#
            } else {#
                ## Add in the next formula#
                data.ii <- data.ii + 1#
                data <- combine.data.frame(data, datas[[data.ii]])#
            }#
#
            ## Have any of the terms in the formula been factorized?#
            checks <- get.formula.terms(formula)#
            for (check in checks) {#
                if (grepl(':', check)) {#
                    for (subterm in split.interaction.term(check))#
                        if (subterm %in% names(olddata) && !(subterm %in% names(data)) && !is.numeric(olddata[, subterm])) {#
                            print(subterm)#
                            formula <- replace.factor.formula(subterm, formula, olddata)#
                            print(formula)#
                        }#
                } else {#
                    if (check %in% names(olddata) && !(check %in% names(data)) && !is.numeric(olddata[, check]))#
                        formula <- replace.factor.formula(check, formula, olddata)#
                }#
            }#
        }#
    }#
#
    print(head(data))#
    print(tail(data))#
    print(formula)#
    lm(formula, data=data)#
}
hierlm(Sepal.Length ~ 0 + Petal.Length + Species + Sepal.Width : Species | Species - . | Sepal.Width : Species - ., iris, c(1, 2))
#' Fit an hierarchical model#
#'#
#' Interpret a hierarchical formula and fit it with the given data and weight ratios.#
#'#
#' @param formula an hierlm-style formula#
#' @param datas a data frame or a list of data frames, for each lm-style formula contained in the hierlm#
#' @param ratios a vector a ratios for the effect of fictional#
#'   observations, with length as large as the number of hyper#
#'   expressions.#
#' @return A fitted lm model#
#' @examples#
#' hierlm(Sepal.Length ~ 0 + Petal.Length + Species + Sepal.Width : Species | Species - ., iris, 1)#
#' hierlm(Sepal.Length ~ 0 + Petal.Length + Species + Sepal.Width : Species | Species - . | Sepal.Width : Species - ., iris, c(1, 2))#
#
hierlm <- function(formula, datas, ratios, sep="") {#
    if (is.data.frame(datas))#
        datas <- list(datas)#
#
    data.ii <- 1#
    ratio.ii <- 1#
#
    data <- datas[[data.ii]]#
#
    ## Split the formula by |#
    labels <- attr(terms(formula), 'term.labels')#
    if (length(labels) == 1) { # otherwise it's just an lm formula#
        lhs <- as.character(formula)[2]#
        chunks <- strsplit(labels, "\\|")[[1]]#
        formula <- as.formula(paste(lhs, "~", chunks[1]), env=attr(formula, '.Environment'))#
        ## Keep this for weight calculations#
        oldformula <- formula#
        for (chunk in chunks[-1]) {#
            ## Keep these around#
            olddata <- data#
#
            ## Make the new formula#
            formula <- combine.formulae(formula, chunk)#
            if (!("constant" %in% names(data)) && "constant" %in% get.formula.terms(formula))#
                data$constant <- 1#
#
            terms <- get.hyper.terms(chunk)#
            if (length(terms) == 3) {#
                ## Build the new relationship#
                weight <- calc.fo.weights(oldformula, terms[1], ratios[ratio.ii], datas[[data.ii]]) # use original data#
                extras <- make.hyper.rows(terms[1], terms[2], weight, datas[[data.ii]])#
#
                ## Done with this ratio#
                ratio.ii <- ratio.ii + 1#
#
                ## Create indicators for nonhyper, if not already done#
                if (terms[1] %in% data)#
                    data <- replace.factor(terms[1], data, 1, sep=sep)#
#
                data <- combine.data.frames(data, extras)#
            } else {#
                ## Add in the next formula#
                data.ii <- data.ii + 1#
                data <- combine.data.frame(data, datas[[data.ii]])#
            }#
#
            ## Have any of the terms in the formula been factorized?#
            print("checking")#
            checks <- get.formula.terms(formula)#
            for (check in checks) {#
                if (grepl(':', check)) {#
                    for (subterm in split.interaction.term(check))#
                        if (subterm %in% names(olddata) && !(subterm %in% names(data)) && !is.numeric(olddata[, subterm])) {#
                            print(subterm)#
                            formula <- replace.factor.formula(subterm, formula, olddata)#
                            print(formula)#
                        }#
                } else {#
                    if (check %in% names(olddata) && !(check %in% names(data)) && !is.numeric(olddata[, check]))#
                        formula <- replace.factor.formula(check, formula, olddata)#
                }#
            }#
        }#
    }#
#
    print(head(data))#
    print(tail(data))#
    print(formula)#
    lm(formula, data=data)#
}
hierlm(Sepal.Length ~ 0 + Petal.Length + Species + Sepal.Width : Species | Species - . | Sepal.Width : Species - ., iris, c(1, 2))
#' Fit an hierarchical model#
#'#
#' Interpret a hierarchical formula and fit it with the given data and weight ratios.#
#'#
#' @param formula an hierlm-style formula#
#' @param datas a data frame or a list of data frames, for each lm-style formula contained in the hierlm#
#' @param ratios a vector a ratios for the effect of fictional#
#'   observations, with length as large as the number of hyper#
#'   expressions.#
#' @return A fitted lm model#
#' @examples#
#' hierlm(Sepal.Length ~ 0 + Petal.Length + Species + Sepal.Width : Species | Species - ., iris, 1)#
#' hierlm(Sepal.Length ~ 0 + Petal.Length + Species + Sepal.Width : Species | Species - . | Sepal.Width : Species - ., iris, c(1, 2))#
#
hierlm <- function(formula, datas, ratios, sep="") {#
    if (is.data.frame(datas))#
        datas <- list(datas)#
#
    data.ii <- 1#
    ratio.ii <- 1#
#
    data <- datas[[data.ii]]#
#
    ## Split the formula by |#
    labels <- attr(terms(formula), 'term.labels')#
    if (length(labels) == 1) { # otherwise it's just an lm formula#
        lhs <- as.character(formula)[2]#
        chunks <- strsplit(labels, "\\|")[[1]]#
        formula <- as.formula(paste(lhs, "~", chunks[1]), env=attr(formula, '.Environment'))#
        ## Keep this for weight calculations#
        oldformula <- formula#
        for (chunk in chunks[-1]) {#
            ## Make the new formula#
            formula <- combine.formulae(formula, chunk)#
            if (!("constant" %in% names(data)) && "constant" %in% get.formula.terms(formula))#
                data$constant <- 1#
#
            terms <- get.hyper.terms(chunk)#
            if (length(terms) == 3) {#
                ## Build the new relationship#
                weight <- calc.fo.weights(oldformula, terms[1], ratios[ratio.ii], datas[[data.ii]]) # use original data#
                extras <- make.hyper.rows(terms[1], terms[2], weight, datas[[data.ii]])#
#
                ## Done with this ratio#
                ratio.ii <- ratio.ii + 1#
#
                ## Create indicators for nonhyper, if not already done#
                if (terms[1] %in% data)#
                    data <- replace.factor(terms[1], data, 1, sep=sep)#
#
                data <- combine.data.frames(data, extras)#
            } else {#
                ## Add in the next formula#
                data.ii <- data.ii + 1#
                data <- combine.data.frame(data, datas[[data.ii]])#
            }#
#
            ## Have any of the terms in the formula been factorized?#
            print("checking")#
            checks <- get.formula.terms(formula)#
            for (check in checks) {#
                if (grepl(':', check)) {#
                    for (subterm in split.interaction.term(check))#
                        if (subterm %in% names(datas[[data.ii]]) && !(subterm %in% names(data)) && !is.numeric(datas[[data.ii]][, subterm])) {#
                            print(subterm)#
                            formula <- replace.factor.formula(subterm, formula, datas[[data.ii]])#
                            print(formula)#
                        }#
                } else {#
                    if (check %in% names(datas[[data.ii]]) && !(check %in% names(data)) && !is.numeric(datas[[data.ii]][, check]))#
                        formula <- replace.factor.formula(check, formula, datas[[data.ii]])#
                }#
            }#
        }#
    }#
#
    print(head(data))#
    print(tail(data))#
    print(formula)#
    lm(formula, data=data)#
}
hierlm(Sepal.Length ~ 0 + Petal.Length + Species + Sepal.Width : Species | Species - . | Sepal.Width : Species - ., iris, c(1, 2))
#' Fit an hierarchical model#
#'#
#' Interpret a hierarchical formula and fit it with the given data and weight ratios.#
#'#
#' @param formula an hierlm-style formula#
#' @param datas a data frame or a list of data frames, for each lm-style formula contained in the hierlm#
#' @param ratios a vector a ratios for the effect of fictional#
#'   observations, with length as large as the number of hyper#
#'   expressions.#
#' @return A fitted lm model#
#' @examples#
#' hierlm(Sepal.Length ~ 0 + Petal.Length + Species + Sepal.Width : Species | Species - ., iris, 1)#
#' hierlm(Sepal.Length ~ 0 + Petal.Length + Species + Sepal.Width : Species | Species - . | Sepal.Width : Species - ., iris, c(1, 2))#
#
hierlm <- function(formula, datas, ratios, sep="") {#
    if (is.data.frame(datas))#
        datas <- list(datas)#
#
    data.ii <- 1#
    ratio.ii <- 1#
#
    data <- datas[[data.ii]]#
#
    ## Split the formula by |#
    labels <- attr(terms(formula), 'term.labels')#
    if (length(labels) == 1) { # otherwise it's just an lm formula#
        lhs <- as.character(formula)[2]#
        chunks <- strsplit(labels, "\\|")[[1]]#
        formula <- as.formula(paste(lhs, "~", chunks[1]), env=attr(formula, '.Environment'))#
        ## Keep this for weight calculations#
        oldformula <- formula#
        for (chunk in chunks[-1]) {#
            ## Make the new formula#
            formula <- combine.formulae(formula, chunk)#
            if (!("constant" %in% names(data)) && "constant" %in% get.formula.terms(formula))#
                data$constant <- 1#
#
            terms <- get.hyper.terms(chunk)#
            if (length(terms) == 3) {#
                ## Build the new relationship#
                weight <- calc.fo.weights(oldformula, terms[1], ratios[ratio.ii], datas[[data.ii]]) # use original data#
                print(weight)#
                extras <- make.hyper.rows(terms[1], terms[2], weight, datas[[data.ii]])#
#
                ## Done with this ratio#
                ratio.ii <- ratio.ii + 1#
#
                ## Create indicators for nonhyper, if not already done#
                if (terms[1] %in% data)#
                    data <- replace.factor(terms[1], data, 1, sep=sep)#
#
                data <- combine.data.frames(data, extras)#
            } else {#
                ## Add in the next formula#
                data.ii <- data.ii + 1#
                data <- combine.data.frame(data, datas[[data.ii]])#
            }#
#
            ## Have any of the terms in the formula been factorized?#
            checks <- get.formula.terms(formula)#
            for (check in checks) {#
                if (grepl(':', check)) {#
                    for (subterm in split.interaction.term(check))#
                        if (subterm %in% names(datas[[data.ii]]) && !(subterm %in% names(data)) && !is.numeric(datas[[data.ii]][, subterm]))#
                            formula <- replace.factor.formula(subterm, formula, datas[[data.ii]])#
                } else {#
                    if (check %in% names(datas[[data.ii]]) && !(check %in% names(data)) && !is.numeric(datas[[data.ii]][, check]))#
                        formula <- replace.factor.formula(check, formula, datas[[data.ii]])#
                }#
            }#
        }#
    }#
#
    print(head(data))#
    print(tail(data))#
    print(formula)#
    lm(formula, data=data)#
}
hierlm(Sepal.Length ~ 0 + Petal.Length + Species + Sepal.Width : Species | Species - . | Sepal.Width : Species - ., iris, c(1, 2))
#' Fit an hierarchical model#
#'#
#' Interpret a hierarchical formula and fit it with the given data and weight ratios.#
#'#
#' @param formula an hierlm-style formula#
#' @param datas a data frame or a list of data frames, for each lm-style formula contained in the hierlm#
#' @param ratios a vector a ratios for the effect of fictional#
#'   observations, with length as large as the number of hyper#
#'   expressions.#
#' @return A fitted lm model#
#' @examples#
#' hierlm(Sepal.Length ~ 0 + Petal.Length + Species + Sepal.Width : Species | Species - ., iris, 1)#
#' hierlm(Sepal.Length ~ 0 + Petal.Length + Species + Sepal.Width : Species | Species - . | Sepal.Width : Species - ., iris, c(1, 2))#
#
hierlm <- function(formula, datas, ratios, sep="") {#
    if (is.data.frame(datas))#
        datas <- list(datas)#
#
    data.ii <- 1#
    ratio.ii <- 1#
#
    data <- datas[[data.ii]]#
#
    ## Split the formula by |#
    labels <- attr(terms(formula), 'term.labels')#
    if (length(labels) == 1) { # otherwise it's just an lm formula#
        lhs <- as.character(formula)[2]#
        chunks <- strsplit(labels, "\\|")[[1]]#
        formula <- as.formula(paste(lhs, "~", chunks[1]), env=attr(formula, '.Environment'))#
        ## Keep this for weight calculations#
        oldformula <- formula#
        for (chunk in chunks[-1]) {#
            ## Make the new formula#
            formula <- combine.formulae(formula, chunk)#
            if (!("constant" %in% names(data)) && "constant" %in% get.formula.terms(formula))#
                data$constant <- 1#
#
            terms <- get.hyper.terms(chunk)#
            if (length(terms) == 3) {#
                ## Build the new relationship#
                print(oldformula)#
                print(c(terms[1], ratios[ratio.ii]))#
                weight <- calc.fo.weights(oldformula, terms[1], ratios[ratio.ii], datas[[data.ii]]) # use original data#
                print(weight)#
                extras <- make.hyper.rows(terms[1], terms[2], weight, datas[[data.ii]])#
#
                ## Done with this ratio#
                ratio.ii <- ratio.ii + 1#
#
                ## Create indicators for nonhyper, if not already done#
                if (terms[1] %in% data)#
                    data <- replace.factor(terms[1], data, 1, sep=sep)#
#
                data <- combine.data.frames(data, extras)#
            } else {#
                ## Add in the next formula#
                data.ii <- data.ii + 1#
                data <- combine.data.frame(data, datas[[data.ii]])#
            }#
#
            ## Have any of the terms in the formula been factorized?#
            checks <- get.formula.terms(formula)#
            for (check in checks) {#
                if (grepl(':', check)) {#
                    for (subterm in split.interaction.term(check))#
                        if (subterm %in% names(datas[[data.ii]]) && !(subterm %in% names(data)) && !is.numeric(datas[[data.ii]][, subterm]))#
                            formula <- replace.factor.formula(subterm, formula, datas[[data.ii]])#
                } else {#
                    if (check %in% names(datas[[data.ii]]) && !(check %in% names(data)) && !is.numeric(datas[[data.ii]][, check]))#
                        formula <- replace.factor.formula(check, formula, datas[[data.ii]])#
                }#
            }#
        }#
    }#
#
    print(head(data))#
    print(tail(data))#
    print(formula)#
    lm(formula, data=data)#
}
hierlm(Sepal.Length ~ 0 + Petal.Length + Species + Sepal.Width : Species | Species - . | Sepal.Width : Species - ., iris, c(1, 2))
lm(Sepal.Length ~ 0 + Petal.Length + Species + Sepal.Width:Species, iris)
#' Calculate Fictional Observation Weights#
#'#
#' Determines the coeffiicients for terms in the fictional observations,#
#' to ensure a given weight relative to the normal observations.#
#'#
#' @param formula lm-style formula#
#' @param label the term to be used in fictional observations#
#' @param ratio desired ratio of observed and fictional data#
#' @param data optional data frame#
#' @return Coefficients for fictional observations#
#' @examples#
#' calc.fo.weights(Sepal.Length ~ Petal.Length + Sepal.Width : Species, "Sepal.Width:Species", 5, data=iris)#
#
calc.fo.weights <- function(formula, label, ratio, data) {#
    mod.lm <- lm(formula, data)#
    sumerr <- sum(mod.lm$residuals^2)#
#
    ## Collect the beta values for all of these#
    dummies <- substr(names(mod.lm$coefficients), 1, nchar(label)) == label#
    if (sum(dummies) == 0 && grepl(':', label)) {#
        ## Try flipping an interaction#
        subterms = split.interaction.term(label)#
        dummies <- grep(paste(subterms[2], ".*", subterms[1], sep=""), names(mod.lm$coefficients))#
    }#
    betas <- mod.lm$coefficients[dummies]#
#
    sumerr / (ratio * sum(dummies) * var(betas))#
}
hierlm(Sepal.Length ~ 0 + Petal.Length + Species + Sepal.Width : Species | Species - . | Sepal.Width : Species - ., iris, c(1, 2))
summary(hierlm(Sepal.Length ~ 0 + Petal.Length + Species + Sepal.Width : Species | Species - . | Sepal.Width : Species - ., iris, c(1, 2)))
summary(hierlm(Sepal.Length ~ 0 + Petal.Length + Species + Sepal.Width : Species | Species - ., iris, c(1, 2)))
hierlm(Sepal.Length ~ 0 + Petal.Length + Species + Sepal.Width : Species | Sepal.Width : Species - ., iris, 2)
summary(hierlm(Sepal.Length ~ 0 + Petal.Length + Species + Sepal.Width : Species | Sepal.Width : Species - ., iris, 2))
100 * exp((2 * 1:50 - 1) / 10) / exp(10)
2 * 1:50 - 1
setwd("~/projects/coffee/global")#
#
source("load-dailies.R")#
source("~/projects/research-common/R/gdd.R")#
#
outfile <- "globalobs-summin.RData" #"globalobs-future-summin.RData"
gdd.low <- 0#
gdd.high <- 33#
#
get.dailies <- function(variable, variety, PID, date.end) {#
    year <- as.numeric(format(date.end, "%Y"))#
    ## Stary by getting previous year#
    mydata1 <- get.data(variable, variety, year-1, PID)#
    if (nrow(mydata1) == 0)#
        return(F)#
#
    if (format(date.end, "%m%d") == "0101") {#
        return(mydata1$averages)#
    } else {#
        mydata2 <- get.data(variable, variety, year, PID)#
        if (nrow(mydata2) == 0)#
            return(F)#
#
        days2 <- as.numeric(date.end - as.Date(paste0(year, "-01-01")))#
        vals2 <- mydata2$averages[1:days2]#
        vals1 <- mydata1$averages[days2:365]#
        return(c(vals1, vals2))#
    }#
}#
#
## Combine arabica and robusta where I wouldn't have a yield otherwise#
records$best.areas <- records$planted#
records$best.areas[is.na(records$best.areas)] <- records$harvested[is.na(records$best.areas)]#
#
records$best.yield <- records$yield#
records$best.yield[is.na(records$best.yield)] <- records$produced[is.na(records$best.yield)] / records$best.areas[is.na(records$best.yield)]#
#
for (ii in which(records$variety == "combined" & is.na(records$best.yield) & !is.na(records$best.areas))) {#
    print(ii / nrow(records))#
    ## Try to match this up#
    splitout <- subset(records, date.start == records$date.start[ii] &#
                           date.end == records$date.end[ii] &#
                               region == records$region[ii] &#
                                   variety != "combined")#
    if (sum(!is.na(splitout$best.yield)) == 0) {#
        ## We aren't using these for anything else!#
        records$best.yield[ii] <- sum(splitout$produced) / records$best.areas[ii]#
    }#
}#
#
data <- data.frame(region=c(), variety=c(), year=c(), produced=c(), yield=c(), PID=c(), frosts=c(), gdds=c(), kdds=c(), summin=c(), precip=c())#
#
for (ii in 1:nrow(records)) {#
    if (is.na(records$best.yield[ii]))#
        next#
#
    region <- as.character(records$region[ii])#
    variety <- as.character(records$variety[ii])#
#
    PID <- get.PID(region)#
    if (length(PID) == 0) {#
        print(paste("Cannot find region", region))#
        next#
    }#
#
    print(c(ii / nrow(records), region, variety))#
#
    tmins <- get.dailies("tmin", variety, PID, records$date.end[ii])#
    if (class(tmins) == "logical")#
        next#
    tmaxs <- get.dailies("tmax", variety, PID, records$date.end[ii])#
    prates <- get.dailies("prate", variety, PID, records$date.end[ii])#
#
    ## Count GDDs in previous 12 months#
    gddkdd <- get.gddkdd(tmins, tmaxs, gdd.low, gdd.high)#
#
    ## Also count "frost points": cummulative degrees below 0#
    frosts <- -sum(tmins[tmins < min(0, gdd.low)])#
#
    summin <- sum(tmins)#
#
    precip <- sum(prates)#
#
    data <- rbind(data, data.frame(region, variety, year=as.numeric(format(records$date.end[ii], "%Y")), produced=records$produced[ii], yield=records$best.yield[ii], PID, frosts, gdds=gddkdd[1], kdds=gddkdd[2], summin, precip))#
}
outfile
save(data, file=outfile)
## Save in prepared form#
data2 <- data#
data2$gdds <- data2$gdds / 1000#
data2$kdds <- data2$kdds / 1000#
data2$summin <- data2$summin / 365.25#
names(data2) <- c("region", "variety", "year", "produced", "yield", "PID", "frosts", "gdd1000", "kdd1000", "avgmin", "precip")#
#
write.csv(data2, file="../tools/production/baseline.csv", row.names=F)
setwd("~/projects/coffee/tools/production")#
#
library(maps)#
source("~/projects/research-common/R/drawmap.R")#
#
changes <- read.csv("changes.csv")#
#
map("world", ylim=c(-30, 30))#
draw.map("world", changes$country, changes$change, position="bottomleft", add=T, digits=2)
setwd("~/projects/coffee/global")
load("globalobs-future-summin.RData")
data[1,]
sum(data$region == "Colombia")
get.PID
get.PID("Colombia")
setwd("~/projects/coffee/tools/climate")#
#
library(ncdf4)#
library(maps)#
library(RColorBrewer)#
#
mains <- c("Mean temperature", "Diurnal range", "Maximum temperature", "Minimum temperature", "Annual Precipitation", "Wettest month precipitation", "Driest month precipitation")#
fileprefixes <- c("bio-1", "bio-2", "bio-5", "bio-6", "bio-12", "bio-13", "bio-14")#
isprecips <- c(rep(F, 4), rep(T, 3))
ii = 5
fileprefix <- fileprefixes[ii]#
    database <- nc_open(paste0("outputs/", fileprefix, ".nc4"))#
    map <- ncvar_get(database, "change")#
    conf <- ncvar_get(database, "confidence")#
#
    conf[conf > 1] <- 1#
#
    longitude <- seq(-180 + .5 / 12, 180 - .5 / 12, by=1/12)#
    latitude <- seq(-30 + .5 / 12, 30 - .5 / 12, by=1/12)#
#
    library(mapdata)#
#
    absmap <- abs(map)#
    maxmap <- max(absmap[absmap < Inf], na.rm=T)#
#
    if (isprecips[ii]) {#
        maxmap <- .5 * maxmap#
        colors <- brewer.pal(11,"RdYlBu") #rev(brewer.pal(11,"RdYlBu")), for precip#
    } else {#
        colors <- rev(brewer.pal(11,"RdYlBu"))#
    }#
#
    breaks <- seq(-maxmap, maxmap, length.out=12)
map("worldHires", ylim=c(-30, 30), mar=rep(0,4))#
    image(longitude, latitude, map, col=colors, breaks=breaks, add=T)#
    image(longitude, latitude, conf, col=rgb(1, 1, 1, seq(1, 0, by=-.1)), add=T)#
    legend("bottomleft", legend=round((breaks[-1] + breaks[-12]) / 2, digits=2), fill=colors, cex=1.5)#
    text(-180, 27, mains[ii], pos=4, cex=2)
map[1,1,]
map[1,1
]
png(paste0("outputs/", fileprefix, ".png"), width=4320/2, height=400)#
    map("worldHires", ylim=c(-30, 30), mar=rep(0,4))#
    image(longitude, latitude, map, col=colors, breaks=breaks, add=T)#
    image(longitude, latitude, is.na(map), col="blue", add=T)#
    image(longitude, latitude, conf, col=rgb(1, 1, 1, seq(1, 0, by=-.1)), add=T)#
    legend("bottomleft", legend=round((breaks[-1] + breaks[-12]) / 2, digits=2), fill=colors, cex=1.5)#
    text(-180, 27, mains[ii], pos=4, cex=2)#
    dev.off()
dim(map)
map[1,]
map[,1]
dim(is.na(map))
map("worldHires", ylim=c(-30, 30), mar=rep(0,4), bg="blue")
png(paste0("outputs/", fileprefix, ".png"), width=4320/2, height=400)#
    map("worldHires", ylim=c(-30, 30), mar=rep(0,4), bg="blue")#
    image(longitude, latitude, map, col=colors, breaks=breaks, add=T)#
    #image(longitude, latitude, is.na(map), col="blue", add=T)#
    image(longitude, latitude, conf, col=rgb(1, 1, 1, seq(1, 0, by=-.1)), add=T)#
    legend("bottomleft", legend=round((breaks[-1] + breaks[-12]) / 2, digits=2), fill=colors, cex=1.5)#
    text(-180, 27, mains[ii], pos=4, cex=2)#
    dev.off()
png(paste0("outputs/", fileprefix, ".png"), width=4320/2, height=400)#
    map("worldHires", ylim=c(-30, 30), mar=rep(0,4), bg="#8080FF")#
    image(longitude, latitude, map, col=colors, breaks=breaks, add=T)#
    #image(longitude, latitude, is.na(map), col="blue", add=T)#
    image(longitude, latitude, conf, col=rgb(1, 1, 1, seq(1, 0, by=-.1)), add=T)#
    legend("bottomleft", legend=round((breaks[-1] + breaks[-12]) / 2, digits=2), fill=colors, cex=1.5)#
    text(-180, 27, mains[ii], pos=4, cex=2)#
    dev.off()
ii = 1
fileprefix <- fileprefixes[ii]#
    database <- nc_open(paste0("outputs/", fileprefix, ".nc4"))#
    map <- ncvar_get(database, "change")#
    conf <- ncvar_get(database, "confidence")#
#
    conf[conf > 1] <- 1#
#
    longitude <- seq(-180 + .5 / 12, 180 - .5 / 12, by=1/12)#
    latitude <- seq(-30 + .5 / 12, 30 - .5 / 12, by=1/12)#
#
    library(mapdata)#
#
    absmap <- abs(map)#
    maxmap <- max(absmap[absmap < Inf], na.rm=T)#
#
    if (isprecips[ii]) {#
        maxmap <- .5 * maxmap#
        colors <- brewer.pal(11,"RdYlBu") #rev(brewer.pal(11,"RdYlBu")), for precip#
    } else {#
        colors <- rev(brewer.pal(11,"RdYlBu"))#
    }#
#
    breaks <- seq(-maxmap, maxmap, length.out=12)#
#
    png(paste0("outputs/", fileprefix, ".png"), width=4320/2, height=400)#
    map("worldHires", ylim=c(-30, 30), mar=rep(0,4), bg="#8080FF")#
    image(longitude, latitude, map, col=colors, breaks=breaks, add=T)#
    #image(longitude, latitude, is.na(map), col="blue", add=T)#
    image(longitude, latitude, conf, col=rgb(1, 1, 1, seq(1, 0, by=-.1)), add=T)#
    legend("bottomleft", legend=round((breaks[-1] + breaks[-12]) / 2, digits=2), fill=colors, cex=1.5)#
    text(-180, 27, mains[ii], pos=4, cex=2)#
    dev.off()
ii = 3
fileprefix <- fileprefixes[ii]#
    database <- nc_open(paste0("outputs/", fileprefix, ".nc4"))#
    map <- ncvar_get(database, "change")#
    conf <- ncvar_get(database, "confidence")#
#
    conf[conf > 1] <- 1#
#
    longitude <- seq(-180 + .5 / 12, 180 - .5 / 12, by=1/12)#
    latitude <- seq(-30 + .5 / 12, 30 - .5 / 12, by=1/12)#
#
    library(mapdata)#
#
    absmap <- abs(map)#
    maxmap <- max(absmap[absmap < Inf], na.rm=T)#
#
    if (isprecips[ii]) {#
        maxmap <- .5 * maxmap#
        colors <- brewer.pal(11,"RdYlBu") #rev(brewer.pal(11,"RdYlBu")), for precip#
    } else {#
        colors <- rev(brewer.pal(11,"RdYlBu"))#
    }#
#
    breaks <- seq(-maxmap, maxmap, length.out=12)#
#
    png(paste0("outputs/", fileprefix, ".png"), width=4320/2, height=400)#
    map("worldHires", ylim=c(-30, 30), mar=rep(0,4), bg="#8080FF")#
    image(longitude, latitude, map, col=colors, breaks=breaks, add=T)#
    #image(longitude, latitude, is.na(map), col="blue", add=T)#
    image(longitude, latitude, conf, col=rgb(1, 1, 1, seq(1, 0, by=-.1)), add=T)#
    legend("bottomleft", legend=round((breaks[-1] + breaks[-12]) / 2, digits=2), fill=colors, cex=1.5)#
    text(-180, 27, mains[ii], pos=4, cex=2)#
    dev.off()
ii = 7
fileprefix <- fileprefixes[ii]#
    database <- nc_open(paste0("outputs/", fileprefix, ".nc4"))#
    map <- ncvar_get(database, "change")#
    conf <- ncvar_get(database, "confidence")#
#
    conf[conf > 1] <- 1#
#
    longitude <- seq(-180 + .5 / 12, 180 - .5 / 12, by=1/12)#
    latitude <- seq(-30 + .5 / 12, 30 - .5 / 12, by=1/12)#
#
    library(mapdata)#
#
    absmap <- abs(map)#
    maxmap <- max(absmap[absmap < Inf], na.rm=T)#
#
    if (isprecips[ii]) {#
        maxmap <- .5 * maxmap#
        colors <- brewer.pal(11,"RdYlBu") #rev(brewer.pal(11,"RdYlBu")), for precip#
    } else {#
        colors <- rev(brewer.pal(11,"RdYlBu"))#
    }#
#
    breaks <- seq(-maxmap, maxmap, length.out=12)#
#
    png(paste0("outputs/", fileprefix, ".png"), width=4320/2, height=400)#
    map("worldHires", ylim=c(-30, 30), mar=rep(0,4), bg="#8080FF")#
    image(longitude, latitude, map, col=colors, breaks=breaks, add=T)#
    #image(longitude, latitude, is.na(map), col="blue", add=T)#
    image(longitude, latitude, conf, col=rgb(1, 1, 1, seq(1, 0, by=-.1)), add=T)#
    legend("bottomleft", legend=round((breaks[-1] + breaks[-12]) / 2, digits=2), fill=colors, cex=1.5)#
    text(-180, 27, mains[ii], pos=4, cex=2)#
    dev.off()
