?matrix
names(diag(3))
names(diag(3)) = c(1, 2, 3)
#' Create fictional observations for a hyper relationship#
#'#
#' Return a data frame with fictional observations#
#'#
#' @param nonhyper name of the non-hyper column#
#' @param hyper name of the hyper column#
#' @param weight weight to be used in the rows#
#' @param data a data frame for inspecting levels#
#' @return Fictional observations in a data frame#
#' @examples#
#' make.hyper.noninteract("Species", "hyperSpecies", 5, iris)#
#
make.hyper.noninteract <- function(nonhyper, hyper, weight, data, sep="") {#
    ## Construct extra from diagonal factor matrix#
    extras <- diag(weight, length(unique(data[, nonhyper])))#
    extras <- as.data.frame(extras)#
#
    names(extras) <- paste(nonhyper, unique(data[, nonhyper]), sep=sep)#
#
    ## Add in the hyper column#
    extras[, hyper] <- -weight#
}
make.hyper.noninteract("Species", "hyperSpecies", 5, iris)
#' Create fictional observations for a hyper relationship#
#'#
#' Return a data frame with fictional observations#
#'#
#' @param nonhyper name of the non-hyper column#
#' @param hyper name of the hyper column#
#' @param weight weight to be used in the rows#
#' @param data a data frame for inspecting levels#
#' @return Fictional observations in a data frame#
#' @examples#
#' make.hyper.noninteract("Species", "hyperSpecies", 5, iris)#
#
make.hyper.noninteract <- function(nonhyper, hyper, weight, data, sep="") {#
    ## Construct extra from diagonal factor matrix#
    extras <- diag(weight, length(unique(data[, nonhyper])))#
    extras <- as.data.frame(extras)#
#
    names(extras) <- paste(nonhyper, unique(data[, nonhyper]), sep=sep)#
#
    ## Add in the hyper column#
    extras[, hyper] <- -weight#
#
    extras#
}
make.hyper.noninteract("Species", "hyperSpecies", 5, iris)
#' Calculate Fictional Observation Weights#
#'#
#' Determines the coeffiicients for terms in the fictional observations,#
#' to ensure a given weight relative to the normal observations.#
#'#
#' @param formula lm-style formula#
#' @param label the term to be used in fictional observations#
#' @param ratio desired ratio of observed and fictional data#
#' @param data optional data frame#
#' @return Coefficients for fictional observations#
#' @examples#
#' calc.fo.weights(Sepal.Length ~ Petal.Length + Sepal.Width : Species, "Sepal.WidthSpecies", 5, data=iris)#
#
calc.fo.weights <- function(formula, label, ratio, data) {#
    mod.lm <- lm(formula, data)#
    sumerr <- sum(mod.lm$residuals^2)#
#
    ## Collect the beta values for all of these#
    dummies <- substr(names(mod.lm$coefficients), 1, nchar(label)) == label#
    betas <- mod.lm$coefficients[dummies]#
#
    sumerr / (ratio * sum(dummies) * var(betas))#
}
calc.fo.weights(Sepal.Length ~ Petal.Length + Sepal.Width : Species, "Sepal.WidthSpecies", 5, data=iris)
lm(Sepal.Length ~ Petal.Length + Sepal.Width : Species, data=iris)
calc.fo.weights(Sepal.Length ~ Petal.Length + Sepal.Width : Species, "Sepal.Width:Species", 5, data=iris)
#' Create fictional observations for a hyper relationship#
#'#
#' Return a data frame with fictional observations#
#'#
#' @param nonhyper name of the non-hyper column#
#' @param hyper name of the hyper column#
#' @param weight weight to be used in the rows#
#' @param data a data frame for inspecting levels#
#' @return Fictional observations in a data frame#
#' @examples#
#' make.hyper.rows("Species", "hyperSpecies", 5, iris)#
#
make.hyper.rows <- function(nonhyper, hyper, weight, data, sep="") {#
    ## Construct extra from diagonal factor matrix#
    extras <- diag(weight, length(unique(data[, nonhyper])))#
    extras <- as.data.frame(extras)#
#
    names(extras) <- paste(nonhyper, unique(data[, nonhyper]), sep=sep)#
#
    ## Add in the hyper column#
    extras[, hyper] <- -weight#
#
    extras#
}
make.hyper.rows("Species", "hyperSpecies", 5, iris)
#' Fit an hierarchical model#
#'#
#' Interpret a hierarchical formula and fit it with the given data and weight ratios.#
#'#
#' @param formula an hierlm-style formula#
#' @param datas a data frame or a list of data frames, for each lm-style formula contained in the hierlm#
#' @param ratios a vector a ratios for the effect of fictional#
#'   observations, with length as large as the number of hyper#
#'   expressions.#
#' @return A fitted lm model#
#' @examples#
#' hierlm(Sepal.Length ~ Petal.Length + Species + Sepal.Width : Species | Species - ., iris, 1)#
#' hierlm(Sepal.Length ~ Petal.Length + Species + Sepal.Width : Species | Species - . | Sepal.Width : Species - ., iris, c(1, 2))#
#
hierlm <- function(formula, datas, ratios, sep="") {#
    if (is.data.frame(datas))#
        datas <- list(datas)#
#
    data.ii <- 1#
    ratio.ii <- 1#
#
    data <- datas[data.ii]#
#
    ## Split the formula by |#
    labels <- attr(terms(formula), 'term.labels')#
    if (length(labels) == 1) { # otherwise it's just an lm formula#
        chunks <- strsplit(labels, "\\|")[[1]]#
        formula <- as.formula(chunks[1], env=attr(formula1, '.Environment'))#
        for (chunk in chunks[-1]) {#
            formula <- combine.formulae(formula, chunk)#
            terms <- get.hyper.terms(chunk)#
            if (length(terms) == 3) {#
                ## Build the new relationship#
                weight <- calc.fo.weights(formula, terms[1], ratios[ratio.ii], datas[[data.ii]]) # use original data#
                extras <- make.hyper.rows(terms[1], terms[2], weight, datas[[data.ii]])#
#
                ## Done with this ratio#
                ratio.ii <- ratio.ii + 1#
#
                ## Create indicators for nonhyper, if not already done#
                if (terms[1] %in% data)#
                    data <- replace.factor(terms[1], data, 1, sep=sep)#
#
                data <- combine.data.frames(data, extras)#
            } else {#
                ## Add in the next formula#
                data.ii <- data.ii + 1#
                data <- combine.data.frame(data, datas[[data.ii]])#
            }#
        }#
    }#
#
    lm(formula, data=data)#
}
hierlm(Sepal.Length ~ Petal.Length + Species + Sepal.Width : Species | Species - ., iris, 1)
iris
formula = Sepal.Length ~ Petal.Length + Species + Sepal.Width : Species | Species - .
data = iris
ratios = 1
if (is.data.frame(datas))#
        datas <- list(datas)#
#
    data.ii <- 1#
    ratio.ii <- 1#
#
    data <- datas[data.ii]
datas = iris
if (is.data.frame(datas))#
        datas <- list(datas)#
#
    data.ii <- 1#
    ratio.ii <- 1#
#
    data <- datas[data.ii]
## Split the formula by |#
    labels <- attr(terms(formula), 'term.labels')#
    if (length(labels) == 1) { # otherwise it's just an lm formula#
        chunks <- strsplit(labels, "\\|")[[1]]#
        formula <- as.formula(chunks[1], env=attr(formula1, '.Environment'))#
        for (chunk in chunks[-1]) {#
            formula <- combine.formulae(formula, chunk)#
            terms <- get.hyper.terms(chunk)#
            if (length(terms) == 3) {#
                ## Build the new relationship#
                weight <- calc.fo.weights(formula, terms[1], ratios[ratio.ii], datas[[data.ii]]) # use original data#
                extras <- make.hyper.rows(terms[1], terms[2], weight, datas[[data.ii]])#
#
                ## Done with this ratio#
                ratio.ii <- ratio.ii + 1#
#
                ## Create indicators for nonhyper, if not already done#
                if (terms[1] %in% data)#
                    data <- replace.factor(terms[1], data, 1, sep=sep)#
#
                data <- combine.data.frames(data, extras)#
            } else {#
                ## Add in the next formula#
                data.ii <- data.ii + 1#
                data <- combine.data.frame(data, datas[[data.ii]])#
            }#
        }#
    }
#' Fit an hierarchical model#
#'#
#' Interpret a hierarchical formula and fit it with the given data and weight ratios.#
#'#
#' @param formula an hierlm-style formula#
#' @param datas a data frame or a list of data frames, for each lm-style formula contained in the hierlm#
#' @param ratios a vector a ratios for the effect of fictional#
#'   observations, with length as large as the number of hyper#
#'   expressions.#
#' @return A fitted lm model#
#' @examples#
#' hierlm(Sepal.Length ~ Petal.Length + Species + Sepal.Width : Species | Species - ., iris, 1)#
#' hierlm(Sepal.Length ~ Petal.Length + Species + Sepal.Width : Species | Species - . | Sepal.Width : Species - ., iris, c(1, 2))#
#
hierlm <- function(formula, datas, ratios, sep="") {#
    if (is.data.frame(datas))#
        datas <- list(datas)#
#
    data.ii <- 1#
    ratio.ii <- 1#
#
    data <- datas[data.ii]#
#
    ## Split the formula by |#
    labels <- attr(terms(formula), 'term.labels')#
    if (length(labels) == 1) { # otherwise it's just an lm formula#
        chunks <- strsplit(labels, "\\|")[[1]]#
        formula <- as.formula(chunks[1], env=attr(formula1, '.Environment'))#
        for (chunk in chunks[-1]) {#
            print(chunk)#
            formula <- combine.formulae(formula, chunk)#
            terms <- get.hyper.terms(chunk)#
            if (length(terms) == 3) {#
                ## Build the new relationship#
                weight <- calc.fo.weights(formula, terms[1], ratios[ratio.ii], datas[[data.ii]]) # use original data#
                extras <- make.hyper.rows(terms[1], terms[2], weight, datas[[data.ii]])#
#
                ## Done with this ratio#
                ratio.ii <- ratio.ii + 1#
#
                ## Create indicators for nonhyper, if not already done#
                if (terms[1] %in% data)#
                    data <- replace.factor(terms[1], data, 1, sep=sep)#
#
                data <- combine.data.frames(data, extras)#
            } else {#
                ## Add in the next formula#
                data.ii <- data.ii + 1#
                data <- combine.data.frame(data, datas[[data.ii]])#
            }#
        }#
    }#
#
    lm(formula, data=data)#
}
formula = Sepal.Length ~ Petal.Length + Species + Sepal.Width : Species | Species - .
hierlm(Sepal.Length ~ Petal.Length + Species + Sepal.Width : Species | Species - ., iris, 1)
#' Fit an hierarchical model#
#'#
#' Interpret a hierarchical formula and fit it with the given data and weight ratios.#
#'#
#' @param formula an hierlm-style formula#
#' @param datas a data frame or a list of data frames, for each lm-style formula contained in the hierlm#
#' @param ratios a vector a ratios for the effect of fictional#
#'   observations, with length as large as the number of hyper#
#'   expressions.#
#' @return A fitted lm model#
#' @examples#
#' hierlm(Sepal.Length ~ Petal.Length + Species + Sepal.Width : Species | Species - ., iris, 1)#
#' hierlm(Sepal.Length ~ Petal.Length + Species + Sepal.Width : Species | Species - . | Sepal.Width : Species - ., iris, c(1, 2))#
#
hierlm <- function(formula, datas, ratios, sep="") {#
    if (is.data.frame(datas))#
        datas <- list(datas)#
#
    data.ii <- 1#
    ratio.ii <- 1#
#
    data <- datas[data.ii]#
#
    ## Split the formula by |#
    labels <- attr(terms(formula), 'term.labels')#
    if (length(labels) == 1) { # otherwise it's just an lm formula#
        chunks <- strsplit(labels, "\\|")[[1]]#
        print(chunks)#
        formula <- as.formula(chunks[1], env=attr(formula1, '.Environment'))#
        for (chunk in chunks[-1]) {#
            print(chunk)#
            formula <- combine.formulae(formula, chunk)#
            terms <- get.hyper.terms(chunk)#
            if (length(terms) == 3) {#
                ## Build the new relationship#
                weight <- calc.fo.weights(formula, terms[1], ratios[ratio.ii], datas[[data.ii]]) # use original data#
                extras <- make.hyper.rows(terms[1], terms[2], weight, datas[[data.ii]])#
#
                ## Done with this ratio#
                ratio.ii <- ratio.ii + 1#
#
                ## Create indicators for nonhyper, if not already done#
                if (terms[1] %in% data)#
                    data <- replace.factor(terms[1], data, 1, sep=sep)#
#
                data <- combine.data.frames(data, extras)#
            } else {#
                ## Add in the next formula#
                data.ii <- data.ii + 1#
                data <- combine.data.frame(data, datas[[data.ii]])#
            }#
        }#
    }#
#
    lm(formula, data=data)#
}
hierlm(Sepal.Length ~ Petal.Length + Species + Sepal.Width : Species | Species - ., iris, 1)
#' Fit an hierarchical model#
#'#
#' Interpret a hierarchical formula and fit it with the given data and weight ratios.#
#'#
#' @param formula an hierlm-style formula#
#' @param datas a data frame or a list of data frames, for each lm-style formula contained in the hierlm#
#' @param ratios a vector a ratios for the effect of fictional#
#'   observations, with length as large as the number of hyper#
#'   expressions.#
#' @return A fitted lm model#
#' @examples#
#' hierlm(Sepal.Length ~ Petal.Length + Species + Sepal.Width : Species | Species - ., iris, 1)#
#' hierlm(Sepal.Length ~ Petal.Length + Species + Sepal.Width : Species | Species - . | Sepal.Width : Species - ., iris, c(1, 2))#
#
hierlm <- function(formula, datas, ratios, sep="") {#
    if (is.data.frame(datas))#
        datas <- list(datas)#
#
    data.ii <- 1#
    ratio.ii <- 1#
#
    data <- datas[data.ii]#
#
    ## Split the formula by |#
    labels <- attr(terms(formula), 'term.labels')#
    if (length(labels) == 1) { # otherwise it's just an lm formula#
        chunks <- strsplit(labels, "\\|")[[1]]#
        print(chunks)#
        formula <- as.formula(chunks[1], env=attr(formula, '.Environment'))#
        for (chunk in chunks[-1]) {#
            print(chunk)#
            formula <- combine.formulae(formula, chunk)#
            terms <- get.hyper.terms(chunk)#
            if (length(terms) == 3) {#
                ## Build the new relationship#
                weight <- calc.fo.weights(formula, terms[1], ratios[ratio.ii], datas[[data.ii]]) # use original data#
                extras <- make.hyper.rows(terms[1], terms[2], weight, datas[[data.ii]])#
#
                ## Done with this ratio#
                ratio.ii <- ratio.ii + 1#
#
                ## Create indicators for nonhyper, if not already done#
                if (terms[1] %in% data)#
                    data <- replace.factor(terms[1], data, 1, sep=sep)#
#
                data <- combine.data.frames(data, extras)#
            } else {#
                ## Add in the next formula#
                data.ii <- data.ii + 1#
                data <- combine.data.frame(data, datas[[data.ii]])#
            }#
        }#
    }#
#
    lm(formula, data=data)#
}
hierlm(Sepal.Length ~ Petal.Length + Species + Sepal.Width : Species | Species - ., iris, 1)
Sepal.Length ~ Petal.Length + Species + Sepal.Width : Species | Species - .
datas
if (is.data.frame(datas))#
        datas <- list(datas)#
#
    data.ii <- 1#
    ratio.ii <- 1#
#
    data <- datas[data.ii]#
#
    ## Split the formula by |#
    labels <- attr(terms(formula), 'term.labels')
labels
chunks <- strsplit(labels, "\\|")[[1]]
formula <- as.formula(chunks[1], env=attr(formula, '.Environment'))
as.formula(chunks[1])
formula
Sepal.Length ~ Petal.Length + Species + Sepal.Width:Species
as.formula(Sepal.Length ~ Petal.Length + Species + Sepal.Width:Species)
as.formula(Sepal.Length ~ Petal.Length + Species + Sepal.Width:Species, env=attr(formula, '.Environment'))
as.formula("Sepal.Length ~ Petal.Length + Species + Sepal.Width:Species", env=attr(formula, '.Environment'))
as.formula(chunks[1], env=attr(formula, '.Environment'))
chunks[1]
labels
terms(formula)
length(labels)
#' Fit an hierarchical model#
#'#
#' Interpret a hierarchical formula and fit it with the given data and weight ratios.#
#'#
#' @param formula an hierlm-style formula#
#' @param datas a data frame or a list of data frames, for each lm-style formula contained in the hierlm#
#' @param ratios a vector a ratios for the effect of fictional#
#'   observations, with length as large as the number of hyper#
#'   expressions.#
#' @return A fitted lm model#
#' @examples#
#' hierlm(Sepal.Length ~ Petal.Length + Species + Sepal.Width : Species | Species - ., iris, 1)#
#' hierlm(Sepal.Length ~ Petal.Length + Species + Sepal.Width : Species | Species - . | Sepal.Width : Species - ., iris, c(1, 2))#
#
hierlm <- function(formula, datas, ratios, sep="") {#
    if (is.data.frame(datas))#
        datas <- list(datas)#
#
    data.ii <- 1#
    ratio.ii <- 1#
#
    data <- datas[data.ii]#
#
    ## Split the formula by |#
    labels <- attr(terms(formula), 'term.labels')#
    if (length(labels) == 1) { # otherwise it's just an lm formula#
        lhs <- as.character(formula)[2]#
        chunks <- strsplit(labels, "\\|")[[1]]#
        formula <- as.formula(paste(lhs, "~", chunks[1]), env=attr(formula, '.Environment'))#
        for (chunk in chunks[-1]) {#
            print(chunk)#
            formula <- combine.formulae(formula, chunk)#
            terms <- get.hyper.terms(chunk)#
            if (length(terms) == 3) {#
                ## Build the new relationship#
                weight <- calc.fo.weights(formula, terms[1], ratios[ratio.ii], datas[[data.ii]]) # use original data#
                extras <- make.hyper.rows(terms[1], terms[2], weight, datas[[data.ii]])#
#
                ## Done with this ratio#
                ratio.ii <- ratio.ii + 1#
#
                ## Create indicators for nonhyper, if not already done#
                if (terms[1] %in% data)#
                    data <- replace.factor(terms[1], data, 1, sep=sep)#
#
                data <- combine.data.frames(data, extras)#
            } else {#
                ## Add in the next formula#
                data.ii <- data.ii + 1#
                data <- combine.data.frame(data, datas[[data.ii]])#
            }#
        }#
    }#
#
    lm(formula, data=data)#
}
hierlm(Sepal.Length ~ Petal.Length + Species + Sepal.Width : Species | Species - ., iris, 1)
#' Fit an hierarchical model#
#'#
#' Interpret a hierarchical formula and fit it with the given data and weight ratios.#
#'#
#' @param formula an hierlm-style formula#
#' @param datas a data frame or a list of data frames, for each lm-style formula contained in the hierlm#
#' @param ratios a vector a ratios for the effect of fictional#
#'   observations, with length as large as the number of hyper#
#'   expressions.#
#' @return A fitted lm model#
#' @examples#
#' hierlm(Sepal.Length ~ Petal.Length + Species + Sepal.Width : Species | Species - ., iris, 1)#
#' hierlm(Sepal.Length ~ Petal.Length + Species + Sepal.Width : Species | Species - . | Sepal.Width : Species - ., iris, c(1, 2))#
#
hierlm <- function(formula, datas, ratios, sep="") {#
    if (is.data.frame(datas))#
        datas <- list(datas)#
#
    data.ii <- 1#
    ratio.ii <- 1#
#
    data <- datas[data.ii]#
#
    ## Split the formula by |#
    labels <- attr(terms(formula), 'term.labels')#
    if (length(labels) == 1) { # otherwise it's just an lm formula#
        lhs <- as.character(formula)[2]#
        chunks <- strsplit(labels, "\\|")[[1]]#
        formula <- as.formula(paste(lhs, "~", chunks[1]), env=attr(formula, '.Environment'))#
        for (chunk in chunks[-1]) {#
            formula <- combine.formulae(formula, chunk)#
            terms <- get.hyper.terms(chunk)#
            if (length(terms) == 3) {#
                ## Build the new relationship#
                weight <- calc.fo.weights(formula, terms[1], ratios[ratio.ii], datas[[data.ii]]) # use original data#
                extras <- make.hyper.rows(terms[1], terms[2], weight, datas[[data.ii]])#
#
                ## Done with this ratio#
                ratio.ii <- ratio.ii + 1#
#
                ## Create indicators for nonhyper, if not already done#
                if (terms[1] %in% data)#
                    data <- replace.factor(terms[1], data, 1, sep=sep)#
#
                data <- combine.data.frames(data, extras)#
            } else {#
                ## Add in the next formula#
                data.ii <- data.ii + 1#
                data <- combine.data.frame(data, datas[[data.ii]])#
            }#
        }#
    }#
#
    print(formula)#
    lm(formula, data=data)#
}
hierlm(Sepal.Length ~ Petal.Length + Species + Sepal.Width : Species | Species - ., iris, 1)
formula
labels <- attr(terms(formula), 'term.labels')#
    if (length(labels) == 1) { # otherwise it's just an lm formula#
        lhs <- as.character(formula)[2]#
        chunks <- strsplit(labels, "\\|")[[1]]#
        formula <- as.formula(paste(lhs, "~", chunks[1]), env=attr(formula, '.Environment'))#
        for (chunk in chunks[-1]) {#
            formula <- combine.formulae(formula, chunk)#
            terms <- get.hyper.terms(chunk)#
            if (length(terms) == 3) {#
                ## Build the new relationship#
                weight <- calc.fo.weights(formula, terms[1], ratios[ratio.ii], datas[[data.ii]]) # use original data#
                extras <- make.hyper.rows(terms[1], terms[2], weight, datas[[data.ii]])#
#
                ## Done with this ratio#
                ratio.ii <- ratio.ii + 1#
#
                ## Create indicators for nonhyper, if not already done#
                if (terms[1] %in% data)#
                    data <- replace.factor(terms[1], data, 1, sep=sep)#
#
                data <- combine.data.frames(data, extras)#
            } else {#
                ## Add in the next formula#
                data.ii <- data.ii + 1#
                data <- combine.data.frame(data, datas[[data.ii]])#
            }#
        }#
    }
formula
terms
extras
weight
#' Fit an hierarchical model#
#'#
#' Interpret a hierarchical formula and fit it with the given data and weight ratios.#
#'#
#' @param formula an hierlm-style formula#
#' @param datas a data frame or a list of data frames, for each lm-style formula contained in the hierlm#
#' @param ratios a vector a ratios for the effect of fictional#
#'   observations, with length as large as the number of hyper#
#'   expressions.#
#' @return A fitted lm model#
#' @examples#
#' hierlm(Sepal.Length ~ Petal.Length + Species + Sepal.Width : Species | Species - ., iris, 1)#
#' hierlm(Sepal.Length ~ Petal.Length + Species + Sepal.Width : Species | Species - . | Sepal.Width : Species - ., iris, c(1, 2))#
#
hierlm <- function(formula, datas, ratios, sep="") {#
    if (is.data.frame(datas))#
        datas <- list(datas)#
#
    data.ii <- 1#
    ratio.ii <- 1#
#
    data <- datas[data.ii]#
#
    ## Split the formula by |#
    labels <- attr(terms(formula), 'term.labels')#
    if (length(labels) == 1) { # otherwise it's just an lm formula#
        lhs <- as.character(formula)[2]#
        chunks <- strsplit(labels, "\\|")[[1]]#
        formula <- as.formula(paste(lhs, "~", chunks[1]), env=attr(formula, '.Environment'))#
        for (chunk in chunks[-1]) {#
            # Make the new formula#
            oldformula <- formula#
            formula <- combine.formulae(formula, chunk)#
            if (!("constant" %in% names(data)) && "constant" %in% get.formula.terms(formula))#
                data$constant <- 1#
#
            terms <- get.hyper.terms(chunk)#
            if (length(terms) == 3) {#
                ## Build the new relationship#
                weight <- calc.fo.weights(oldformula, terms[1], ratios[ratio.ii], datas[[data.ii]]) # use original data#
                extras <- make.hyper.rows(terms[1], terms[2], weight, datas[[data.ii]])#
#
                ## Done with this ratio#
                ratio.ii <- ratio.ii + 1#
#
                ## Create indicators for nonhyper, if not already done#
                if (terms[1] %in% data)#
                    data <- replace.factor(terms[1], data, 1, sep=sep)#
#
                data <- combine.data.frames(data, extras)#
#
            } else {#
                ## Add in the next formula#
                data.ii <- data.ii + 1#
                data <- combine.data.frame(data, datas[[data.ii]])#
            }#
        }#
    }#
#
    print(formula)#
    lm(formula, data=data)#
}
hierlm(Sepal.Length ~ Petal.Length + Species + Sepal.Width : Species | Species - ., iris, 1)
#' Fit an hierarchical model#
#'#
#' Interpret a hierarchical formula and fit it with the given data and weight ratios.#
#'#
#' @param formula an hierlm-style formula#
#' @param datas a data frame or a list of data frames, for each lm-style formula contained in the hierlm#
#' @param ratios a vector a ratios for the effect of fictional#
#'   observations, with length as large as the number of hyper#
#'   expressions.#
#' @return A fitted lm model#
#' @examples#
#' hierlm(Sepal.Length ~ Petal.Length + Species + Sepal.Width : Species | Species - ., iris, 1)#
#' hierlm(Sepal.Length ~ Petal.Length + Species + Sepal.Width : Species | Species - . | Sepal.Width : Species - ., iris, c(1, 2))#
#
hierlm <- function(formula, datas, ratios, sep="") {#
    if (is.data.frame(datas))#
        datas <- list(datas)#
#
    data.ii <- 1#
    ratio.ii <- 1#
#
    data <- datas[data.ii]#
#
    ## Split the formula by |#
    labels <- attr(terms(formula), 'term.labels')#
    if (length(labels) == 1) { # otherwise it's just an lm formula#
        lhs <- as.character(formula)[2]#
        chunks <- strsplit(labels, "\\|")[[1]]#
        formula <- as.formula(paste(lhs, "~", chunks[1]), env=attr(formula, '.Environment'))#
        for (chunk in chunks[-1]) {#
            # Make the new formula#
            oldformula <- formula#
            formula <- combine.formulae(formula, chunk)#
            if (!("constant" %in% names(data)) && "constant" %in% get.formula.terms(formula))#
                data$constant <- 1#
#
            terms <- get.hyper.terms(chunk)#
            if (length(terms) == 3) {#
                ## Build the new relationship#
                weight <- calc.fo.weights(oldformula, terms[1], ratios[ratio.ii], datas[[data.ii]]) # use original data#
                extras <- make.hyper.rows(terms[1], terms[2], weight, datas[[data.ii]])#
#
                ## Done with this ratio#
                ratio.ii <- ratio.ii + 1#
#
                ## Create indicators for nonhyper, if not already done#
                if (terms[1] %in% data)#
                    data <- replace.factor(terms[1], data, 1, sep=sep)#
#
                print(data)#
                data <- combine.data.frames(data, extras)#
#
            } else {#
                ## Add in the next formula#
                data.ii <- data.ii + 1#
                data <- combine.data.frame(data, datas[[data.ii]])#
            }#
        }#
    }#
#
    print(formula)#
    lm(formula, data=data)#
}
hierlm(Sepal.Length ~ Petal.Length + Species + Sepal.Width : Species | Species - ., iris, 1)
#' Fit an hierarchical model#
#'#
#' Interpret a hierarchical formula and fit it with the given data and weight ratios.#
#'#
#' @param formula an hierlm-style formula#
#' @param datas a data frame or a list of data frames, for each lm-style formula contained in the hierlm#
#' @param ratios a vector a ratios for the effect of fictional#
#'   observations, with length as large as the number of hyper#
#'   expressions.#
#' @return A fitted lm model#
#' @examples#
#' hierlm(Sepal.Length ~ Petal.Length + Species + Sepal.Width : Species | Species - ., iris, 1)#
#' hierlm(Sepal.Length ~ Petal.Length + Species + Sepal.Width : Species | Species - . | Sepal.Width : Species - ., iris, c(1, 2))#
#
hierlm <- function(formula, datas, ratios, sep="") {#
    if (is.data.frame(datas))#
        datas <- list(datas)#
#
    data.ii <- 1#
    ratio.ii <- 1#
#
    data <- datas[[data.ii]]#
#
    ## Split the formula by |#
    labels <- attr(terms(formula), 'term.labels')#
    if (length(labels) == 1) { # otherwise it's just an lm formula#
        lhs <- as.character(formula)[2]#
        chunks <- strsplit(labels, "\\|")[[1]]#
        formula <- as.formula(paste(lhs, "~", chunks[1]), env=attr(formula, '.Environment'))#
        for (chunk in chunks[-1]) {#
            # Make the new formula#
            oldformula <- formula#
            formula <- combine.formulae(formula, chunk)#
            if (!("constant" %in% names(data)) && "constant" %in% get.formula.terms(formula))#
                data$constant <- 1#
#
            terms <- get.hyper.terms(chunk)#
            if (length(terms) == 3) {#
                ## Build the new relationship#
                weight <- calc.fo.weights(oldformula, terms[1], ratios[ratio.ii], datas[[data.ii]]) # use original data#
                extras <- make.hyper.rows(terms[1], terms[2], weight, datas[[data.ii]])#
#
                ## Done with this ratio#
                ratio.ii <- ratio.ii + 1#
#
                ## Create indicators for nonhyper, if not already done#
                if (terms[1] %in% data)#
                    data <- replace.factor(terms[1], data, 1, sep=sep)#
#
                data <- combine.data.frames(data, extras)#
            } else {#
                ## Add in the next formula#
                data.ii <- data.ii + 1#
                data <- combine.data.frame(data, datas[[data.ii]])#
            }#
        }#
    }#
#
    print(formula)#
    lm(formula, data=data)#
}
hierlm(Sepal.Length ~ Petal.Length + Species + Sepal.Width : Species | Species - ., iris, 1)
#' Fit an hierarchical model#
#'#
#' Interpret a hierarchical formula and fit it with the given data and weight ratios.#
#'#
#' @param formula an hierlm-style formula#
#' @param datas a data frame or a list of data frames, for each lm-style formula contained in the hierlm#
#' @param ratios a vector a ratios for the effect of fictional#
#'   observations, with length as large as the number of hyper#
#'   expressions.#
#' @return A fitted lm model#
#' @examples#
#' hierlm(Sepal.Length ~ Petal.Length + Species + Sepal.Width : Species | Species - ., iris, 1)#
#' hierlm(Sepal.Length ~ Petal.Length + Species + Sepal.Width : Species | Species - . | Sepal.Width : Species - ., iris, c(1, 2))#
#
hierlm <- function(formula, datas, ratios, sep="") {#
    if (is.data.frame(datas))#
        datas <- list(datas)#
#
    data.ii <- 1#
    ratio.ii <- 1#
#
    data <- datas[[data.ii]]#
#
    ## Split the formula by |#
    labels <- attr(terms(formula), 'term.labels')#
    if (length(labels) == 1) { # otherwise it's just an lm formula#
        lhs <- as.character(formula)[2]#
        chunks <- strsplit(labels, "\\|")[[1]]#
        formula <- as.formula(paste(lhs, "~", chunks[1]), env=attr(formula, '.Environment'))#
        for (chunk in chunks[-1]) {#
            # Make the new formula#
            oldformula <- formula#
            formula <- combine.formulae(formula, chunk)#
            if (!("constant" %in% names(data)) && "constant" %in% get.formula.terms(formula))#
                data$constant <- 1#
#
            terms <- get.hyper.terms(chunk)#
            if (length(terms) == 3) {#
                ## Build the new relationship#
                weight <- calc.fo.weights(oldformula, terms[1], ratios[ratio.ii], datas[[data.ii]]) # use original data#
                extras <- make.hyper.rows(terms[1], terms[2], weight, datas[[data.ii]])#
#
                ## Done with this ratio#
                ratio.ii <- ratio.ii + 1#
#
                ## Create indicators for nonhyper, if not already done#
                if (terms[1] %in% data)#
                    data <- replace.factor(terms[1], data, 1, sep=sep)#
#
                data <- combine.data.frames(data, extras)#
            } else {#
                ## Add in the next formula#
                data.ii <- data.ii + 1#
                data <- combine.data.frame(data, datas[[data.ii]])#
            }#
        }#
    }#
#
    print(head(data))#
    print(formula)#
    lm(formula, data=data)#
}
hierlm(Sepal.Length ~ Petal.Length + Species + Sepal.Width : Species | Species - ., iris, 1)
#' Fit an hierarchical model#
#'#
#' Interpret a hierarchical formula and fit it with the given data and weight ratios.#
#'#
#' @param formula an hierlm-style formula#
#' @param datas a data frame or a list of data frames, for each lm-style formula contained in the hierlm#
#' @param ratios a vector a ratios for the effect of fictional#
#'   observations, with length as large as the number of hyper#
#'   expressions.#
#' @return A fitted lm model#
#' @examples#
#' hierlm(Sepal.Length ~ Petal.Length + Species + Sepal.Width : Species | Species - ., iris, 1)#
#' hierlm(Sepal.Length ~ Petal.Length + Species + Sepal.Width : Species | Species - . | Sepal.Width : Species - ., iris, c(1, 2))#
#
hierlm <- function(formula, datas, ratios, sep="") {#
    if (is.data.frame(datas))#
        datas <- list(datas)#
#
    data.ii <- 1#
    ratio.ii <- 1#
#
    data <- datas[[data.ii]]#
#
    ## Split the formula by |#
    labels <- attr(terms(formula), 'term.labels')#
    if (length(labels) == 1) { # otherwise it's just an lm formula#
        lhs <- as.character(formula)[2]#
        chunks <- strsplit(labels, "\\|")[[1]]#
        formula <- as.formula(paste(lhs, "~", chunks[1]), env=attr(formula, '.Environment'))#
        for (chunk in chunks[-1]) {#
            # Make the new formula#
            oldformula <- formula#
            formula <- combine.formulae(formula, chunk)#
            if (!("constant" %in% names(data)) && "constant" %in% get.formula.terms(formula))#
                data$constant <- 1#
#
            terms <- get.hyper.terms(chunk)#
            if (length(terms) == 3) {#
                ## Build the new relationship#
                weight <- calc.fo.weights(oldformula, terms[1], ratios[ratio.ii], datas[[data.ii]]) # use original data#
                extras <- make.hyper.rows(terms[1], terms[2], weight, datas[[data.ii]])#
#
                ## Done with this ratio#
                ratio.ii <- ratio.ii + 1#
#
                ## Create indicators for nonhyper, if not already done#
                if (terms[1] %in% data)#
                    data <- replace.factor(terms[1], data, 1, sep=sep)#
#
                print(extras)#
                data <- combine.data.frames(data, extras)#
            } else {#
                ## Add in the next formula#
                data.ii <- data.ii + 1#
                data <- combine.data.frame(data, datas[[data.ii]])#
            }#
        }#
    }#
#
    print(head(data))#
    print(formula)#
    lm(formula, data=data)#
}
hierlm(Sepal.Length ~ Petal.Length + Species + Sepal.Width : Species | Species - ., iris, 1)
#' Fit an hierarchical model#
#'#
#' Interpret a hierarchical formula and fit it with the given data and weight ratios.#
#'#
#' @param formula an hierlm-style formula#
#' @param datas a data frame or a list of data frames, for each lm-style formula contained in the hierlm#
#' @param ratios a vector a ratios for the effect of fictional#
#'   observations, with length as large as the number of hyper#
#'   expressions.#
#' @return A fitted lm model#
#' @examples#
#' hierlm(Sepal.Length ~ Petal.Length + Species + Sepal.Width : Species | Species - ., iris, 1)#
#' hierlm(Sepal.Length ~ Petal.Length + Species + Sepal.Width : Species | Species - . | Sepal.Width : Species - ., iris, c(1, 2))#
#
hierlm <- function(formula, datas, ratios, sep="") {#
    if (is.data.frame(datas))#
        datas <- list(datas)#
#
    data.ii <- 1#
    ratio.ii <- 1#
#
    data <- datas[[data.ii]]#
#
    ## Split the formula by |#
    labels <- attr(terms(formula), 'term.labels')#
    if (length(labels) == 1) { # otherwise it's just an lm formula#
        lhs <- as.character(formula)[2]#
        chunks <- strsplit(labels, "\\|")[[1]]#
        formula <- as.formula(paste(lhs, "~", chunks[1]), env=attr(formula, '.Environment'))#
        for (chunk in chunks[-1]) {#
            # Make the new formula#
            oldformula <- formula#
            formula <- combine.formulae(formula, chunk)#
            if (!("constant" %in% names(data)) && "constant" %in% get.formula.terms(formula))#
                data$constant <- 1#
#
            terms <- get.hyper.terms(chunk)#
            if (length(terms) == 3) {#
                ## Build the new relationship#
                weight <- calc.fo.weights(oldformula, terms[1], ratios[ratio.ii], datas[[data.ii]]) # use original data#
                extras <- make.hyper.rows(terms[1], terms[2], weight, datas[[data.ii]])#
#
                ## Done with this ratio#
                ratio.ii <- ratio.ii + 1#
#
                ## Create indicators for nonhyper, if not already done#
                if (terms[1] %in% data)#
                    data <- replace.factor(terms[1], data, 1, sep=sep)#
#
                data <- combine.data.frames(data, extras)#
            } else {#
                ## Add in the next formula#
                data.ii <- data.ii + 1#
                data <- combine.data.frame(data, datas[[data.ii]])#
            }#
        }#
    }#
#
    print(head(data))#
    print(tail(data))#
    print(formula)#
    lm(formula, data=data)#
}
hierlm(Sepal.Length ~ Petal.Length + Species + Sepal.Width : Species | Species - ., iris, 1)
formula = Sepal.Length ~ Petal.Length : Species
get.formula.terms(formula)
#' Fit an hierarchical model#
#'#
#' Interpret a hierarchical formula and fit it with the given data and weight ratios.#
#'#
#' @param formula an hierlm-style formula#
#' @param datas a data frame or a list of data frames, for each lm-style formula contained in the hierlm#
#' @param ratios a vector a ratios for the effect of fictional#
#'   observations, with length as large as the number of hyper#
#'   expressions.#
#' @return A fitted lm model#
#' @examples#
#' hierlm(Sepal.Length ~ Petal.Length + Species + Sepal.Width : Species | Species - ., iris, 1)#
#' hierlm(Sepal.Length ~ Petal.Length + Species + Sepal.Width : Species | Species - . | Sepal.Width : Species - ., iris, c(1, 2))#
#
hierlm <- function(formula, datas, ratios, sep="") {#
    if (is.data.frame(datas))#
        datas <- list(datas)#
#
    data.ii <- 1#
    ratio.ii <- 1#
#
    data <- datas[[data.ii]]#
#
    ## Split the formula by |#
    labels <- attr(terms(formula), 'term.labels')#
    if (length(labels) == 1) { # otherwise it's just an lm formula#
        lhs <- as.character(formula)[2]#
        chunks <- strsplit(labels, "\\|")[[1]]#
        formula <- as.formula(paste(lhs, "~", chunks[1]), env=attr(formula, '.Environment'))#
        for (chunk in chunks[-1]) {#
            ## Keep these around#
            oldformula <- formula#
            olddata <- data#
#
            ## Make the new formula#
            formula <- combine.formulae(formula, chunk)#
            if (!("constant" %in% names(data)) && "constant" %in% get.formula.terms(formula))#
                data$constant <- 1#
#
            terms <- get.hyper.terms(chunk)#
            if (length(terms) == 3) {#
                ## Build the new relationship#
                weight <- calc.fo.weights(oldformula, terms[1], ratios[ratio.ii], datas[[data.ii]]) # use original data#
                extras <- make.hyper.rows(terms[1], terms[2], weight, datas[[data.ii]])#
#
                ## Done with this ratio#
                ratio.ii <- ratio.ii + 1#
#
                ## Create indicators for nonhyper, if not already done#
                if (terms[1] %in% data)#
                    data <- replace.factor(terms[1], data, 1, sep=sep)#
#
                data <- combine.data.frames(data, extras)#
            } else {#
                ## Add in the next formula#
                data.ii <- data.ii + 1#
                data <- combine.data.frame(data, datas[[data.ii]])#
            }#
#
            ## Have any of the terms in the formula been factorized?#
            checks <- get.formula.terms(formula)#
            for (check in checks) {#
                if (is.factor(olddata[, check]))#
                    formula <- replace.factor.formula(check, formula, data)#
            }#
        }#
    }#
#
    print(head(data))#
    print(tail(data))#
    print(formula)#
    lm(formula, data=data)#
}
hierlm(Sepal.Length ~ Petal.Length + Species + Sepal.Width : Species | Species - ., iris, 1)
#' Fit an hierarchical model#
#'#
#' Interpret a hierarchical formula and fit it with the given data and weight ratios.#
#'#
#' @param formula an hierlm-style formula#
#' @param datas a data frame or a list of data frames, for each lm-style formula contained in the hierlm#
#' @param ratios a vector a ratios for the effect of fictional#
#'   observations, with length as large as the number of hyper#
#'   expressions.#
#' @return A fitted lm model#
#' @examples#
#' hierlm(Sepal.Length ~ Petal.Length + Species + Sepal.Width : Species | Species - ., iris, 1)#
#' hierlm(Sepal.Length ~ Petal.Length + Species + Sepal.Width : Species | Species - . | Sepal.Width : Species - ., iris, c(1, 2))#
#
hierlm <- function(formula, datas, ratios, sep="") {#
    if (is.data.frame(datas))#
        datas <- list(datas)#
#
    data.ii <- 1#
    ratio.ii <- 1#
#
    data <- datas[[data.ii]]#
#
    ## Split the formula by |#
    labels <- attr(terms(formula), 'term.labels')#
    if (length(labels) == 1) { # otherwise it's just an lm formula#
        lhs <- as.character(formula)[2]#
        chunks <- strsplit(labels, "\\|")[[1]]#
        formula <- as.formula(paste(lhs, "~", chunks[1]), env=attr(formula, '.Environment'))#
        for (chunk in chunks[-1]) {#
            ## Keep these around#
            oldformula <- formula#
            olddata <- data#
#
            ## Make the new formula#
            formula <- combine.formulae(formula, chunk)#
            if (!("constant" %in% names(data)) && "constant" %in% get.formula.terms(formula))#
                data$constant <- 1#
#
            terms <- get.hyper.terms(chunk)#
            if (length(terms) == 3) {#
                ## Build the new relationship#
                weight <- calc.fo.weights(oldformula, terms[1], ratios[ratio.ii], datas[[data.ii]]) # use original data#
                extras <- make.hyper.rows(terms[1], terms[2], weight, datas[[data.ii]])#
#
                ## Done with this ratio#
                ratio.ii <- ratio.ii + 1#
#
                ## Create indicators for nonhyper, if not already done#
                if (terms[1] %in% data)#
                    data <- replace.factor(terms[1], data, 1, sep=sep)#
#
                data <- combine.data.frames(data, extras)#
            } else {#
                ## Add in the next formula#
                data.ii <- data.ii + 1#
                data <- combine.data.frame(data, datas[[data.ii]])#
            }#
#
            ## Have any of the terms in the formula been factorized?#
            checks <- get.formula.terms(formula)#
            for (check in checks) {#
                print(check)#
                if (is.factor(olddata[, check]))#
                    formula <- replace.factor.formula(check, formula, data)#
            }#
        }#
    }#
#
    print(head(data))#
    print(tail(data))#
    print(formula)#
    lm(formula, data=data)#
}
hierlm(Sepal.Length ~ Petal.Length + Species + Sepal.Width : Species | Species - ., iris, 1)
#' Fit an hierarchical model#
#'#
#' Interpret a hierarchical formula and fit it with the given data and weight ratios.#
#'#
#' @param formula an hierlm-style formula#
#' @param datas a data frame or a list of data frames, for each lm-style formula contained in the hierlm#
#' @param ratios a vector a ratios for the effect of fictional#
#'   observations, with length as large as the number of hyper#
#'   expressions.#
#' @return A fitted lm model#
#' @examples#
#' hierlm(Sepal.Length ~ Petal.Length + Species + Sepal.Width : Species | Species - ., iris, 1)#
#' hierlm(Sepal.Length ~ Petal.Length + Species + Sepal.Width : Species | Species - . | Sepal.Width : Species - ., iris, c(1, 2))#
#
hierlm <- function(formula, datas, ratios, sep="") {#
    if (is.data.frame(datas))#
        datas <- list(datas)#
#
    data.ii <- 1#
    ratio.ii <- 1#
#
    data <- datas[[data.ii]]#
#
    ## Split the formula by |#
    labels <- attr(terms(formula), 'term.labels')#
    if (length(labels) == 1) { # otherwise it's just an lm formula#
        lhs <- as.character(formula)[2]#
        chunks <- strsplit(labels, "\\|")[[1]]#
        formula <- as.formula(paste(lhs, "~", chunks[1]), env=attr(formula, '.Environment'))#
        for (chunk in chunks[-1]) {#
            ## Keep these around#
            oldformula <- formula#
            olddata <- data#
#
            ## Make the new formula#
            formula <- combine.formulae(formula, chunk)#
            if (!("constant" %in% names(data)) && "constant" %in% get.formula.terms(formula))#
                data$constant <- 1#
#
            terms <- get.hyper.terms(chunk)#
            if (length(terms) == 3) {#
                ## Build the new relationship#
                weight <- calc.fo.weights(oldformula, terms[1], ratios[ratio.ii], datas[[data.ii]]) # use original data#
                extras <- make.hyper.rows(terms[1], terms[2], weight, datas[[data.ii]])#
#
                ## Done with this ratio#
                ratio.ii <- ratio.ii + 1#
#
                ## Create indicators for nonhyper, if not already done#
                if (terms[1] %in% data)#
                    data <- replace.factor(terms[1], data, 1, sep=sep)#
#
                data <- combine.data.frames(data, extras)#
            } else {#
                ## Add in the next formula#
                data.ii <- data.ii + 1#
                data <- combine.data.frame(data, datas[[data.ii]])#
            }#
#
            ## Have any of the terms in the formula been factorized?#
            checks <- get.formula.terms(formula)#
            for (check in checks) {#
                if (check %in% names(olddata) && is.factor(olddata[, check]))#
                    formula <- replace.factor.formula(check, formula, data)#
            }#
        }#
    }#
#
    print(head(data))#
    print(tail(data))#
    print(formula)#
    lm(formula, data=data)#
}
hierlm(Sepal.Length ~ Petal.Length + Species + Sepal.Width : Species | Species - ., iris, 1)
#' Replace a factor term#
#'#
#' Constructs indicator terms for a factor variable.#
#'#
#' @param name term name#
#' @param formula formula#
#' @param sep paste sep used to construct factor names#
#' @return Modified formula#
#' @examples#
#' replace.factor.formula("Species", Sepal.Length ~ Species)#
#' replace.factor.formula("Species", Sepal.Length ~ Petal.Length : Species)#
#
replace.factor.formula <- function(name, formula, data, sep="") {#
    terms <- c()#
#
    for (term in get.formula.terms(formula)) {#
        if (term == name) {#
            terms <- c(terms, make.factor.names(name, data))#
        } else if (grepl(':', term)) {#
            subterms <- split.interaction.term(term)#
            if (subterms[1] == name) {#
                terms <- c(terms, paste(make.factor.names(subterms[1], data), subterms[2], sep=':'))#
            } else if (subterms[2] == name) {#
                terms <- c(terms, paste(subterms[1], make.factor.names(subterms[2], data), sep=':'))#
            } else {#
                terms <- c(terms, term)#
            }#
        } else {#
            terms <- c(terms, term)#
        }#
    }#
#
    chunks <- as.character(formula)#
    paste(chunks[2], paste(terms, collapse=" + "), sep=" ~ ")#
}
hierlm(Sepal.Length ~ Petal.Length + Species + Sepal.Width : Species | Species - ., iris, 1)
#' Make a factor name#
#'#
#' Construct a factor name for each level#
#'#
#' @param name the factor to be decomposed#
#' @param data data frame with that as a column#
#' @return Vector of the factor names#
#' @examples#
#' make.factor.names("Species", iris)#
#
make.factor.names <- function(name, data, sep="") {#
    paste(name, unique(data[, name]), sep=sep)#
}
hierlm(Sepal.Length ~ Petal.Length + Species + Sepal.Width : Species | Species - ., iris, 1)
#' Make a factor name#
#'#
#' Construct a factor name for each level#
#'#
#' @param name the factor to be decomposed#
#' @param data data frame with that as a column#
#' @return Vector of the factor names#
#' @examples#
#' make.factor.names("Species", iris)#
#
make.factor.names <- function(name, data, sep="") {#
    print(1)#
    x = paste(name, unique(data[, name]), sep=sep)#
    print(2)#
    x#
}
hierlm(Sepal.Length ~ Petal.Length + Species + Sepal.Width : Species | Species - ., iris, 1)
#' Make a factor name#
#'#
#' Construct a factor name for each level#
#'#
#' @param name the factor to be decomposed#
#' @param data data frame with that as a column#
#' @return Vector of the factor names#
#' @examples#
#' make.factor.names("Species", iris)#
#
make.factor.names <- function(name, data, sep="") {#
    print(names(data))#
    x = paste(name, unique(data[, name]), sep=sep)#
    print(2)#
    x#
}
hierlm(Sepal.Length ~ Petal.Length + Species + Sepal.Width : Species | Species - ., iris, 1)
#' Make a factor name#
#'#
#' Construct a factor name for each level#
#'#
#' @param name the factor to be decomposed#
#' @param data data frame with that as a column#
#' @return Vector of the factor names#
#' @examples#
#' make.factor.names("Species", iris)#
#
make.factor.names <- function(name, data, sep="") {#
    print(name)#
    print(names(data))#
    x = paste(name, unique(data[, name]), sep=sep)#
    print(2)#
    x#
}
hierlm(Sepal.Length ~ Petal.Length + Species + Sepal.Width : Species | Species - ., iris, 1)
#' Replace a factor term#
#'#
#' Constructs indicator terms for a factor variable.#
#'#
#' @param name term name#
#' @param formula formula#
#' @param sep paste sep used to construct factor names#
#' @return Modified formula#
#' @examples#
#' replace.factor.formula("Species", Sepal.Length ~ Species)#
#' replace.factor.formula("Species", Sepal.Length ~ Petal.Length : Species)#
#
replace.factor.formula <- function(name, formula, data, sep="") {#
    print(1)#
    terms <- c()#
#
    for (term in get.formula.terms(formula)) {#
        if (term == name) {#
            terms <- c(terms, make.factor.names(name, data))#
        } else if (grepl(':', term)) {#
            subterms <- split.interaction.term(term)#
            if (subterms[1] == name) {#
                terms <- c(terms, paste(make.factor.names(subterms[1], data), subterms[2], sep=':'))#
            } else if (subterms[2] == name) {#
                terms <- c(terms, paste(subterms[1], make.factor.names(subterms[2], data), sep=':'))#
            } else {#
                terms <- c(terms, term)#
            }#
        } else {#
            terms <- c(terms, term)#
        }#
    }#
#
    chunks <- as.character(formula)#
    print(2)#
    paste(chunks[2], paste(terms, collapse=" + "), sep=" ~ ")#
}
hierlm(Sepal.Length ~ Petal.Length + Species + Sepal.Width : Species | Species - ., iris, 1)
#' Replace a factor term#
#'#
#' Constructs indicator terms for a factor variable.#
#'#
#' @param name term name#
#' @param formula formula#
#' @param sep paste sep used to construct factor names#
#' @return Modified formula#
#' @examples#
#' replace.factor.formula("Species", Sepal.Length ~ Species)#
#' replace.factor.formula("Species", Sepal.Length ~ Petal.Length : Species)#
#
replace.factor.formula <- function(name, formula, data, sep="") {#
    print(1)#
    print(names(data))#
    terms <- c()#
#
    for (term in get.formula.terms(formula)) {#
        if (term == name) {#
            terms <- c(terms, make.factor.names(name, data))#
        } else if (grepl(':', term)) {#
            subterms <- split.interaction.term(term)#
            if (subterms[1] == name) {#
                terms <- c(terms, paste(make.factor.names(subterms[1], data), subterms[2], sep=':'))#
            } else if (subterms[2] == name) {#
                terms <- c(terms, paste(subterms[1], make.factor.names(subterms[2], data), sep=':'))#
            } else {#
                terms <- c(terms, term)#
            }#
        } else {#
            terms <- c(terms, term)#
        }#
    }#
#
    chunks <- as.character(formula)#
    print(2)#
    paste(chunks[2], paste(terms, collapse=" + "), sep=" ~ ")#
}
hierlm(Sepal.Length ~ Petal.Length + Species + Sepal.Width : Species | Species - ., iris, 1)
#' Make a factor name#
#'#
#' Construct a factor name for each level#
#'#
#' @param name the factor to be decomposed#
#' @param data data frame with that as a column#
#' @return Vector of the factor names#
#' @examples#
#' make.factor.names("Species", iris)#
#
make.factor.names <- function(name, data, sep="") {#
    paste(name, unique(data[, name]), sep=sep)#
}
#' Fit an hierarchical model#
#'#
#' Interpret a hierarchical formula and fit it with the given data and weight ratios.#
#'#
#' @param formula an hierlm-style formula#
#' @param datas a data frame or a list of data frames, for each lm-style formula contained in the hierlm#
#' @param ratios a vector a ratios for the effect of fictional#
#'   observations, with length as large as the number of hyper#
#'   expressions.#
#' @return A fitted lm model#
#' @examples#
#' hierlm(Sepal.Length ~ Petal.Length + Species + Sepal.Width : Species | Species - ., iris, 1)#
#' hierlm(Sepal.Length ~ Petal.Length + Species + Sepal.Width : Species | Species - . | Sepal.Width : Species - ., iris, c(1, 2))#
#
hierlm <- function(formula, datas, ratios, sep="") {#
    if (is.data.frame(datas))#
        datas <- list(datas)#
#
    data.ii <- 1#
    ratio.ii <- 1#
#
    data <- datas[[data.ii]]#
#
    ## Split the formula by |#
    labels <- attr(terms(formula), 'term.labels')#
    if (length(labels) == 1) { # otherwise it's just an lm formula#
        lhs <- as.character(formula)[2]#
        chunks <- strsplit(labels, "\\|")[[1]]#
        formula <- as.formula(paste(lhs, "~", chunks[1]), env=attr(formula, '.Environment'))#
        for (chunk in chunks[-1]) {#
            ## Keep these around#
            oldformula <- formula#
            olddata <- data#
#
            ## Make the new formula#
            formula <- combine.formulae(formula, chunk)#
            if (!("constant" %in% names(data)) && "constant" %in% get.formula.terms(formula))#
                data$constant <- 1#
#
            terms <- get.hyper.terms(chunk)#
            if (length(terms) == 3) {#
                ## Build the new relationship#
                weight <- calc.fo.weights(oldformula, terms[1], ratios[ratio.ii], datas[[data.ii]]) # use original data#
                extras <- make.hyper.rows(terms[1], terms[2], weight, datas[[data.ii]])#
#
                ## Done with this ratio#
                ratio.ii <- ratio.ii + 1#
#
                ## Create indicators for nonhyper, if not already done#
                if (terms[1] %in% data)#
                    data <- replace.factor(terms[1], data, 1, sep=sep)#
#
                data <- combine.data.frames(data, extras)#
            } else {#
                ## Add in the next formula#
                data.ii <- data.ii + 1#
                data <- combine.data.frame(data, datas[[data.ii]])#
            }#
#
            ## Have any of the terms in the formula been factorized?#
            checks <- get.formula.terms(formula)#
            for (check in checks) {#
                if (check %in% names(olddata) && is.factor(olddata[, check]))#
                    formula <- replace.factor.formula(check, formula, olddata)#
            }#
        }#
    }#
#
    print(head(data))#
    print(tail(data))#
    print(formula)#
    lm(formula, data=data)#
}
hierlm(Sepal.Length ~ Petal.Length + Species + Sepal.Width : Species | Species - ., iris, 1)
#' Replace a factor term#
#'#
#' Constructs indicator terms for a factor variable.#
#'#
#' @param name term name#
#' @param formula formula#
#' @param sep paste sep used to construct factor names#
#' @return Modified formula#
#' @examples#
#' replace.factor.formula("Species", Sepal.Length ~ Species)#
#' replace.factor.formula("Species", Sepal.Length ~ Petal.Length : Species)#
#
replace.factor.formula <- function(name, formula, data, sep="") {#
    terms <- c()#
#
    for (term in get.formula.terms(formula)) {#
        if (term == name) {#
            terms <- c(terms, make.factor.names(name, data))#
        } else if (grepl(':', term)) {#
            subterms <- split.interaction.term(term)#
            if (subterms[1] == name) {#
                terms <- c(terms, paste(make.factor.names(subterms[1], data), subterms[2], sep=':'))#
            } else if (subterms[2] == name) {#
                terms <- c(terms, paste(subterms[1], make.factor.names(subterms[2], data), sep=':'))#
            } else {#
                terms <- c(terms, term)#
            }#
        } else {#
            terms <- c(terms, term)#
        }#
    }#
#
    chunks <- as.character(formula)#
    paste(chunks[2], paste(terms, collapse=" + "), sep=" ~ ")#
}
hierlm(Sepal.Length ~ Petal.Length + Species + Sepal.Width : Species | Species - ., iris, 1)
#' Split an Interaction Term#
#'#
#' Extract the two pieces of an interaction term#
#'#
#' @param term An interaction (a:b) term#
#' @return Vector of the subterms (c(a, b))#
#' @examples#
#' split.interaction.term("Petal.Length : Species")#
#
split.interaction.term <- function(term) {#
    subterms <- strsplit(term, ":")[[1]]#
    gsub("^\\s+|\\s+$", "", subterms)#
}
hierlm(Sepal.Length ~ Petal.Length + Species + Sepal.Width : Species | Species - ., iris, 1)
summary(hierlm(Sepal.Length ~ Petal.Length + Species + Sepal.Width : Species | Species - ., iris, 1))
summary(hierlm(Sepal.Length ~ 0 + Petal.Length + Species + Sepal.Width : Species | Species - ., iris, 1))
hierlm(Sepal.Length ~ 0 + Petal.Length + Species + Sepal.Width : Species | Species - . | Sepal.Width : Species - ., iris, c(1, 2))
formula = Sepal.Length ~ 0 + Petal.Length + Species + Sepal.Width : Species | Species - . | Sepal.Width : Species - .
datas = iris
ratios = c(1, 2)
if (is.data.frame(datas))#
        datas <- list(datas)#
#
    data.ii <- 1#
    ratio.ii <- 1#
#
    data <- datas[[data.ii]]#
#
    ## Split the formula by |#
    labels <- attr(terms(formula), 'term.labels')#
    if (length(labels) == 1) { # otherwise it's just an lm formula#
        lhs <- as.character(formula)[2]#
        chunks <- strsplit(labels, "\\|")[[1]]#
        formula <- as.formula(paste(lhs, "~", chunks[1]), env=attr(formula, '.Environment'))#
        for (chunk in chunks[-1]) {#
            ## Keep these around#
            oldformula <- formula#
            olddata <- data#
#
            ## Make the new formula#
            formula <- combine.formulae(formula, chunk)#
            if (!("constant" %in% names(data)) && "constant" %in% get.formula.terms(formula))#
                data$constant <- 1#
#
            terms <- get.hyper.terms(chunk)#
            if (length(terms) == 3) {#
                ## Build the new relationship#
                weight <- calc.fo.weights(oldformula, terms[1], ratios[ratio.ii], datas[[data.ii]]) # use original data#
                extras <- make.hyper.rows(terms[1], terms[2], weight, datas[[data.ii]])#
#
                ## Done with this ratio#
                ratio.ii <- ratio.ii + 1#
#
                ## Create indicators for nonhyper, if not already done#
                if (terms[1] %in% data)#
                    data <- replace.factor(terms[1], data, 1, sep=sep)#
#
                data <- combine.data.frames(data, extras)#
            } else {#
                ## Add in the next formula#
                data.ii <- data.ii + 1#
                data <- combine.data.frame(data, datas[[data.ii]])#
            }#
#
            ## Have any of the terms in the formula been factorized?#
            checks <- get.formula.terms(formula)#
            for (check in checks) {#
                if (check %in% names(olddata) && is.factor(olddata[, check]))#
                    formula <- replace.factor.formula(check, formula, olddata)#
            }#
        }#
    }#
#
    print(head(data))#
    print(tail(data))#
    print(formula)#
    lm(formula, data=data)
#' Fit an hierarchical model#
#'#
#' Interpret a hierarchical formula and fit it with the given data and weight ratios.#
#'#
#' @param formula an hierlm-style formula#
#' @param datas a data frame or a list of data frames, for each lm-style formula contained in the hierlm#
#' @param ratios a vector a ratios for the effect of fictional#
#'   observations, with length as large as the number of hyper#
#'   expressions.#
#' @return A fitted lm model#
#' @examples#
#' hierlm(Sepal.Length ~ 0 + Petal.Length + Species + Sepal.Width : Species | Species - ., iris, 1)#
#' hierlm(Sepal.Length ~ 0 + Petal.Length + Species + Sepal.Width : Species | Species - . | Sepal.Width : Species - ., iris, c(1, 2))#
#
hierlm <- function(formula, datas, ratios, sep="") {#
    if (is.data.frame(datas))#
        datas <- list(datas)#
#
    data.ii <- 1#
    ratio.ii <- 1#
#
    data <- datas[[data.ii]]#
#
    ## Split the formula by |#
    labels <- attr(terms(formula), 'term.labels')#
    if (length(labels) == 1) { # otherwise it's just an lm formula#
        lhs <- as.character(formula)[2]#
        chunks <- strsplit(labels, "\\|")[[1]]#
        formula <- as.formula(paste(lhs, "~", chunks[1]), env=attr(formula, '.Environment'))#
        for (chunk in chunks[-1]) {#
            ## Keep these around#
            oldformula <- formula#
            olddata <- data#
#
            ## Make the new formula#
            formula <- combine.formulae(formula, chunk)#
            if (!("constant" %in% names(data)) && "constant" %in% get.formula.terms(formula))#
                data$constant <- 1#
#
            terms <- get.hyper.terms(chunk)#
            if (length(terms) == 3) {#
                ## Build the new relationship#
                weight <- calc.fo.weights(oldformula, terms[1], ratios[ratio.ii], datas[[data.ii]]) # use original data#
                extras <- make.hyper.rows(terms[1], terms[2], weight, datas[[data.ii]])#
#
                ## Done with this ratio#
                ratio.ii <- ratio.ii + 1#
#
                ## Create indicators for nonhyper, if not already done#
                if (terms[1] %in% data)#
                    data <- replace.factor(terms[1], data, 1, sep=sep)#
#
                data <- combine.data.frames(data, extras)#
            } else {#
                ## Add in the next formula#
                data.ii <- data.ii + 1#
                data <- combine.data.frame(data, datas[[data.ii]])#
            }#
#
            ## Have any of the terms in the formula been factorized?#
            checks <- get.formula.terms(formula)#
            for (check in checks) {#
                if (check %in% names(olddata) && is.factor(olddata[, check]))#
                    formula <- replace.factor.formula(check, formula, olddata)#
            }#
        }#
    }#
#
    print(head(data))#
    print(tail(data))#
    print(formula)#
    lm(formula, data=data)#
}
hierlm(Sepal.Length ~ 0 + Petal.Length + Species + Sepal.Width : Species | Species - . | Sepal.Width : Species - ., iris, c(1, 2))
#' Fit an hierarchical model#
#'#
#' Interpret a hierarchical formula and fit it with the given data and weight ratios.#
#'#
#' @param formula an hierlm-style formula#
#' @param datas a data frame or a list of data frames, for each lm-style formula contained in the hierlm#
#' @param ratios a vector a ratios for the effect of fictional#
#'   observations, with length as large as the number of hyper#
#'   expressions.#
#' @return A fitted lm model#
#' @examples#
#' hierlm(Sepal.Length ~ 0 + Petal.Length + Species + Sepal.Width : Species | Species - ., iris, 1)#
#' hierlm(Sepal.Length ~ 0 + Petal.Length + Species + Sepal.Width : Species | Species - . | Sepal.Width : Species - ., iris, c(1, 2))#
#
hierlm <- function(formula, datas, ratios, sep="") {#
    if (is.data.frame(datas))#
        datas <- list(datas)#
#
    data.ii <- 1#
    ratio.ii <- 1#
#
    data <- datas[[data.ii]]#
#
    ## Split the formula by |#
    labels <- attr(terms(formula), 'term.labels')#
    if (length(labels) == 1) { # otherwise it's just an lm formula#
        lhs <- as.character(formula)[2]#
        chunks <- strsplit(labels, "\\|")[[1]]#
        formula <- as.formula(paste(lhs, "~", chunks[1]), env=attr(formula, '.Environment'))#
        for (chunk in chunks[-1]) {#
            print(chunk)#
            ## Keep these around#
            oldformula <- formula#
            olddata <- data#
#
            ## Make the new formula#
            formula <- combine.formulae(formula, chunk)#
            if (!("constant" %in% names(data)) && "constant" %in% get.formula.terms(formula))#
                data$constant <- 1#
#
            terms <- get.hyper.terms(chunk)#
            if (length(terms) == 3) {#
                ## Build the new relationship#
                weight <- calc.fo.weights(oldformula, terms[1], ratios[ratio.ii], datas[[data.ii]]) # use original data#
                extras <- make.hyper.rows(terms[1], terms[2], weight, datas[[data.ii]])#
#
                ## Done with this ratio#
                ratio.ii <- ratio.ii + 1#
#
                ## Create indicators for nonhyper, if not already done#
                if (terms[1] %in% data)#
                    data <- replace.factor(terms[1], data, 1, sep=sep)#
#
                data <- combine.data.frames(data, extras)#
            } else {#
                ## Add in the next formula#
                data.ii <- data.ii + 1#
                data <- combine.data.frame(data, datas[[data.ii]])#
            }#
#
            ## Have any of the terms in the formula been factorized?#
            checks <- get.formula.terms(formula)#
            for (check in checks) {#
                if (check %in% names(olddata) && is.factor(olddata[, check]))#
                    formula <- replace.factor.formula(check, formula, olddata)#
            }#
        }#
    }#
#
    print(head(data))#
    print(tail(data))#
    print(formula)#
    lm(formula, data=data)#
}
hierlm(Sepal.Length ~ 0 + Petal.Length + Species + Sepal.Width : Species | Species - . | Sepal.Width : Species - ., iris, c(1, 2))
#' Fit an hierarchical model#
#'#
#' Interpret a hierarchical formula and fit it with the given data and weight ratios.#
#'#
#' @param formula an hierlm-style formula#
#' @param datas a data frame or a list of data frames, for each lm-style formula contained in the hierlm#
#' @param ratios a vector a ratios for the effect of fictional#
#'   observations, with length as large as the number of hyper#
#'   expressions.#
#' @return A fitted lm model#
#' @examples#
#' hierlm(Sepal.Length ~ 0 + Petal.Length + Species + Sepal.Width : Species | Species - ., iris, 1)#
#' hierlm(Sepal.Length ~ 0 + Petal.Length + Species + Sepal.Width : Species | Species - . | Sepal.Width : Species - ., iris, c(1, 2))#
#
hierlm <- function(formula, datas, ratios, sep="") {#
    if (is.data.frame(datas))#
        datas <- list(datas)#
#
    data.ii <- 1#
    ratio.ii <- 1#
#
    data <- datas[[data.ii]]#
#
    ## Split the formula by |#
    labels <- attr(terms(formula), 'term.labels')#
    if (length(labels) == 1) { # otherwise it's just an lm formula#
        lhs <- as.character(formula)[2]#
        chunks <- strsplit(labels, "\\|")[[1]]#
        formula <- as.formula(paste(lhs, "~", chunks[1]), env=attr(formula, '.Environment'))#
        for (chunk in chunks[-1]) {#
            print(chunk)#
            ## Keep these around#
            oldformula <- formula#
            olddata <- data#
#
            ## Make the new formula#
            formula <- combine.formulae(formula, chunk)#
            if (!("constant" %in% names(data)) && "constant" %in% get.formula.terms(formula))#
                data$constant <- 1#
#
            terms <- get.hyper.terms(chunk)#
            if (length(terms) == 3) {#
                ## Build the new relationship#
                weight <- calc.fo.weights(oldformula, terms[1], ratios[ratio.ii], datas[[data.ii]]) # use original data#
                print("ao")#
                extras <- make.hyper.rows(terms[1], terms[2], weight, datas[[data.ii]])#
#
                ## Done with this ratio#
                ratio.ii <- ratio.ii + 1#
#
                ## Create indicators for nonhyper, if not already done#
                if (terms[1] %in% data)#
                    data <- replace.factor(terms[1], data, 1, sep=sep)#
#
                data <- combine.data.frames(data, extras)#
            } else {#
                ## Add in the next formula#
                data.ii <- data.ii + 1#
                data <- combine.data.frame(data, datas[[data.ii]])#
            }#
#
            ## Have any of the terms in the formula been factorized?#
            checks <- get.formula.terms(formula)#
            for (check in checks) {#
                if (check %in% names(olddata) && is.factor(olddata[, check]))#
                    formula <- replace.factor.formula(check, formula, olddata)#
            }#
        }#
    }#
#
    print(head(data))#
    print(tail(data))#
    print(formula)#
    lm(formula, data=data)#
}
hierlm(Sepal.Length ~ 0 + Petal.Length + Species + Sepal.Width : Species | Species - . | Sepal.Width : Species - ., iris, c(1, 2))
#' Fit an hierarchical model#
#'#
#' Interpret a hierarchical formula and fit it with the given data and weight ratios.#
#'#
#' @param formula an hierlm-style formula#
#' @param datas a data frame or a list of data frames, for each lm-style formula contained in the hierlm#
#' @param ratios a vector a ratios for the effect of fictional#
#'   observations, with length as large as the number of hyper#
#'   expressions.#
#' @return A fitted lm model#
#' @examples#
#' hierlm(Sepal.Length ~ 0 + Petal.Length + Species + Sepal.Width : Species | Species - ., iris, 1)#
#' hierlm(Sepal.Length ~ 0 + Petal.Length + Species + Sepal.Width : Species | Species - . | Sepal.Width : Species - ., iris, c(1, 2))#
#
hierlm <- function(formula, datas, ratios, sep="") {#
    if (is.data.frame(datas))#
        datas <- list(datas)#
#
    data.ii <- 1#
    ratio.ii <- 1#
#
    data <- datas[[data.ii]]#
#
    ## Split the formula by |#
    labels <- attr(terms(formula), 'term.labels')#
    if (length(labels) == 1) { # otherwise it's just an lm formula#
        lhs <- as.character(formula)[2]#
        chunks <- strsplit(labels, "\\|")[[1]]#
        formula <- as.formula(paste(lhs, "~", chunks[1]), env=attr(formula, '.Environment'))#
        for (chunk in chunks[-1]) {#
            print(chunk)#
            ## Keep these around#
            oldformula <- formula#
            olddata <- data#
#
            ## Make the new formula#
            formula <- combine.formulae(formula, chunk)#
            if (!("constant" %in% names(data)) && "constant" %in% get.formula.terms(formula))#
                data$constant <- 1#
#
            terms <- get.hyper.terms(chunk)#
            if (length(terms) == 3) {#
                print("ab")#
                ## Build the new relationship#
                weight <- calc.fo.weights(oldformula, terms[1], ratios[ratio.ii], datas[[data.ii]]) # use original data#
                print("ao")#
                extras <- make.hyper.rows(terms[1], terms[2], weight, datas[[data.ii]])#
#
                ## Done with this ratio#
                ratio.ii <- ratio.ii + 1#
#
                ## Create indicators for nonhyper, if not already done#
                if (terms[1] %in% data)#
                    data <- replace.factor(terms[1], data, 1, sep=sep)#
#
                data <- combine.data.frames(data, extras)#
            } else {#
                ## Add in the next formula#
                data.ii <- data.ii + 1#
                data <- combine.data.frame(data, datas[[data.ii]])#
            }#
#
            ## Have any of the terms in the formula been factorized?#
            checks <- get.formula.terms(formula)#
            for (check in checks) {#
                if (check %in% names(olddata) && is.factor(olddata[, check]))#
                    formula <- replace.factor.formula(check, formula, olddata)#
            }#
        }#
    }#
#
    print(head(data))#
    print(tail(data))#
    print(formula)#
    lm(formula, data=data)#
}
hierlm(Sepal.Length ~ 0 + Petal.Length + Species + Sepal.Width : Species | Species - . | Sepal.Width : Species - ., iris, c(1, 2))
#' Fit an hierarchical model#
#'#
#' Interpret a hierarchical formula and fit it with the given data and weight ratios.#
#'#
#' @param formula an hierlm-style formula#
#' @param datas a data frame or a list of data frames, for each lm-style formula contained in the hierlm#
#' @param ratios a vector a ratios for the effect of fictional#
#'   observations, with length as large as the number of hyper#
#'   expressions.#
#' @return A fitted lm model#
#' @examples#
#' hierlm(Sepal.Length ~ 0 + Petal.Length + Species + Sepal.Width : Species | Species - ., iris, 1)#
#' hierlm(Sepal.Length ~ 0 + Petal.Length + Species + Sepal.Width : Species | Species - . | Sepal.Width : Species - ., iris, c(1, 2))#
#
hierlm <- function(formula, datas, ratios, sep="") {#
    if (is.data.frame(datas))#
        datas <- list(datas)#
#
    data.ii <- 1#
    ratio.ii <- 1#
#
    data <- datas[[data.ii]]#
#
    ## Split the formula by |#
    labels <- attr(terms(formula), 'term.labels')#
    if (length(labels) == 1) { # otherwise it's just an lm formula#
        lhs <- as.character(formula)[2]#
        chunks <- strsplit(labels, "\\|")[[1]]#
        formula <- as.formula(paste(lhs, "~", chunks[1]), env=attr(formula, '.Environment'))#
        for (chunk in chunks[-1]) {#
            print(chunk)#
            ## Keep these around#
            oldformula <- formula#
            olddata <- data#
#
            ## Make the new formula#
            formula <- combine.formulae(formula, chunk)#
            if (!("constant" %in% names(data)) && "constant" %in% get.formula.terms(formula))#
                data$constant <- 1#
#
            print("xx")#
            terms <- get.hyper.terms(chunk)#
            if (length(terms) == 3) {#
                print("ab")#
                ## Build the new relationship#
                weight <- calc.fo.weights(oldformula, terms[1], ratios[ratio.ii], datas[[data.ii]]) # use original data#
                print("ao")#
                extras <- make.hyper.rows(terms[1], terms[2], weight, datas[[data.ii]])#
#
                ## Done with this ratio#
                ratio.ii <- ratio.ii + 1#
#
                ## Create indicators for nonhyper, if not already done#
                if (terms[1] %in% data)#
                    data <- replace.factor(terms[1], data, 1, sep=sep)#
#
                data <- combine.data.frames(data, extras)#
            } else {#
                ## Add in the next formula#
                data.ii <- data.ii + 1#
                data <- combine.data.frame(data, datas[[data.ii]])#
            }#
#
            ## Have any of the terms in the formula been factorized?#
            checks <- get.formula.terms(formula)#
            for (check in checks) {#
                if (check %in% names(olddata) && is.factor(olddata[, check]))#
                    formula <- replace.factor.formula(check, formula, olddata)#
            }#
        }#
    }#
#
    print(head(data))#
    print(tail(data))#
    print(formula)#
    lm(formula, data=data)#
}
hierlm(Sepal.Length ~ 0 + Petal.Length + Species + Sepal.Width : Species | Species - . | Sepal.Width : Species - ., iris, c(1, 2))
#' Fit an hierarchical model#
#'#
#' Interpret a hierarchical formula and fit it with the given data and weight ratios.#
#'#
#' @param formula an hierlm-style formula#
#' @param datas a data frame or a list of data frames, for each lm-style formula contained in the hierlm#
#' @param ratios a vector a ratios for the effect of fictional#
#'   observations, with length as large as the number of hyper#
#'   expressions.#
#' @return A fitted lm model#
#' @examples#
#' hierlm(Sepal.Length ~ 0 + Petal.Length + Species + Sepal.Width : Species | Species - ., iris, 1)#
#' hierlm(Sepal.Length ~ 0 + Petal.Length + Species + Sepal.Width : Species | Species - . | Sepal.Width : Species - ., iris, c(1, 2))#
#
hierlm <- function(formula, datas, ratios, sep="") {#
    if (is.data.frame(datas))#
        datas <- list(datas)#
#
    data.ii <- 1#
    ratio.ii <- 1#
#
    data <- datas[[data.ii]]#
#
    ## Split the formula by |#
    labels <- attr(terms(formula), 'term.labels')#
    if (length(labels) == 1) { # otherwise it's just an lm formula#
        lhs <- as.character(formula)[2]#
        chunks <- strsplit(labels, "\\|")[[1]]#
        formula <- as.formula(paste(lhs, "~", chunks[1]), env=attr(formula, '.Environment'))#
        for (chunk in chunks[-1]) {#
            print(chunk)#
            ## Keep these around#
            oldformula <- formula#
            olddata <- data#
#
            ## Make the new formula#
            formula <- combine.formulae(formula, chunk)#
            print("vv")#
            if (!("constant" %in% names(data)) && "constant" %in% get.formula.terms(formula))#
                data$constant <- 1#
#
            print("xx")#
            terms <- get.hyper.terms(chunk)#
            if (length(terms) == 3) {#
                print("ab")#
                ## Build the new relationship#
                weight <- calc.fo.weights(oldformula, terms[1], ratios[ratio.ii], datas[[data.ii]]) # use original data#
                print("ao")#
                extras <- make.hyper.rows(terms[1], terms[2], weight, datas[[data.ii]])#
#
                ## Done with this ratio#
                ratio.ii <- ratio.ii + 1#
#
                ## Create indicators for nonhyper, if not already done#
                if (terms[1] %in% data)#
                    data <- replace.factor(terms[1], data, 1, sep=sep)#
#
                data <- combine.data.frames(data, extras)#
            } else {#
                ## Add in the next formula#
                data.ii <- data.ii + 1#
                data <- combine.data.frame(data, datas[[data.ii]])#
            }#
#
            ## Have any of the terms in the formula been factorized?#
            checks <- get.formula.terms(formula)#
            for (check in checks) {#
                if (check %in% names(olddata) && is.factor(olddata[, check]))#
                    formula <- replace.factor.formula(check, formula, olddata)#
            }#
        }#
    }#
#
    print(head(data))#
    print(tail(data))#
    print(formula)#
    lm(formula, data=data)#
}
hierlm(Sepal.Length ~ 0 + Petal.Length + Species + Sepal.Width : Species | Species - . | Sepal.Width : Species - ., iris, c(1, 2))
#' Combine two formulas in hierlm-format#
#'#
#' Return the left and right side of a new combined formula.#
#' Left formula must be a standard formula.  Right formula may take the following forms:#
#' y ~ ... : an lm-style formula; the left-hand-side variables much match#
#' f - b : A requirement that two variables be close together (typically one is a factor)#
#' f - . : A requirement that a variable (or set of factors) be close to a new hyper-variable#
#' a : f - [b or .] : A requirement that the results of an interaction be near a hyper-variable#
#' TODO:#
#' a + B : A requirement that the factors in 'a' are similar to eachother by smoothness 'B'#
#'#
#' @param formula1 an lm-style formula#
#' @param formula2 an additional formula or hierlm term#
#' @return Augmented formula#
#' @examples#
#' combine.formulae(combine.formulae(combine.formulae(y ~ a + b, "b - c"), y ~ c + d), "c : d - .")#
#
combine.formulae <- function(formula1, formula2, sep="") {#
    chunks1 <- as.character(formula1)#
#
    if (is.character(formula2))#
        if (grepl("~", formula2))#
            formula2 <- as.formula(formula2)#
#
    if (class(formula2) == "formula") {#
        chunks2 <- as.character(formula2)#
        if (chunks2[2] != chunks1[2])#
            error("Left-hand-side variables do not match.")#
#
        terms1 <- get.formula.terms(formula1)#
        terms2 <- get.formula.terms(formula2)#
    } else {#
        print("yy")#
        terms2 <- get.hyper.terms(formula2, sep=sep)#
        if (length(terms2) != 3)#
            error(paste("Cannot understand expression:", formula2))#
#
        terms2 <- terms2[-3]#
#
        terms1 <- get.formula.terms(formula1)#
        if (attr(terms(formula1), 'intercept') == 0) {#
            if (!("0" %in% terms1))#
                terms1 <- c("0", terms1)#
        } else {#
            if (!("0" %in% terms1 && "constant" %in% terms1))#
                terms1 <- c("0", "constant", terms1)#
        }#
    }#
#
    for (term in terms2)#
        if (!(term %in% terms1))#
            terms1 <- c(terms1, term)#
#
    as.formula(paste(chunks1[2], "~", paste(terms1, collapse=" + ")),#
               env=attr(formula1, '.Environment'))#
}
hierlm(Sepal.Length ~ 0 + Petal.Length + Species + Sepal.Width : Species | Species - . | Sepal.Width : Species - ., iris, c(1, 2))
#' Combine two formulas in hierlm-format#
#'#
#' Return the left and right side of a new combined formula.#
#' Left formula must be a standard formula.  Right formula may take the following forms:#
#' y ~ ... : an lm-style formula; the left-hand-side variables much match#
#' f - b : A requirement that two variables be close together (typically one is a factor)#
#' f - . : A requirement that a variable (or set of factors) be close to a new hyper-variable#
#' a : f - [b or .] : A requirement that the results of an interaction be near a hyper-variable#
#' TODO:#
#' a + B : A requirement that the factors in 'a' are similar to eachother by smoothness 'B'#
#'#
#' @param formula1 an lm-style formula#
#' @param formula2 an additional formula or hierlm term#
#' @return Augmented formula#
#' @examples#
#' combine.formulae(combine.formulae(combine.formulae(y ~ a + b, "b - c"), y ~ c + d), "c : d - .")#
#
combine.formulae <- function(formula1, formula2, sep="") {#
    chunks1 <- as.character(formula1)#
#
    if (is.character(formula2))#
        if (grepl("~", formula2))#
            formula2 <- as.formula(formula2)#
#
    if (class(formula2) == "formula") {#
        chunks2 <- as.character(formula2)#
        if (chunks2[2] != chunks1[2])#
            error("Left-hand-side variables do not match.")#
#
        terms1 <- get.formula.terms(formula1)#
        terms2 <- get.formula.terms(formula2)#
    } else {#
        print("yy")#
        terms2 <- get.hyper.terms(formula2, sep=sep)#
        if (length(terms2) != 3)#
            error(paste("Cannot understand expression:", formula2))#
#
        terms2 <- terms2[-3]#
#
        terms1 <- get.formula.terms(formula1)#
        print("uu")#
        if (attr(terms(formula1), 'intercept') == 0) {#
            if (!("0" %in% terms1))#
                terms1 <- c("0", terms1)#
        } else {#
            if (!("0" %in% terms1 && "constant" %in% terms1))#
                terms1 <- c("0", "constant", terms1)#
        }#
    }#
#
    for (term in terms2)#
        if (!(term %in% terms1))#
            terms1 <- c(terms1, term)#
#
    as.formula(paste(chunks1[2], "~", paste(terms1, collapse=" + ")),#
               env=attr(formula1, '.Environment'))#
}
hierlm(Sepal.Length ~ 0 + Petal.Length + Species + Sepal.Width : Species | Species - . | Sepal.Width : Species - ., iris, c(1, 2))
#' Combine two formulas in hierlm-format#
#'#
#' Return the left and right side of a new combined formula.#
#' Left formula must be a standard formula.  Right formula may take the following forms:#
#' y ~ ... : an lm-style formula; the left-hand-side variables much match#
#' f - b : A requirement that two variables be close together (typically one is a factor)#
#' f - . : A requirement that a variable (or set of factors) be close to a new hyper-variable#
#' a : f - [b or .] : A requirement that the results of an interaction be near a hyper-variable#
#' TODO:#
#' a + B : A requirement that the factors in 'a' are similar to eachother by smoothness 'B'#
#'#
#' @param formula1 an lm-style formula#
#' @param formula2 an additional formula or hierlm term#
#' @return Augmented formula#
#' @examples#
#' combine.formulae(combine.formulae(combine.formulae(y ~ a + b, "b - c"), y ~ c + d), "c : d - .")#
#
combine.formulae <- function(formula1, formula2, sep="") {#
    chunks1 <- as.character(formula1)#
#
    if (is.character(formula2))#
        if (grepl("~", formula2))#
            formula2 <- as.formula(formula2)#
#
    if (class(formula2) == "formula") {#
        chunks2 <- as.character(formula2)#
        if (chunks2[2] != chunks1[2])#
            error("Left-hand-side variables do not match.")#
#
        terms1 <- get.formula.terms(formula1)#
        terms2 <- get.formula.terms(formula2)#
    } else {#
        print("yy")#
        terms2 <- get.hyper.terms(formula2, sep=sep)#
        if (length(terms2) != 3)#
            error(paste("Cannot understand expression:", formula2))#
#
        terms2 <- terms2[-3]#
#
        terms1 <- get.formula.terms(formula1)#
        print("uu")#
        if (attr(terms(formula1), 'intercept') == 0) {#
            if (!("0" %in% terms1))#
                terms1 <- c("0", terms1)#
        } else {#
            if (!("0" %in% terms1 && "constant" %in% terms1))#
                terms1 <- c("0", "constant", terms1)#
        }#
    }#
#
    print("tt")#
    for (term in terms2)#
        if (!(term %in% terms1))#
            terms1 <- c(terms1, term)#
#
    as.formula(paste(chunks1[2], "~", paste(terms1, collapse=" + ")),#
               env=attr(formula1, '.Environment'))#
}
hierlm(Sepal.Length ~ 0 + Petal.Length + Species + Sepal.Width : Species | Species - . | Sepal.Width : Species - ., iris, c(1, 2))
#' Combine two formulas in hierlm-format#
#'#
#' Return the left and right side of a new combined formula.#
#' Left formula must be a standard formula.  Right formula may take the following forms:#
#' y ~ ... : an lm-style formula; the left-hand-side variables much match#
#' f - b : A requirement that two variables be close together (typically one is a factor)#
#' f - . : A requirement that a variable (or set of factors) be close to a new hyper-variable#
#' a : f - [b or .] : A requirement that the results of an interaction be near a hyper-variable#
#' TODO:#
#' a + B : A requirement that the factors in 'a' are similar to eachother by smoothness 'B'#
#'#
#' @param formula1 an lm-style formula#
#' @param formula2 an additional formula or hierlm term#
#' @return Augmented formula#
#' @examples#
#' combine.formulae(combine.formulae(combine.formulae(y ~ a + b, "b - c"), y ~ c + d), "c : d - .")#
#
combine.formulae <- function(formula1, formula2, sep="") {#
    chunks1 <- as.character(formula1)#
#
    if (is.character(formula2))#
        if (grepl("~", formula2))#
            formula2 <- as.formula(formula2)#
#
    if (class(formula2) == "formula") {#
        chunks2 <- as.character(formula2)#
        if (chunks2[2] != chunks1[2])#
            error("Left-hand-side variables do not match.")#
#
        terms1 <- get.formula.terms(formula1)#
        terms2 <- get.formula.terms(formula2)#
    } else {#
        print("yy")#
        terms2 <- get.hyper.terms(formula2, sep=sep)#
        if (length(terms2) != 3)#
            error(paste("Cannot understand expression:", formula2))#
#
        terms2 <- terms2[-3]#
#
        terms1 <- get.formula.terms(formula1)#
        print("uu")#
        if (attr(terms(formula1), 'intercept') == 0) {#
            print("ss")#
            if (!("0" %in% terms1))#
                terms1 <- c("0", terms1)#
        } else {#
            if (!("0" %in% terms1 && "constant" %in% terms1))#
                terms1 <- c("0", "constant", terms1)#
        }#
    }#
#
    print("tt")#
    for (term in terms2)#
        if (!(term %in% terms1))#
            terms1 <- c(terms1, term)#
#
    as.formula(paste(chunks1[2], "~", paste(terms1, collapse=" + ")),#
               env=attr(formula1, '.Environment'))#
}
hierlm(Sepal.Length ~ 0 + Petal.Length + Species + Sepal.Width : Species | Species - . | Sepal.Width : Species - ., iris, c(1, 2))
#' Combine two formulas in hierlm-format#
#'#
#' Return the left and right side of a new combined formula.#
#' Left formula must be a standard formula.  Right formula may take the following forms:#
#' y ~ ... : an lm-style formula; the left-hand-side variables much match#
#' f - b : A requirement that two variables be close together (typically one is a factor)#
#' f - . : A requirement that a variable (or set of factors) be close to a new hyper-variable#
#' a : f - [b or .] : A requirement that the results of an interaction be near a hyper-variable#
#' TODO:#
#' a + B : A requirement that the factors in 'a' are similar to eachother by smoothness 'B'#
#'#
#' @param formula1 an lm-style formula#
#' @param formula2 an additional formula or hierlm term#
#' @return Augmented formula#
#' @examples#
#' combine.formulae(combine.formulae(combine.formulae(y ~ a + b, "b - c"), y ~ c + d), "c : d - .")#
#
combine.formulae <- function(formula1, formula2, sep="") {#
    chunks1 <- as.character(formula1)#
#
    if (is.character(formula2))#
        if (grepl("~", formula2))#
            formula2 <- as.formula(formula2)#
#
    if (class(formula2) == "formula") {#
        chunks2 <- as.character(formula2)#
        if (chunks2[2] != chunks1[2])#
            error("Left-hand-side variables do not match.")#
#
        terms1 <- get.formula.terms(formula1)#
        terms2 <- get.formula.terms(formula2)#
    } else {#
        print("yy")#
        terms2 <- get.hyper.terms(formula2, sep=sep)#
        if (length(terms2) != 3)#
            error(paste("Cannot understand expression:", formula2))#
#
        terms2 <- terms2[-3]#
#
        terms1 <- get.formula.terms(formula1)#
        print("uu")#
        print(attr(terms(formula1), 'intercept'))#
        if (attr(terms(formula1), 'intercept') == 0) {#
            print("ss")#
            if (!("0" %in% terms1))#
                terms1 <- c("0", terms1)#
        } else {#
            if (!("0" %in% terms1 && "constant" %in% terms1))#
                terms1 <- c("0", "constant", terms1)#
        }#
    }#
#
    print("tt")#
    for (term in terms2)#
        if (!(term %in% terms1))#
            terms1 <- c(terms1, term)#
#
    as.formula(paste(chunks1[2], "~", paste(terms1, collapse=" + ")),#
               env=attr(formula1, '.Environment'))#
}
hierlm(Sepal.Length ~ 0 + Petal.Length + Species + Sepal.Width : Species | Species - . | Sepal.Width : Species - ., iris, c(1, 2))
#' Combine two formulas in hierlm-format#
#'#
#' Return the left and right side of a new combined formula.#
#' Left formula must be a standard formula.  Right formula may take the following forms:#
#' y ~ ... : an lm-style formula; the left-hand-side variables much match#
#' f - b : A requirement that two variables be close together (typically one is a factor)#
#' f - . : A requirement that a variable (or set of factors) be close to a new hyper-variable#
#' a : f - [b or .] : A requirement that the results of an interaction be near a hyper-variable#
#' TODO:#
#' a + B : A requirement that the factors in 'a' are similar to eachother by smoothness 'B'#
#'#
#' @param formula1 an lm-style formula#
#' @param formula2 an additional formula or hierlm term#
#' @return Augmented formula#
#' @examples#
#' combine.formulae(combine.formulae(combine.formulae(y ~ a + b, "b - c"), y ~ c + d), "c : d - .")#
#
combine.formulae <- function(formula1, formula2, sep="") {#
    chunks1 <- as.character(formula1)#
#
    if (is.character(formula2))#
        if (grepl("~", formula2))#
            formula2 <- as.formula(formula2)#
#
    if (class(formula2) == "formula") {#
        chunks2 <- as.character(formula2)#
        if (chunks2[2] != chunks1[2])#
            error("Left-hand-side variables do not match.")#
#
        terms1 <- get.formula.terms(formula1)#
        terms2 <- get.formula.terms(formula2)#
    } else {#
        print("yy")#
        terms2 <- get.hyper.terms(formula2, sep=sep)#
        if (length(terms2) != 3)#
            error(paste("Cannot understand expression:", formula2))#
#
        terms2 <- terms2[-3]#
#
        terms1 <- get.formula.terms(formula1)#
        print("uu")#
        print(formula1)#
        print(attr(terms(formula1), 'intercept'))#
        if (attr(terms(formula1), 'intercept') == 0) {#
            print("ss")#
            if (!("0" %in% terms1))#
                terms1 <- c("0", terms1)#
        } else {#
            if (!("0" %in% terms1 && "constant" %in% terms1))#
                terms1 <- c("0", "constant", terms1)#
        }#
    }#
#
    print("tt")#
    for (term in terms2)#
        if (!(term %in% terms1))#
            terms1 <- c(terms1, term)#
#
    as.formula(paste(chunks1[2], "~", paste(terms1, collapse=" + ")),#
               env=attr(formula1, '.Environment'))#
}
hierlm(Sepal.Length ~ 0 + Petal.Length + Species + Sepal.Width : Species | Species - . | Sepal.Width : Species - ., iris, c(1, 2))
#' Combine two formulas in hierlm-format#
#'#
#' Return the left and right side of a new combined formula.#
#' Left formula must be a standard formula.  Right formula may take the following forms:#
#' y ~ ... : an lm-style formula; the left-hand-side variables much match#
#' f - b : A requirement that two variables be close together (typically one is a factor)#
#' f - . : A requirement that a variable (or set of factors) be close to a new hyper-variable#
#' a : f - [b or .] : A requirement that the results of an interaction be near a hyper-variable#
#' TODO:#
#' a + B : A requirement that the factors in 'a' are similar to eachother by smoothness 'B'#
#'#
#' @param formula1 an lm-style formula#
#' @param formula2 an additional formula or hierlm term#
#' @return Augmented formula#
#' @examples#
#' combine.formulae(combine.formulae(combine.formulae(y ~ a + b, "b - c"), y ~ c + d), "c : d - .")#
#
combine.formulae <- function(formula1, formula2, sep="") {#
    chunks1 <- as.character(formula1)#
#
    if (is.character(formula2))#
        if (grepl("~", formula2))#
            formula2 <- as.formula(formula2)#
#
    if (class(formula2) == "formula") {#
        chunks2 <- as.character(formula2)#
        if (chunks2[2] != chunks1[2])#
            error("Left-hand-side variables do not match.")#
#
        terms1 <- get.formula.terms(formula1)#
        terms2 <- get.formula.terms(formula2)#
    } else {#
        print("yy")#
        terms2 <- get.hyper.terms(formula2, sep=sep)#
        if (length(terms2) != 3)#
            error(paste("Cannot understand expression:", formula2))#
#
        terms2 <- terms2[-3]#
#
        terms1 <- get.formula.terms(formula1)#
        print("uu")#
        print(class(formula1))#
        print(attr(terms(formula1), 'intercept'))#
        if (attr(terms(formula1), 'intercept') == 0) {#
            print("ss")#
            if (!("0" %in% terms1))#
                terms1 <- c("0", terms1)#
        } else {#
            if (!("0" %in% terms1 && "constant" %in% terms1))#
                terms1 <- c("0", "constant", terms1)#
        }#
    }#
#
    print("tt")#
    for (term in terms2)#
        if (!(term %in% terms1))#
            terms1 <- c(terms1, term)#
#
    as.formula(paste(chunks1[2], "~", paste(terms1, collapse=" + ")),#
               env=attr(formula1, '.Environment'))#
}
hierlm(Sepal.Length ~ 0 + Petal.Length + Species + Sepal.Width : Species | Species - . | Sepal.Width : Species - ., iris, c(1, 2))
#' Replace a factor term#
#'#
#' Constructs indicator terms for a factor variable.#
#'#
#' @param name term name#
#' @param formula formula#
#' @param sep paste sep used to construct factor names#
#' @return Modified formula#
#' @examples#
#' replace.factor.formula("Species", Sepal.Length ~ Species)#
#' replace.factor.formula("Species", Sepal.Length ~ Petal.Length : Species)#
#
replace.factor.formula <- function(name, formula, data, sep="") {#
    terms <- c()#
#
    for (term in get.formula.terms(formula)) {#
        if (term == name) {#
            terms <- c(terms, make.factor.names(name, data))#
        } else if (grepl(':', term)) {#
            subterms <- split.interaction.term(term)#
            if (subterms[1] == name) {#
                terms <- c(terms, paste(make.factor.names(subterms[1], data), subterms[2], sep=':'))#
            } else if (subterms[2] == name) {#
                terms <- c(terms, paste(subterms[1], make.factor.names(subterms[2], data), sep=':'))#
            } else {#
                terms <- c(terms, term)#
            }#
        } else {#
            terms <- c(terms, term)#
        }#
    }#
#
    chunks <- as.character(formula)#
    as.formula(paste(chunks[2], paste(terms, collapse=" + "), sep=" ~ "))#
}
hierlm(Sepal.Length ~ 0 + Petal.Length + Species + Sepal.Width : Species | Species - . | Sepal.Width : Species - ., iris, c(1, 2))
#' Combine two formulas in hierlm-format#
#'#
#' Return the left and right side of a new combined formula.#
#' Left formula must be a standard formula.  Right formula may take the following forms:#
#' y ~ ... : an lm-style formula; the left-hand-side variables much match#
#' f - b : A requirement that two variables be close together (typically one is a factor)#
#' f - . : A requirement that a variable (or set of factors) be close to a new hyper-variable#
#' a : f - [b or .] : A requirement that the results of an interaction be near a hyper-variable#
#' TODO:#
#' a + B : A requirement that the factors in 'a' are similar to eachother by smoothness 'B'#
#'#
#' @param formula1 an lm-style formula#
#' @param formula2 an additional formula or hierlm term#
#' @return Augmented formula#
#' @examples#
#' combine.formulae(combine.formulae(combine.formulae(y ~ a + b, "b - c"), y ~ c + d), "c : d - .")#
#
combine.formulae <- function(formula1, formula2, sep="") {#
    chunks1 <- as.character(formula1)#
#
    if (is.character(formula2))#
        if (grepl("~", formula2))#
            formula2 <- as.formula(formula2)#
#
    if (class(formula2) == "formula") {#
        chunks2 <- as.character(formula2)#
        if (chunks2[2] != chunks1[2])#
            error("Left-hand-side variables do not match.")#
#
        terms1 <- get.formula.terms(formula1)#
        terms2 <- get.formula.terms(formula2)#
    } else {#
        terms2 <- get.hyper.terms(formula2, sep=sep)#
        if (length(terms2) != 3)#
            error(paste("Cannot understand expression:", formula2))#
#
        terms2 <- terms2[-3]#
#
        terms1 <- get.formula.terms(formula1)#
        if (attr(terms(formula1), 'intercept') == 0) {#
            if (!("0" %in% terms1))#
                terms1 <- c("0", terms1)#
        } else {#
            if (!("0" %in% terms1 && "constant" %in% terms1))#
                terms1 <- c("0", "constant", terms1)#
        }#
    }#
#
    for (term in terms2)#
        if (!(term %in% terms1))#
            terms1 <- c(terms1, term)#
#
    as.formula(paste(chunks1[2], "~", paste(terms1, collapse=" + ")),#
               env=attr(formula1, '.Environment'))#
}
hierlm(Sepal.Length ~ 0 + Petal.Length + Species + Sepal.Width : Species | Species - . | Sepal.Width : Species - ., iris, c(1, 2))
#' Fit an hierarchical model#
#'#
#' Interpret a hierarchical formula and fit it with the given data and weight ratios.#
#'#
#' @param formula an hierlm-style formula#
#' @param datas a data frame or a list of data frames, for each lm-style formula contained in the hierlm#
#' @param ratios a vector a ratios for the effect of fictional#
#'   observations, with length as large as the number of hyper#
#'   expressions.#
#' @return A fitted lm model#
#' @examples#
#' hierlm(Sepal.Length ~ 0 + Petal.Length + Species + Sepal.Width : Species | Species - ., iris, 1)#
#' hierlm(Sepal.Length ~ 0 + Petal.Length + Species + Sepal.Width : Species | Species - . | Sepal.Width : Species - ., iris, c(1, 2))#
#
hierlm <- function(formula, datas, ratios, sep="") {#
    if (is.data.frame(datas))#
        datas <- list(datas)#
#
    data.ii <- 1#
    ratio.ii <- 1#
#
    data <- datas[[data.ii]]#
#
    ## Split the formula by |#
    labels <- attr(terms(formula), 'term.labels')#
    if (length(labels) == 1) { # otherwise it's just an lm formula#
        lhs <- as.character(formula)[2]#
        chunks <- strsplit(labels, "\\|")[[1]]#
        formula <- as.formula(paste(lhs, "~", chunks[1]), env=attr(formula, '.Environment'))#
        ## Keep this for weight calculations#
        oldformula <- formula#
        for (chunk in chunks[-1]) {#
            print(chunk)#
            ## Keep these around#
            olddata <- data#
#
            ## Make the new formula#
            formula <- combine.formulae(formula, chunk)#
            print("vv")#
            if (!("constant" %in% names(data)) && "constant" %in% get.formula.terms(formula))#
                data$constant <- 1#
#
            print("xx")#
#
            terms <- get.hyper.terms(chunk)#
            if (length(terms) == 3) {#
                print("ab")#
                ## Build the new relationship#
                weight <- calc.fo.weights(oldformula, terms[1], ratios[ratio.ii], datas[[data.ii]]) # use original data#
                print("ao")#
                extras <- make.hyper.rows(terms[1], terms[2], weight, datas[[data.ii]])#
#
                ## Done with this ratio#
                ratio.ii <- ratio.ii + 1#
#
                ## Create indicators for nonhyper, if not already done#
                if (terms[1] %in% data)#
                    data <- replace.factor(terms[1], data, 1, sep=sep)#
#
                data <- combine.data.frames(data, extras)#
            } else {#
                ## Add in the next formula#
                data.ii <- data.ii + 1#
                data <- combine.data.frame(data, datas[[data.ii]])#
            }#
#
            ## Have any of the terms in the formula been factorized?#
            checks <- get.formula.terms(formula)#
            for (check in checks) {#
                if (check %in% names(olddata) && is.factor(olddata[, check]))#
                    formula <- replace.factor.formula(check, formula, olddata)#
            }#
        }#
    }#
#
    print(head(data))#
    print(tail(data))#
    print(formula)#
    lm(formula, data=data)#
}
hierlm(Sepal.Length ~ 0 + Petal.Length + Species + Sepal.Width : Species | Species - . | Sepal.Width : Species - ., iris, c(1, 2))
#' Fit an hierarchical model#
#'#
#' Interpret a hierarchical formula and fit it with the given data and weight ratios.#
#'#
#' @param formula an hierlm-style formula#
#' @param datas a data frame or a list of data frames, for each lm-style formula contained in the hierlm#
#' @param ratios a vector a ratios for the effect of fictional#
#'   observations, with length as large as the number of hyper#
#'   expressions.#
#' @return A fitted lm model#
#' @examples#
#' hierlm(Sepal.Length ~ 0 + Petal.Length + Species + Sepal.Width : Species | Species - ., iris, 1)#
#' hierlm(Sepal.Length ~ 0 + Petal.Length + Species + Sepal.Width : Species | Species - . | Sepal.Width : Species - ., iris, c(1, 2))#
#
hierlm <- function(formula, datas, ratios, sep="") {#
    if (is.data.frame(datas))#
        datas <- list(datas)#
#
    data.ii <- 1#
    ratio.ii <- 1#
#
    data <- datas[[data.ii]]#
#
    ## Split the formula by |#
    labels <- attr(terms(formula), 'term.labels')#
    if (length(labels) == 1) { # otherwise it's just an lm formula#
        lhs <- as.character(formula)[2]#
        chunks <- strsplit(labels, "\\|")[[1]]#
        formula <- as.formula(paste(lhs, "~", chunks[1]), env=attr(formula, '.Environment'))#
        ## Keep this for weight calculations#
        oldformula <- formula#
        for (chunk in chunks[-1]) {#
            print(chunk)#
            ## Keep these around#
            olddata <- data#
#
            ## Make the new formula#
            formula <- combine.formulae(formula, chunk)#
            print("vv")#
            if (!("constant" %in% names(data)) && "constant" %in% get.formula.terms(formula))#
                data$constant <- 1#
#
            print("xx")#
#
            terms <- get.hyper.terms(chunk)#
            if (length(terms) == 3) {#
                print("ab")#
                ## Build the new relationship#
                weight <- calc.fo.weights(oldformula, terms[1], ratios[ratio.ii], datas[[data.ii]]) # use original data#
                print("ao")#
                print(terms)#
                extras <- make.hyper.rows(terms[1], terms[2], weight, datas[[data.ii]])#
#
                ## Done with this ratio#
                ratio.ii <- ratio.ii + 1#
#
                ## Create indicators for nonhyper, if not already done#
                if (terms[1] %in% data)#
                    data <- replace.factor(terms[1], data, 1, sep=sep)#
#
                data <- combine.data.frames(data, extras)#
            } else {#
                ## Add in the next formula#
                data.ii <- data.ii + 1#
                data <- combine.data.frame(data, datas[[data.ii]])#
            }#
#
            ## Have any of the terms in the formula been factorized?#
            checks <- get.formula.terms(formula)#
            for (check in checks) {#
                if (check %in% names(olddata) && is.factor(olddata[, check]))#
                    formula <- replace.factor.formula(check, formula, olddata)#
            }#
        }#
    }#
#
    print(head(data))#
    print(tail(data))#
    print(formula)#
    lm(formula, data=data)#
}
hierlm(Sepal.Length ~ 0 + Petal.Length + Species + Sepal.Width : Species | Species - . | Sepal.Width : Species - ., iris, c(1, 2))
make.hyper.rows("Species", "hyperSpecies", 5, iris)
#' Get any new hyper terms from formula#
#'#
#' If the "a - b" formula requires the creation of a new hyper terms#
#' (one of a or b is .), return them.#
#'#
#' @param formula Single component of a hierlm formula#
#' @return Vector of c(nonhyper, hyper, is.interaction), if a new one was created;#
#'   or c(left, right, NA) if both terms are given;#
#'   or c() if not an "a - b" expression#
#' @examples#
#' get.hyper.terms(Sepal.Length ~ Petal.Length + Species + Sepal.Width : Species)#
#
get.hyper.terms <- function(formula, sep="") {#
    if (class(formula) == "formula")#
        return(c())#
#
    terms <- strsplit(formula, "-")[[1]]#
    if (length(terms) != 2)#
        return(c())#
#
    terms <- gsub("^\\s+|\\s+$", "", terms)#
    if ("." %in% terms) {#
        nonhyper <- terms[terms != "."]#
        if (grepl(':', nonhyper)) {#
            subterms <- split.interaction.term(nonhyper)#
            hyper <- paste("hyper", paste(subterms, collapse=sep), sep=sep)#
            return(c(nonhyper, hyper, T))#
        } else {#
            hyper <- paste("hyper", nonhyper, sep=sep)#
            return(c(nonhyper, hyper, F))#
        }#
    }#
    return(c(terms, NA))#
}
get.hyper.terms(Sepal.Length ~ Petal.Length + Species + Sepal.Width : Species)
#' Create fictional observations for a hyper relationship#
#'#
#' Return a data frame with fictional observations#
#'#
#' @param nonhyper name of the non-hyper column#
#' @param hyper name of the hyper column#
#' @param weight weight to be used in the rows#
#' @param data a data frame for inspecting levels#
#' @return Fictional observations in a data frame#
#' @examples#
#' make.hyper.rows("Species", "hyperSpecies", 5, iris)#
#
make.hyper.rows <- function(nonhyper, hyper, weight, data, sep="") {#
    if (grepl(':', nonhyper)) {#
        for (subterm in split.interaction.term(nonhyper)) {#
            if (!is.numeric(data[, subterm]))#
                return(make.hyper.rows(subterm, hyper))#
        }#
    } else {#
        ## Construct extra from diagonal factor matrix#
        extras <- diag(weight, length(unique(data[, nonhyper])))#
        extras <- as.data.frame(extras)#
#
        names(extras) <- paste(nonhyper, unique(data[, nonhyper]), sep=sep)#
#
        ## Add in the hyper column#
        extras[, hyper] <- -weight#
#
        extras#
    }#
}
hierlm(Sepal.Length ~ 0 + Petal.Length + Species + Sepal.Width : Species | Species - . | Sepal.Width : Species - ., iris, c(1, 2))
#' Create fictional observations for a hyper relationship#
#'#
#' Return a data frame with fictional observations#
#'#
#' @param nonhyper name of the non-hyper column#
#' @param hyper name of the hyper column#
#' @param weight weight to be used in the rows#
#' @param data a data frame for inspecting levels#
#' @return Fictional observations in a data frame#
#' @examples#
#' make.hyper.rows("Species", "hyperSpecies", 5, iris)#
#
make.hyper.rows <- function(nonhyper, hyper, weight, data, sep="") {#
    if (grepl(':', nonhyper)) {#
        for (subterm in split.interaction.term(nonhyper)) {#
            if (!is.numeric(data[, subterm]))#
                return(make.hyper.rows(subterm, hyper, weight, data))#
        }#
    } else {#
        ## Construct extra from diagonal factor matrix#
        extras <- diag(weight, length(unique(data[, nonhyper])))#
        extras <- as.data.frame(extras)#
#
        names(extras) <- paste(nonhyper, unique(data[, nonhyper]), sep=sep)#
#
        ## Add in the hyper column#
        extras[, hyper] <- -weight#
#
        extras#
    }#
}
hierlm(Sepal.Length ~ 0 + Petal.Length + Species + Sepal.Width : Species | Species - . | Sepal.Width : Species - ., iris, c(1, 2))
#' Fit an hierarchical model#
#'#
#' Interpret a hierarchical formula and fit it with the given data and weight ratios.#
#'#
#' @param formula an hierlm-style formula#
#' @param datas a data frame or a list of data frames, for each lm-style formula contained in the hierlm#
#' @param ratios a vector a ratios for the effect of fictional#
#'   observations, with length as large as the number of hyper#
#'   expressions.#
#' @return A fitted lm model#
#' @examples#
#' hierlm(Sepal.Length ~ 0 + Petal.Length + Species + Sepal.Width : Species | Species - ., iris, 1)#
#' hierlm(Sepal.Length ~ 0 + Petal.Length + Species + Sepal.Width : Species | Species - . | Sepal.Width : Species - ., iris, c(1, 2))#
#
hierlm <- function(formula, datas, ratios, sep="") {#
    if (is.data.frame(datas))#
        datas <- list(datas)#
#
    data.ii <- 1#
    ratio.ii <- 1#
#
    data <- datas[[data.ii]]#
#
    ## Split the formula by |#
    labels <- attr(terms(formula), 'term.labels')#
    if (length(labels) == 1) { # otherwise it's just an lm formula#
        lhs <- as.character(formula)[2]#
        chunks <- strsplit(labels, "\\|")[[1]]#
        formula <- as.formula(paste(lhs, "~", chunks[1]), env=attr(formula, '.Environment'))#
        ## Keep this for weight calculations#
        oldformula <- formula#
        for (chunk in chunks[-1]) {#
            print(chunk)#
            ## Keep these around#
            olddata <- data#
#
            ## Make the new formula#
            formula <- combine.formulae(formula, chunk)#
            print("vv")#
            if (!("constant" %in% names(data)) && "constant" %in% get.formula.terms(formula))#
                data$constant <- 1#
#
            print("xx")#
#
            terms <- get.hyper.terms(chunk)#
            if (length(terms) == 3) {#
                print("ab")#
                ## Build the new relationship#
                weight <- calc.fo.weights(oldformula, terms[1], ratios[ratio.ii], datas[[data.ii]]) # use original data#
                print("ao")#
                print(terms)#
                extras <- make.hyper.rows(terms[1], terms[2], weight, datas[[data.ii]])#
#
                ## Done with this ratio#
                ratio.ii <- ratio.ii + 1#
#
                ## Create indicators for nonhyper, if not already done#
                if (terms[1] %in% data)#
                    data <- replace.factor(terms[1], data, 1, sep=sep)#
#
                data <- combine.data.frames(data, extras)#
            } else {#
                ## Add in the next formula#
                data.ii <- data.ii + 1#
                data <- combine.data.frame(data, datas[[data.ii]])#
            }#
#
            ## Have any of the terms in the formula been factorized?#
            checks <- get.formula.terms(formula)#
            for (check in checks) {#
                if (check %in% names(olddata) && !is.character(olddata[, check]))#
                    formula <- replace.factor.formula(check, formula, olddata)#
            }#
        }#
    }#
#
    print(head(data))#
    print(tail(data))#
    print(formula)#
    lm(formula, data=data)#
}
hierlm(Sepal.Length ~ 0 + Petal.Length + Species + Sepal.Width : Species | Species - . | Sepal.Width : Species - ., iris, c(1, 2))
#' Fit an hierarchical model#
#'#
#' Interpret a hierarchical formula and fit it with the given data and weight ratios.#
#'#
#' @param formula an hierlm-style formula#
#' @param datas a data frame or a list of data frames, for each lm-style formula contained in the hierlm#
#' @param ratios a vector a ratios for the effect of fictional#
#'   observations, with length as large as the number of hyper#
#'   expressions.#
#' @return A fitted lm model#
#' @examples#
#' hierlm(Sepal.Length ~ 0 + Petal.Length + Species + Sepal.Width : Species | Species - ., iris, 1)#
#' hierlm(Sepal.Length ~ 0 + Petal.Length + Species + Sepal.Width : Species | Species - . | Sepal.Width : Species - ., iris, c(1, 2))#
#
hierlm <- function(formula, datas, ratios, sep="") {#
    if (is.data.frame(datas))#
        datas <- list(datas)#
#
    data.ii <- 1#
    ratio.ii <- 1#
#
    data <- datas[[data.ii]]#
#
    ## Split the formula by |#
    labels <- attr(terms(formula), 'term.labels')#
    if (length(labels) == 1) { # otherwise it's just an lm formula#
        lhs <- as.character(formula)[2]#
        chunks <- strsplit(labels, "\\|")[[1]]#
        formula <- as.formula(paste(lhs, "~", chunks[1]), env=attr(formula, '.Environment'))#
        ## Keep this for weight calculations#
        oldformula <- formula#
        for (chunk in chunks[-1]) {#
            print(chunk)#
            ## Keep these around#
            olddata <- data#
#
            ## Make the new formula#
            formula <- combine.formulae(formula, chunk)#
            print("vv")#
            if (!("constant" %in% names(data)) && "constant" %in% get.formula.terms(formula))#
                data$constant <- 1#
#
            print("xx")#
#
            terms <- get.hyper.terms(chunk)#
            if (length(terms) == 3) {#
                print("ab")#
                ## Build the new relationship#
                weight <- calc.fo.weights(oldformula, terms[1], ratios[ratio.ii], datas[[data.ii]]) # use original data#
                print("ao")#
                print(terms)#
                extras <- make.hyper.rows(terms[1], terms[2], weight, datas[[data.ii]])#
#
                ## Done with this ratio#
                ratio.ii <- ratio.ii + 1#
#
                ## Create indicators for nonhyper, if not already done#
                if (terms[1] %in% data)#
                    data <- replace.factor(terms[1], data, 1, sep=sep)#
#
                data <- combine.data.frames(data, extras)#
            } else {#
                ## Add in the next formula#
                data.ii <- data.ii + 1#
                data <- combine.data.frame(data, datas[[data.ii]])#
            }#
#
            ## Have any of the terms in the formula been factorized?#
            checks <- get.formula.terms(formula)#
            for (check in checks) {#
                if (check %in% names(olddata) && !is.numeric(olddata[, check]))#
                    formula <- replace.factor.formula(check, formula, olddata)#
            }#
        }#
    }#
#
    print(head(data))#
    print(tail(data))#
    print(formula)#
    lm(formula, data=data)#
}
hierlm(Sepal.Length ~ 0 + Petal.Length + Species + Sepal.Width : Species | Species - . | Sepal.Width : Species - ., iris, c(1, 2))
#' Fit an hierarchical model#
#'#
#' Interpret a hierarchical formula and fit it with the given data and weight ratios.#
#'#
#' @param formula an hierlm-style formula#
#' @param datas a data frame or a list of data frames, for each lm-style formula contained in the hierlm#
#' @param ratios a vector a ratios for the effect of fictional#
#'   observations, with length as large as the number of hyper#
#'   expressions.#
#' @return A fitted lm model#
#' @examples#
#' hierlm(Sepal.Length ~ 0 + Petal.Length + Species + Sepal.Width : Species | Species - ., iris, 1)#
#' hierlm(Sepal.Length ~ 0 + Petal.Length + Species + Sepal.Width : Species | Species - . | Sepal.Width : Species - ., iris, c(1, 2))#
#
hierlm <- function(formula, datas, ratios, sep="") {#
    if (is.data.frame(datas))#
        datas <- list(datas)#
#
    data.ii <- 1#
    ratio.ii <- 1#
#
    data <- datas[[data.ii]]#
#
    ## Split the formula by |#
    labels <- attr(terms(formula), 'term.labels')#
    if (length(labels) == 1) { # otherwise it's just an lm formula#
        lhs <- as.character(formula)[2]#
        chunks <- strsplit(labels, "\\|")[[1]]#
        formula <- as.formula(paste(lhs, "~", chunks[1]), env=attr(formula, '.Environment'))#
        ## Keep this for weight calculations#
        oldformula <- formula#
        for (chunk in chunks[-1]) {#
            print(chunk)#
            ## Keep these around#
            olddata <- data#
#
            ## Make the new formula#
            formula <- combine.formulae(formula, chunk)#
            print("vv")#
            if (!("constant" %in% names(data)) && "constant" %in% get.formula.terms(formula))#
                data$constant <- 1#
#
            print("xx")#
#
            terms <- get.hyper.terms(chunk)#
            if (length(terms) == 3) {#
                print("ab")#
                ## Build the new relationship#
                weight <- calc.fo.weights(oldformula, terms[1], ratios[ratio.ii], datas[[data.ii]]) # use original data#
                print("ao")#
                print(terms)#
                extras <- make.hyper.rows(terms[1], terms[2], weight, datas[[data.ii]])#
#
                ## Done with this ratio#
                ratio.ii <- ratio.ii + 1#
#
                ## Create indicators for nonhyper, if not already done#
                if (terms[1] %in% data)#
                    data <- replace.factor(terms[1], data, 1, sep=sep)#
#
                data <- combine.data.frames(data, extras)#
            } else {#
                ## Add in the next formula#
                data.ii <- data.ii + 1#
                data <- combine.data.frame(data, datas[[data.ii]])#
            }#
#
            ## Have any of the terms in the formula been factorized?#
            checks <- get.formula.terms(formula)#
            for (check in checks) {#
                if (grepl(':', check)) {#
                    for (subterm in split.interaction.term(check))#
                        if (subterm %in% names(oldata) && !(subterm %in% names(data)) && !is.numeric(olddata[, check]))#
                            formula <- replace.factor.formula(subterm, formula, olddata)#
                } else {#
                    if (check %in% names(olddata) && !(check %in% names(data)) && !is.numeric(olddata[, check]))#
                        formula <- replace.factor.formula(check, formula, olddata)#
                }#
            }#
        }#
    }#
#
    print(head(data))#
    print(tail(data))#
    print(formula)#
    lm(formula, data=data)#
}
hierlm(Sepal.Length ~ 0 + Petal.Length + Species + Sepal.Width : Species | Species - . | Sepal.Width : Species - ., iris, c(1, 2))
#' Fit an hierarchical model#
#'#
#' Interpret a hierarchical formula and fit it with the given data and weight ratios.#
#'#
#' @param formula an hierlm-style formula#
#' @param datas a data frame or a list of data frames, for each lm-style formula contained in the hierlm#
#' @param ratios a vector a ratios for the effect of fictional#
#'   observations, with length as large as the number of hyper#
#'   expressions.#
#' @return A fitted lm model#
#' @examples#
#' hierlm(Sepal.Length ~ 0 + Petal.Length + Species + Sepal.Width : Species | Species - ., iris, 1)#
#' hierlm(Sepal.Length ~ 0 + Petal.Length + Species + Sepal.Width : Species | Species - . | Sepal.Width : Species - ., iris, c(1, 2))#
#
hierlm <- function(formula, datas, ratios, sep="") {#
    if (is.data.frame(datas))#
        datas <- list(datas)#
#
    data.ii <- 1#
    ratio.ii <- 1#
#
    data <- datas[[data.ii]]#
#
    ## Split the formula by |#
    labels <- attr(terms(formula), 'term.labels')#
    if (length(labels) == 1) { # otherwise it's just an lm formula#
        lhs <- as.character(formula)[2]#
        chunks <- strsplit(labels, "\\|")[[1]]#
        formula <- as.formula(paste(lhs, "~", chunks[1]), env=attr(formula, '.Environment'))#
        ## Keep this for weight calculations#
        oldformula <- formula#
        for (chunk in chunks[-1]) {#
            print(chunk)#
            ## Keep these around#
            olddata <- data#
#
            ## Make the new formula#
            formula <- combine.formulae(formula, chunk)#
            print("vv")#
            if (!("constant" %in% names(data)) && "constant" %in% get.formula.terms(formula))#
                data$constant <- 1#
#
            print("xx")#
#
            terms <- get.hyper.terms(chunk)#
            if (length(terms) == 3) {#
                print("ab")#
                ## Build the new relationship#
                weight <- calc.fo.weights(oldformula, terms[1], ratios[ratio.ii], datas[[data.ii]]) # use original data#
                print("ao")#
                print(terms)#
                extras <- make.hyper.rows(terms[1], terms[2], weight, datas[[data.ii]])#
#
                ## Done with this ratio#
                ratio.ii <- ratio.ii + 1#
#
                ## Create indicators for nonhyper, if not already done#
                if (terms[1] %in% data)#
                    data <- replace.factor(terms[1], data, 1, sep=sep)#
#
                data <- combine.data.frames(data, extras)#
            } else {#
                ## Add in the next formula#
                data.ii <- data.ii + 1#
                data <- combine.data.frame(data, datas[[data.ii]])#
            }#
#
            ## Have any of the terms in the formula been factorized?#
            checks <- get.formula.terms(formula)#
            for (check in checks) {#
                if (grepl(':', check)) {#
                    for (subterm in split.interaction.term(check))#
                        if (subterm %in% names(olddata) && !(subterm %in% names(data)) && !is.numeric(olddata[, check]))#
                            formula <- replace.factor.formula(subterm, formula, olddata)#
                } else {#
                    if (check %in% names(olddata) && !(check %in% names(data)) && !is.numeric(olddata[, check]))#
                        formula <- replace.factor.formula(check, formula, olddata)#
                }#
            }#
        }#
    }#
#
    print(head(data))#
    print(tail(data))#
    print(formula)#
    lm(formula, data=data)#
}
hierlm(Sepal.Length ~ 0 + Petal.Length + Species + Sepal.Width : Species | Species - . | Sepal.Width : Species - ., iris, c(1, 2))
#' Fit an hierarchical model#
#'#
#' Interpret a hierarchical formula and fit it with the given data and weight ratios.#
#'#
#' @param formula an hierlm-style formula#
#' @param datas a data frame or a list of data frames, for each lm-style formula contained in the hierlm#
#' @param ratios a vector a ratios for the effect of fictional#
#'   observations, with length as large as the number of hyper#
#'   expressions.#
#' @return A fitted lm model#
#' @examples#
#' hierlm(Sepal.Length ~ 0 + Petal.Length + Species + Sepal.Width : Species | Species - ., iris, 1)#
#' hierlm(Sepal.Length ~ 0 + Petal.Length + Species + Sepal.Width : Species | Species - . | Sepal.Width : Species - ., iris, c(1, 2))#
#
hierlm <- function(formula, datas, ratios, sep="") {#
    if (is.data.frame(datas))#
        datas <- list(datas)#
#
    data.ii <- 1#
    ratio.ii <- 1#
#
    data <- datas[[data.ii]]#
#
    ## Split the formula by |#
    labels <- attr(terms(formula), 'term.labels')#
    if (length(labels) == 1) { # otherwise it's just an lm formula#
        lhs <- as.character(formula)[2]#
        chunks <- strsplit(labels, "\\|")[[1]]#
        formula <- as.formula(paste(lhs, "~", chunks[1]), env=attr(formula, '.Environment'))#
        ## Keep this for weight calculations#
        oldformula <- formula#
        for (chunk in chunks[-1]) {#
            print(chunk)#
            ## Keep these around#
            olddata <- data#
#
            ## Make the new formula#
            formula <- combine.formulae(formula, chunk)#
            print("vv")#
            if (!("constant" %in% names(data)) && "constant" %in% get.formula.terms(formula))#
                data$constant <- 1#
#
            print("xx")#
#
            terms <- get.hyper.terms(chunk)#
            if (length(terms) == 3) {#
                print("ab")#
                ## Build the new relationship#
                weight <- calc.fo.weights(oldformula, terms[1], ratios[ratio.ii], datas[[data.ii]]) # use original data#
                print("ao")#
                print(terms)#
                extras <- make.hyper.rows(terms[1], terms[2], weight, datas[[data.ii]])#
#
                ## Done with this ratio#
                ratio.ii <- ratio.ii + 1#
#
                ## Create indicators for nonhyper, if not already done#
                if (terms[1] %in% data)#
                    data <- replace.factor(terms[1], data, 1, sep=sep)#
#
                data <- combine.data.frames(data, extras)#
            } else {#
                ## Add in the next formula#
                data.ii <- data.ii + 1#
                data <- combine.data.frame(data, datas[[data.ii]])#
            }#
#
            ## Have any of the terms in the formula been factorized?#
            checks <- get.formula.terms(formula)#
            for (check in checks) {#
                if (grepl(':', check)) {#
                    for (subterm in split.interaction.term(check))#
                        if (subterm %in% names(olddata) && !(subterm %in% names(data)) && !is.numeric(olddata[, subterm]))#
                            formula <- replace.factor.formula(subterm, formula, olddata)#
                } else {#
                    if (check %in% names(olddata) && !(check %in% names(data)) && !is.numeric(olddata[, check]))#
                        formula <- replace.factor.formula(check, formula, olddata)#
                }#
            }#
        }#
    }#
#
    print(head(data))#
    print(tail(data))#
    print(formula)#
    lm(formula, data=data)#
}
hierlm(Sepal.Length ~ 0 + Petal.Length + Species + Sepal.Width : Species | Species - . | Sepal.Width : Species - ., iris, c(1, 2))
#' Fit an hierarchical model#
#'#
#' Interpret a hierarchical formula and fit it with the given data and weight ratios.#
#'#
#' @param formula an hierlm-style formula#
#' @param datas a data frame or a list of data frames, for each lm-style formula contained in the hierlm#
#' @param ratios a vector a ratios for the effect of fictional#
#'   observations, with length as large as the number of hyper#
#'   expressions.#
#' @return A fitted lm model#
#' @examples#
#' hierlm(Sepal.Length ~ 0 + Petal.Length + Species + Sepal.Width : Species | Species - ., iris, 1)#
#' hierlm(Sepal.Length ~ 0 + Petal.Length + Species + Sepal.Width : Species | Species - . | Sepal.Width : Species - ., iris, c(1, 2))#
#
hierlm <- function(formula, datas, ratios, sep="") {#
    if (is.data.frame(datas))#
        datas <- list(datas)#
#
    data.ii <- 1#
    ratio.ii <- 1#
#
    data <- datas[[data.ii]]#
#
    ## Split the formula by |#
    labels <- attr(terms(formula), 'term.labels')#
    if (length(labels) == 1) { # otherwise it's just an lm formula#
        lhs <- as.character(formula)[2]#
        chunks <- strsplit(labels, "\\|")[[1]]#
        formula <- as.formula(paste(lhs, "~", chunks[1]), env=attr(formula, '.Environment'))#
        ## Keep this for weight calculations#
        oldformula <- formula#
        for (chunk in chunks[-1]) {#
            ## Keep these around#
            olddata <- data#
#
            ## Make the new formula#
            formula <- combine.formulae(formula, chunk)#
            if (!("constant" %in% names(data)) && "constant" %in% get.formula.terms(formula))#
                data$constant <- 1#
#
            terms <- get.hyper.terms(chunk)#
            if (length(terms) == 3) {#
                ## Build the new relationship#
                weight <- calc.fo.weights(oldformula, terms[1], ratios[ratio.ii], datas[[data.ii]]) # use original data#
                extras <- make.hyper.rows(terms[1], terms[2], weight, datas[[data.ii]])#
#
                ## Done with this ratio#
                ratio.ii <- ratio.ii + 1#
#
                ## Create indicators for nonhyper, if not already done#
                if (terms[1] %in% data)#
                    data <- replace.factor(terms[1], data, 1, sep=sep)#
#
                data <- combine.data.frames(data, extras)#
            } else {#
                ## Add in the next formula#
                data.ii <- data.ii + 1#
                data <- combine.data.frame(data, datas[[data.ii]])#
            }#
#
            ## Have any of the terms in the formula been factorized?#
            checks <- get.formula.terms(formula)#
            for (check in checks) {#
                if (grepl(':', check)) {#
                    for (subterm in split.interaction.term(check))#
                        if (subterm %in% names(olddata) && !(subterm %in% names(data)) && !is.numeric(olddata[, subterm])) {#
                            print(subterm)#
                            formula <- replace.factor.formula(subterm, formula, olddata)#
                            print(formula)#
                        }#
                } else {#
                    if (check %in% names(olddata) && !(check %in% names(data)) && !is.numeric(olddata[, check]))#
                        formula <- replace.factor.formula(check, formula, olddata)#
                }#
            }#
        }#
    }#
#
    print(head(data))#
    print(tail(data))#
    print(formula)#
    lm(formula, data=data)#
}
hierlm(Sepal.Length ~ 0 + Petal.Length + Species + Sepal.Width : Species | Species - . | Sepal.Width : Species - ., iris, c(1, 2))
#' Fit an hierarchical model#
#'#
#' Interpret a hierarchical formula and fit it with the given data and weight ratios.#
#'#
#' @param formula an hierlm-style formula#
#' @param datas a data frame or a list of data frames, for each lm-style formula contained in the hierlm#
#' @param ratios a vector a ratios for the effect of fictional#
#'   observations, with length as large as the number of hyper#
#'   expressions.#
#' @return A fitted lm model#
#' @examples#
#' hierlm(Sepal.Length ~ 0 + Petal.Length + Species + Sepal.Width : Species | Species - ., iris, 1)#
#' hierlm(Sepal.Length ~ 0 + Petal.Length + Species + Sepal.Width : Species | Species - . | Sepal.Width : Species - ., iris, c(1, 2))#
#
hierlm <- function(formula, datas, ratios, sep="") {#
    if (is.data.frame(datas))#
        datas <- list(datas)#
#
    data.ii <- 1#
    ratio.ii <- 1#
#
    data <- datas[[data.ii]]#
#
    ## Split the formula by |#
    labels <- attr(terms(formula), 'term.labels')#
    if (length(labels) == 1) { # otherwise it's just an lm formula#
        lhs <- as.character(formula)[2]#
        chunks <- strsplit(labels, "\\|")[[1]]#
        formula <- as.formula(paste(lhs, "~", chunks[1]), env=attr(formula, '.Environment'))#
        ## Keep this for weight calculations#
        oldformula <- formula#
        for (chunk in chunks[-1]) {#
            ## Keep these around#
            olddata <- data#
#
            ## Make the new formula#
            formula <- combine.formulae(formula, chunk)#
            if (!("constant" %in% names(data)) && "constant" %in% get.formula.terms(formula))#
                data$constant <- 1#
#
            terms <- get.hyper.terms(chunk)#
            if (length(terms) == 3) {#
                ## Build the new relationship#
                weight <- calc.fo.weights(oldformula, terms[1], ratios[ratio.ii], datas[[data.ii]]) # use original data#
                extras <- make.hyper.rows(terms[1], terms[2], weight, datas[[data.ii]])#
#
                ## Done with this ratio#
                ratio.ii <- ratio.ii + 1#
#
                ## Create indicators for nonhyper, if not already done#
                if (terms[1] %in% data)#
                    data <- replace.factor(terms[1], data, 1, sep=sep)#
#
                data <- combine.data.frames(data, extras)#
            } else {#
                ## Add in the next formula#
                data.ii <- data.ii + 1#
                data <- combine.data.frame(data, datas[[data.ii]])#
            }#
#
            ## Have any of the terms in the formula been factorized?#
            print("checking")#
            checks <- get.formula.terms(formula)#
            for (check in checks) {#
                if (grepl(':', check)) {#
                    for (subterm in split.interaction.term(check))#
                        if (subterm %in% names(olddata) && !(subterm %in% names(data)) && !is.numeric(olddata[, subterm])) {#
                            print(subterm)#
                            formula <- replace.factor.formula(subterm, formula, olddata)#
                            print(formula)#
                        }#
                } else {#
                    if (check %in% names(olddata) && !(check %in% names(data)) && !is.numeric(olddata[, check]))#
                        formula <- replace.factor.formula(check, formula, olddata)#
                }#
            }#
        }#
    }#
#
    print(head(data))#
    print(tail(data))#
    print(formula)#
    lm(formula, data=data)#
}
hierlm(Sepal.Length ~ 0 + Petal.Length + Species + Sepal.Width : Species | Species - . | Sepal.Width : Species - ., iris, c(1, 2))
#' Fit an hierarchical model#
#'#
#' Interpret a hierarchical formula and fit it with the given data and weight ratios.#
#'#
#' @param formula an hierlm-style formula#
#' @param datas a data frame or a list of data frames, for each lm-style formula contained in the hierlm#
#' @param ratios a vector a ratios for the effect of fictional#
#'   observations, with length as large as the number of hyper#
#'   expressions.#
#' @return A fitted lm model#
#' @examples#
#' hierlm(Sepal.Length ~ 0 + Petal.Length + Species + Sepal.Width : Species | Species - ., iris, 1)#
#' hierlm(Sepal.Length ~ 0 + Petal.Length + Species + Sepal.Width : Species | Species - . | Sepal.Width : Species - ., iris, c(1, 2))#
#
hierlm <- function(formula, datas, ratios, sep="") {#
    if (is.data.frame(datas))#
        datas <- list(datas)#
#
    data.ii <- 1#
    ratio.ii <- 1#
#
    data <- datas[[data.ii]]#
#
    ## Split the formula by |#
    labels <- attr(terms(formula), 'term.labels')#
    if (length(labels) == 1) { # otherwise it's just an lm formula#
        lhs <- as.character(formula)[2]#
        chunks <- strsplit(labels, "\\|")[[1]]#
        formula <- as.formula(paste(lhs, "~", chunks[1]), env=attr(formula, '.Environment'))#
        ## Keep this for weight calculations#
        oldformula <- formula#
        for (chunk in chunks[-1]) {#
            ## Make the new formula#
            formula <- combine.formulae(formula, chunk)#
            if (!("constant" %in% names(data)) && "constant" %in% get.formula.terms(formula))#
                data$constant <- 1#
#
            terms <- get.hyper.terms(chunk)#
            if (length(terms) == 3) {#
                ## Build the new relationship#
                weight <- calc.fo.weights(oldformula, terms[1], ratios[ratio.ii], datas[[data.ii]]) # use original data#
                extras <- make.hyper.rows(terms[1], terms[2], weight, datas[[data.ii]])#
#
                ## Done with this ratio#
                ratio.ii <- ratio.ii + 1#
#
                ## Create indicators for nonhyper, if not already done#
                if (terms[1] %in% data)#
                    data <- replace.factor(terms[1], data, 1, sep=sep)#
#
                data <- combine.data.frames(data, extras)#
            } else {#
                ## Add in the next formula#
                data.ii <- data.ii + 1#
                data <- combine.data.frame(data, datas[[data.ii]])#
            }#
#
            ## Have any of the terms in the formula been factorized?#
            print("checking")#
            checks <- get.formula.terms(formula)#
            for (check in checks) {#
                if (grepl(':', check)) {#
                    for (subterm in split.interaction.term(check))#
                        if (subterm %in% names(datas[[data.ii]]) && !(subterm %in% names(data)) && !is.numeric(datas[[data.ii]][, subterm])) {#
                            print(subterm)#
                            formula <- replace.factor.formula(subterm, formula, datas[[data.ii]])#
                            print(formula)#
                        }#
                } else {#
                    if (check %in% names(datas[[data.ii]]) && !(check %in% names(data)) && !is.numeric(datas[[data.ii]][, check]))#
                        formula <- replace.factor.formula(check, formula, datas[[data.ii]])#
                }#
            }#
        }#
    }#
#
    print(head(data))#
    print(tail(data))#
    print(formula)#
    lm(formula, data=data)#
}
hierlm(Sepal.Length ~ 0 + Petal.Length + Species + Sepal.Width : Species | Species - . | Sepal.Width : Species - ., iris, c(1, 2))
#' Fit an hierarchical model#
#'#
#' Interpret a hierarchical formula and fit it with the given data and weight ratios.#
#'#
#' @param formula an hierlm-style formula#
#' @param datas a data frame or a list of data frames, for each lm-style formula contained in the hierlm#
#' @param ratios a vector a ratios for the effect of fictional#
#'   observations, with length as large as the number of hyper#
#'   expressions.#
#' @return A fitted lm model#
#' @examples#
#' hierlm(Sepal.Length ~ 0 + Petal.Length + Species + Sepal.Width : Species | Species - ., iris, 1)#
#' hierlm(Sepal.Length ~ 0 + Petal.Length + Species + Sepal.Width : Species | Species - . | Sepal.Width : Species - ., iris, c(1, 2))#
#
hierlm <- function(formula, datas, ratios, sep="") {#
    if (is.data.frame(datas))#
        datas <- list(datas)#
#
    data.ii <- 1#
    ratio.ii <- 1#
#
    data <- datas[[data.ii]]#
#
    ## Split the formula by |#
    labels <- attr(terms(formula), 'term.labels')#
    if (length(labels) == 1) { # otherwise it's just an lm formula#
        lhs <- as.character(formula)[2]#
        chunks <- strsplit(labels, "\\|")[[1]]#
        formula <- as.formula(paste(lhs, "~", chunks[1]), env=attr(formula, '.Environment'))#
        ## Keep this for weight calculations#
        oldformula <- formula#
        for (chunk in chunks[-1]) {#
            ## Make the new formula#
            formula <- combine.formulae(formula, chunk)#
            if (!("constant" %in% names(data)) && "constant" %in% get.formula.terms(formula))#
                data$constant <- 1#
#
            terms <- get.hyper.terms(chunk)#
            if (length(terms) == 3) {#
                ## Build the new relationship#
                weight <- calc.fo.weights(oldformula, terms[1], ratios[ratio.ii], datas[[data.ii]]) # use original data#
                print(weight)#
                extras <- make.hyper.rows(terms[1], terms[2], weight, datas[[data.ii]])#
#
                ## Done with this ratio#
                ratio.ii <- ratio.ii + 1#
#
                ## Create indicators for nonhyper, if not already done#
                if (terms[1] %in% data)#
                    data <- replace.factor(terms[1], data, 1, sep=sep)#
#
                data <- combine.data.frames(data, extras)#
            } else {#
                ## Add in the next formula#
                data.ii <- data.ii + 1#
                data <- combine.data.frame(data, datas[[data.ii]])#
            }#
#
            ## Have any of the terms in the formula been factorized?#
            checks <- get.formula.terms(formula)#
            for (check in checks) {#
                if (grepl(':', check)) {#
                    for (subterm in split.interaction.term(check))#
                        if (subterm %in% names(datas[[data.ii]]) && !(subterm %in% names(data)) && !is.numeric(datas[[data.ii]][, subterm]))#
                            formula <- replace.factor.formula(subterm, formula, datas[[data.ii]])#
                } else {#
                    if (check %in% names(datas[[data.ii]]) && !(check %in% names(data)) && !is.numeric(datas[[data.ii]][, check]))#
                        formula <- replace.factor.formula(check, formula, datas[[data.ii]])#
                }#
            }#
        }#
    }#
#
    print(head(data))#
    print(tail(data))#
    print(formula)#
    lm(formula, data=data)#
}
hierlm(Sepal.Length ~ 0 + Petal.Length + Species + Sepal.Width : Species | Species - . | Sepal.Width : Species - ., iris, c(1, 2))
#' Fit an hierarchical model#
#'#
#' Interpret a hierarchical formula and fit it with the given data and weight ratios.#
#'#
#' @param formula an hierlm-style formula#
#' @param datas a data frame or a list of data frames, for each lm-style formula contained in the hierlm#
#' @param ratios a vector a ratios for the effect of fictional#
#'   observations, with length as large as the number of hyper#
#'   expressions.#
#' @return A fitted lm model#
#' @examples#
#' hierlm(Sepal.Length ~ 0 + Petal.Length + Species + Sepal.Width : Species | Species - ., iris, 1)#
#' hierlm(Sepal.Length ~ 0 + Petal.Length + Species + Sepal.Width : Species | Species - . | Sepal.Width : Species - ., iris, c(1, 2))#
#
hierlm <- function(formula, datas, ratios, sep="") {#
    if (is.data.frame(datas))#
        datas <- list(datas)#
#
    data.ii <- 1#
    ratio.ii <- 1#
#
    data <- datas[[data.ii]]#
#
    ## Split the formula by |#
    labels <- attr(terms(formula), 'term.labels')#
    if (length(labels) == 1) { # otherwise it's just an lm formula#
        lhs <- as.character(formula)[2]#
        chunks <- strsplit(labels, "\\|")[[1]]#
        formula <- as.formula(paste(lhs, "~", chunks[1]), env=attr(formula, '.Environment'))#
        ## Keep this for weight calculations#
        oldformula <- formula#
        for (chunk in chunks[-1]) {#
            ## Make the new formula#
            formula <- combine.formulae(formula, chunk)#
            if (!("constant" %in% names(data)) && "constant" %in% get.formula.terms(formula))#
                data$constant <- 1#
#
            terms <- get.hyper.terms(chunk)#
            if (length(terms) == 3) {#
                ## Build the new relationship#
                print(oldformula)#
                print(c(terms[1], ratios[ratio.ii]))#
                weight <- calc.fo.weights(oldformula, terms[1], ratios[ratio.ii], datas[[data.ii]]) # use original data#
                print(weight)#
                extras <- make.hyper.rows(terms[1], terms[2], weight, datas[[data.ii]])#
#
                ## Done with this ratio#
                ratio.ii <- ratio.ii + 1#
#
                ## Create indicators for nonhyper, if not already done#
                if (terms[1] %in% data)#
                    data <- replace.factor(terms[1], data, 1, sep=sep)#
#
                data <- combine.data.frames(data, extras)#
            } else {#
                ## Add in the next formula#
                data.ii <- data.ii + 1#
                data <- combine.data.frame(data, datas[[data.ii]])#
            }#
#
            ## Have any of the terms in the formula been factorized?#
            checks <- get.formula.terms(formula)#
            for (check in checks) {#
                if (grepl(':', check)) {#
                    for (subterm in split.interaction.term(check))#
                        if (subterm %in% names(datas[[data.ii]]) && !(subterm %in% names(data)) && !is.numeric(datas[[data.ii]][, subterm]))#
                            formula <- replace.factor.formula(subterm, formula, datas[[data.ii]])#
                } else {#
                    if (check %in% names(datas[[data.ii]]) && !(check %in% names(data)) && !is.numeric(datas[[data.ii]][, check]))#
                        formula <- replace.factor.formula(check, formula, datas[[data.ii]])#
                }#
            }#
        }#
    }#
#
    print(head(data))#
    print(tail(data))#
    print(formula)#
    lm(formula, data=data)#
}
hierlm(Sepal.Length ~ 0 + Petal.Length + Species + Sepal.Width : Species | Species - . | Sepal.Width : Species - ., iris, c(1, 2))
lm(Sepal.Length ~ 0 + Petal.Length + Species + Sepal.Width:Species, iris)
#' Calculate Fictional Observation Weights#
#'#
#' Determines the coeffiicients for terms in the fictional observations,#
#' to ensure a given weight relative to the normal observations.#
#'#
#' @param formula lm-style formula#
#' @param label the term to be used in fictional observations#
#' @param ratio desired ratio of observed and fictional data#
#' @param data optional data frame#
#' @return Coefficients for fictional observations#
#' @examples#
#' calc.fo.weights(Sepal.Length ~ Petal.Length + Sepal.Width : Species, "Sepal.Width:Species", 5, data=iris)#
#
calc.fo.weights <- function(formula, label, ratio, data) {#
    mod.lm <- lm(formula, data)#
    sumerr <- sum(mod.lm$residuals^2)#
#
    ## Collect the beta values for all of these#
    dummies <- substr(names(mod.lm$coefficients), 1, nchar(label)) == label#
    if (sum(dummies) == 0 && grepl(':', label)) {#
        ## Try flipping an interaction#
        subterms = split.interaction.term(label)#
        dummies <- grep(paste(subterms[2], ".*", subterms[1], sep=""), names(mod.lm$coefficients))#
    }#
    betas <- mod.lm$coefficients[dummies]#
#
    sumerr / (ratio * sum(dummies) * var(betas))#
}
hierlm(Sepal.Length ~ 0 + Petal.Length + Species + Sepal.Width : Species | Species - . | Sepal.Width : Species - ., iris, c(1, 2))
summary(hierlm(Sepal.Length ~ 0 + Petal.Length + Species + Sepal.Width : Species | Species - . | Sepal.Width : Species - ., iris, c(1, 2)))
summary(hierlm(Sepal.Length ~ 0 + Petal.Length + Species + Sepal.Width : Species | Species - ., iris, c(1, 2)))
hierlm(Sepal.Length ~ 0 + Petal.Length + Species + Sepal.Width : Species | Sepal.Width : Species - ., iris, 2)
summary(hierlm(Sepal.Length ~ 0 + Petal.Length + Species + Sepal.Width : Species | Sepal.Width : Species - ., iris, 2))
100 * exp((2 * 1:50 - 1) / 10) / exp(10)
2 * 1:50 - 1
arima
arima()
setwd("~/projects/coffee/database")#
#
library(ncdf4)#
library(maps)#
library(RColorBrewer)#
#
database <- nc_open("harvestarea.nc4")#
map <- ncvar_get(database, "arabica")#
map[map > 150] <- 150
longitude <- ncvar_get(database, "lon")#
latitude <- ncvar_get(database, "lat")
map("worldHires", ylim=c(-30, 30), mar=rep(0,4))#
image(longitude, latitude, map, col=brewer.pal(9,"YlGn"), add=T)
library(mapdata)
setwd("~/projects/coffee/tools/climate")#
#
library(ncdf4)#
library(maps)#
library(RColorBrewer)#
source("../lib/mapper.R")#
#
do.versb <- T#
#
mains <- c("Mean temperature", "Diurnal range", "Maximum temperature", "Minimum temperature", "Annual Precipitation", "Wettest month precipitation", "Driest month precipitation")#
if (do.versb) {#
    fileprefixes <- c("bio-1b", "bio-2b", "bio-5b", "bio-6b", "bio-12b", "bio-13b", "bio-14b")#
} else {#
    fileprefixes <- c("bio-1", "bio-2", "bio-5", "bio-6", "bio-12", "bio-13", "bio-14")#
}#
isprecips <- c(rep(F, 4), rep(T, 3))
ii = 1
fileprefix <- fileprefixes[ii]#
    database <- nc_open(paste0("outputs/", fileprefix, ".nc4"))#
    map <- ncvar_get(database, "change")#
    conf <- ncvar_get(database, "confidence")#
#
    conf[conf > 1] <- 1#
#
    longitude <- seq(-180 + .5 / 12, 180 - .5 / 12, by=1/12)#
    latitude <- seq(-30 + .5 / 12, 30 - .5 / 12, by=1/12)#
#
    library(mapdata)#
#
    absmap <- abs(map)#
    maxmap <- max(absmap[absmap < Inf], na.rm=T)#
#
    if (isprecips[ii]) {#
        maxmap <- .5 * maxmap#
        colors <- brewer.pal(11,"RdYlBu") #rev(brewer.pal(11,"RdYlBu")), for precip#
    } else {#
        colors <- rev(brewer.pal(11,"RdYlBu"))#
    }#
#
    breaks <- seq(-maxmap, maxmap, length.out=12)
### NEW MAP GENERATION: INCORPORATE BELOW!#
    image(seq(-169.5, 61.5, length.out=2079), seq(-1.035, 1.0, length.out=900),#
          map, col=colors, breaks=breaks)#
    addMap(border="#00000060")
image(seq(-169.5, 61.5, length.out=2079), seq(-1.035, 1.0, length.out=900),#
          map, col=colors, breaks=breaks, asp=1)
image(seq(-169.5, 61.5, length.out=2079) * pi / 180, seq(-1.035, 1.0, length.out=900),#
          map, col=colors, breaks=breaks, asp=1)
addMap(border="#00000060")
plotMap <- function(border) {#
    par(mar=rep(0, 4))#
#
    oldshape.gp <- oldshape#
    oldshape.gp$X <- oldshape.gp$X - 1.5#
    oldshape.gp$X <- oldshape.gp$X * pi / 180#
    oldshape.gp$Y <- 2 * sin(oldshape.gp$Y * pi / 180)#
    oldshape.gp$Y[oldshape.gp$Y > 0] <- oldshape.gp$Y[oldshape.gp$Y > 0] - .05 * sin(oldshape.gp$Y[oldshape.gp$Y > 0] * pi)#
    oldshape.gp$Y[oldshape.gp$Y > -.25 & oldshape.gp$Y < .25] <- oldshape.gp$Y[oldshape.gp$Y > -.25 & oldshape.gp$Y < .25] - .015 * sin((oldshape.gp$Y[oldshape.gp$Y > -.25 & oldshape.gp$Y < .25] + .25) * 2 * pi)#
    plotPolys(oldshape.gp, ylim=c(-1, 1), xlim=c(-165, 65), border=border)#
#
    addMap2(border)#
}#
#
addMap <- function(border) {#
    oldshape.gp <- oldshape#
    oldshape.gp$X <- oldshape.gp$X - 1.5#
    oldshape.gp$X <- oldshape.gp$X * pi / 180#
    oldshape.gp$Y <- 2 * sin(oldshape.gp$Y * pi / 180)#
    oldshape.gp$Y[oldshape.gp$Y > 0] <- oldshape.gp$Y[oldshape.gp$Y > 0] - .05 * sin(oldshape.gp$Y[oldshape.gp$Y > 0] * pi)#
    oldshape.gp$Y[oldshape.gp$Y > -.25 & oldshape.gp$Y < .25] <- oldshape.gp$Y[oldshape.gp$Y > -.25 & oldshape.gp$Y < .25] - .015 * sin((oldshape.gp$Y[oldshape.gp$Y > -.25 & oldshape.gp$Y < .25] + .25) * 2 * pi)#
    addPolys(oldshape.gp, border=border)#
#
    addMap2(border)#
}#
#
addMap2 <- function(border) {#
    oldshape2.gp <- oldshape#
    oldshape2.gp$X <- oldshape2.gp$X - 265 + 30 + 1#
    ##oldshape2.gp$X <- oldshape2.gp$X + .01 * (oldshape2.gp$X - -170)#
    oldshape2.gp$X <- oldshape2.gp$X * pi / 180#
    oldshape2.gp$Y <- 2 * sin(oldshape2.gp$Y * pi / 180)#
    oldshape2.gp$Y[oldshape2.gp$Y > 0] <- oldshape2.gp$Y[oldshape2.gp$Y > 0] - .05 * sin(oldshape2.gp$Y[oldshape2.gp$Y > 0] * pi)#
    oldshape2.gp$Y[oldshape2.gp$Y > -.25 & oldshape2.gp$Y < .25] <- oldshape2.gp$Y[oldshape2.gp$Y > -.25 & oldshape2.gp$Y < .25] - .015 * sin((oldshape2.gp$Y[oldshape2.gp$Y > -.25 & oldshape2.gp$Y < .25] + .25) * 2 * pi)#
    addPolys(oldshape2.gp, border=border)#
#
    nudged.gp <- ausshape#
    nudged.gp$X <- nudged.gp$X - 265 + 30 + 1#
    nudged.gp$X <- nudged.gp$X * pi / 180#
    nudged.gp$Y <- 2 * sin(nudged.gp$Y * pi / 180)#
    nudged.gp$Y[nudged.gp$Y > 0] <- nudged.gp$Y[nudged.gp$Y > 0] - .05 * sin(nudged.gp$Y[nudged.gp$Y > 0] * pi)#
    nudged.gp$Y[nudged.gp$Y > -.25 & nudged.gp$Y < .25] <- nudged.gp$Y[nudged.gp$Y > -.25 & nudged.gp$Y < .25] - .015 * sin((nudged.gp$Y[nudged.gp$Y > -.25 & nudged.gp$Y < .25] + .25) * 2 * pi)#
    addPolys(nudged.gp, border=border)#
#
    shiftright.gp <- shiftright#
    shiftright.gp$X <- shiftright.gp$X + .15#
    shiftright.gp$X <- shiftright.gp$X * pi / 180#
    shiftright.gp$Y <- 2 * sin(shiftright.gp$Y * pi / 180)#
    shiftright.gp$Y[shiftright.gp$Y > 0] <- shiftright.gp$Y[shiftright.gp$Y > 0] - .05 * sin(shiftright.gp$Y[shiftright.gp$Y > 0] * pi)#
    shiftright.gp$Y[shiftright.gp$Y > -.25 & shiftright.gp$Y < .25] <- shiftright.gp$Y[shiftright.gp$Y > -.25 & shiftright.gp$Y < .25] - .015 * sin((shiftright.gp$Y[shiftright.gp$Y > -.25 & shiftright.gp$Y < .25] + .25) * 2 * pi)#
    addPolys(shiftright.gp, border=border)#
#
    shiftleft.gp <- shiftleft#
    shiftleft.gp$X <- shiftleft.gp$X - 5 + 1#
    shiftleft.gp$X <- shiftleft.gp$X * pi / 180#
    shiftleft.gp$Y <- 2 * sin(shiftleft.gp$Y * pi / 180)#
    shiftleft.gp$Y[shiftleft.gp$Y > 0] <- shiftleft.gp$Y[shiftleft.gp$Y > 0] - .05 * sin(shiftleft.gp$Y[shiftleft.gp$Y > 0] * pi)#
    shiftleft.gp$Y[shiftleft.gp$Y > -.25 & shiftleft.gp$Y < .25] <- shiftleft.gp$Y[shiftleft.gp$Y > -.25 & shiftleft.gp$Y < .25] - .015 * sin((shiftleft.gp$Y[shiftleft.gp$Y > -.25 & shiftleft.gp$Y < .25] + .25) * 2 * pi)#
    addPolys(shiftleft.gp, border=border)#
#
    dropped.gp <- hawshape#
    dropped.gp$X <- dropped.gp$X + 58.1#
    dropped.gp$X <- dropped.gp$X * pi / 180#
    dropped.gp$Y <- dropped.gp$Y + .7#
    dropped.gp$Y <- 2 * sin((dropped.gp$Y - 2) * pi / 180)#
    addPolys(dropped.gp, border=border)#
}#
#
##addSeams
image(seq(-169.5, 61.5, length.out=2079) * pi / 180, seq(-1.035, 1.0, length.out=900),#
          map, col=colors, breaks=breaks, asp=1)
addMap(border="#00000060")
image(seq(-169.5, 61.5, length.out=2079) * pi / 180, seq(-1.035, 1.0, length.out=900),#
          map, col=colors, breaks=breaks, asp=1, ylim=c(-1, 1))
addMap(border="#00000060")
addSeams <- function(col) {#
    lines(c(-1.75, -.8, -.8), c(1, -.75, -1), col=col)#
    lines(c(.5, .5, 0, 0), c(1, .4, .3, -1), col=col)#
    lines(c(-1.5, -2, -2, -1.5), c(.5, .5, .7, .7), col=col)#
}
addSeams(col="#00000040")
addSeams <- function(col) {#
    lines(c(-1.65, -.8, -.8), c(1, -.75, -1), col=col)#
    lines(c(-.5, -.5, 0, 0), c(1, .4, .3, -1), col=col)#
    lines(c(-1.6, -1.9, -1.9, -1.6, -1.6), c(.55, .55, .75, .75, .55), col=col)#
}
addSeams(col="#00000040")
addSeams <- function(col) {#
    lines(c(-1.65, -.8, -.8), c(1, -.75, -1), col=col)#
    lines(c(-.5, -.5, 0, 0), c(1, .4, -.3, -1), col=col)#
    lines(c(-1.65, -1.8, -1.8, -1.65, -1.65), c(.55, .55, .75, .75, .55), col=col)#
}
addSeams(col="#00000040")
addSeams <- function(col) {#
    ## Left old to New#
    lines(c(-1.65, -.8, -.8), c(1, -.75, -1), col=col)#
    ## New to right old#
    lines(c(-.5, -.5, 0, 0), c(1, .4, -.25, -1), col=col)#
    ## Hawaii#
    lines(c(-1.65, -1.85, -1.85, -1.65, -1.65), c(.55, .55, .75, .75, .55), col=col)#
}
addSeams(col="#00000040")
dim(map)
mapperImage(map, colors, breaks=breaks)#
    mapperImage(conf, rgb(1, 1, 1, seq(1, 0, by=-.1)))#
    addMap(border="#00000060")#
    addSeams(col="#00000040")#
#
    ##map("worldHires", ylim=c(-30, 30), mar=rep(0,4), bg="#8080FF")#
    ##image(longitude, latitude, map, col=colors, breaks=breaks, add=T)#
    ##image(longitude, latitude, is.na(map), col="blue", add=T)#
    ##image(longitude, latitude, conf, col=rgb(1, 1, 1, seq(1, 0, by=-.1)), add=T)#
    legend("bottomleft", legend=round((breaks[-1] + breaks[-12]) / 2, digits=2), fill=colors, cex=1.5)#
    text(-180, 27, mains[ii], pos=4, cex=2)
mapperImage <- function(array, colors, breaks=NULL) {#
    if (is.null(breaks)) {#
        image(seq(-169.5, 61.5, length.out=dim(map)[1]) * pi / 180, seq(-1.035, 1.0, length.out=dim(map)[2]),#
              array, col=colors, asp=1, ylim=c(-1, 1))#
    } else {#
        image(seq(-169.5, 61.5, length.out=dim(map)[1]) * pi / 180, seq(-1.035, 1.0, length.out=dim(map)[2]),#
              array, col=colors, breaks=breaks, asp=1, ylim=c(-1, 1))#
    }#
}
mapperImage(map, colors, breaks=breaks)#
    mapperImage(conf, rgb(1, 1, 1, seq(1, 0, by=-.1)))#
    addMap(border="#00000060")#
    addSeams(col="#00000040")#
#
    ##map("worldHires", ylim=c(-30, 30), mar=rep(0,4), bg="#8080FF")#
    ##image(longitude, latitude, map, col=colors, breaks=breaks, add=T)#
    ##image(longitude, latitude, is.na(map), col="blue", add=T)#
    ##image(longitude, latitude, conf, col=rgb(1, 1, 1, seq(1, 0, by=-.1)), add=T)#
    legend("bottomleft", legend=round((breaks[-1] + breaks[-12]) / 2, digits=2), fill=colors, cex=1.5)#
    text(-180, 27, mains[ii], pos=4, cex=2)
mapperImage <- function(array, colors, breaks=NULL, add=F) {#
    if (is.null(breaks)) {#
        image(seq(-169.5, 61.5, length.out=dim(map)[1]) * pi / 180, seq(-1.035, 1.0, length.out=dim(map)[2]),#
              array, col=colors, asp=1, ylim=c(-1, 1), add=add)#
    } else {#
        image(seq(-169.5, 61.5, length.out=dim(map)[1]) * pi / 180, seq(-1.035, 1.0, length.out=dim(map)[2]),#
              array, col=colors, breaks=breaks, asp=1, ylim=c(-1, 1), add=add)#
    }#
}
mapperImage(map, colors, breaks=breaks)#
    mapperImage(conf, rgb(1, 1, 1, seq(1, 0, by=-.1)), add=T)
addMap(border="#00000060")#
    addSeams(col="#00000040")
addSeams <- function(col) {#
    ## Left old to New#
    lines(c(-1.65, -.8, -.8), c(1, -.75, -1), col=col)#
    ## New to right old#
    lines(c(-.5, -.5, 0, 0), c(1, .4, -.25, -1), col=col)#
    ## Hawaii#
    lines(c(-1.625, -1.825, -1.825, -1.625, -1.625), c(.55, .55, .75, .75, .55), col=col)#
}
for (ii in 1:length(mains)) {#
    fileprefix <- fileprefixes[ii]#
    database <- nc_open(paste0("outputs/", fileprefix, ".nc4"))#
    map <- ncvar_get(database, "change")#
    conf <- ncvar_get(database, "confidence")#
#
    conf[conf > 1] <- 1#
#
    longitude <- seq(-180 + .5 / 12, 180 - .5 / 12, by=1/12)#
    latitude <- seq(-30 + .5 / 12, 30 - .5 / 12, by=1/12)#
#
    library(mapdata)#
#
    absmap <- abs(map)#
    maxmap <- max(absmap[absmap < Inf], na.rm=T)#
#
    if (isprecips[ii]) {#
        maxmap <- .5 * maxmap#
        colors <- brewer.pal(11,"RdYlBu") #rev(brewer.pal(11,"RdYlBu")), for precip#
    } else {#
        colors <- rev(brewer.pal(11,"RdYlBu"))#
    }#
#
    breaks <- seq(-maxmap, maxmap, length.out=12)#
#
    png(paste0("outputs/", fileprefix, ".png"), width=4320/2, height=400)#
    mapperImage(map, colors, breaks=breaks)#
    mapperImage(conf, rgb(1, 1, 1, seq(1, 0, by=-.1)), add=T)#
    addMap(border="#00000060")#
    addSeams(col="#00000040")#
#
    ##map("worldHires", ylim=c(-30, 30), mar=rep(0,4), bg="#8080FF")#
    ##image(longitude, latitude, map, col=colors, breaks=breaks, add=T)#
    ##image(longitude, latitude, is.na(map), col="blue", add=T)#
    ##image(longitude, latitude, conf, col=rgb(1, 1, 1, seq(1, 0, by=-.1)), add=T)#
    legend("bottomleft", legend=round((breaks[-1] + breaks[-12]) / 2, digits=2), fill=colors, cex=1.5)#
    text(-180, 27, mains[ii], pos=4, cex=2)#
    dev.off()#
}
warnings()
fileprefix
mapperImage(map, colors, breaks=breaks)#
    mapperImage(conf, rgb(1, 1, 1, seq(1, 0, by=-.1)), add=T)
addMap(border="#00000060")#
    addSeams(col="#00000040")
legend("bottomleft", legend=round((breaks[-1] + breaks[-12]) / 2, digits=2), fill=colors, cex=1.5)#
    text(-180, 27, mains[ii], pos=4, cex=2)
png(paste0("outputs/", fileprefix, ".png"), width=4320/2, height=900)#
    mapperImage(map, colors, breaks=breaks)#
    mapperImage(conf, rgb(1, 1, 1, seq(1, 0, by=-.1)), add=T)#
    addMap(border="#00000060")#
    addSeams(col="#00000040")#
#
    ##map("worldHires", ylim=c(-30, 30), mar=rep(0,4), bg="#8080FF")#
    ##image(longitude, latitude, map, col=colors, breaks=breaks, add=T)#
    ##image(longitude, latitude, is.na(map), col="blue", add=T)#
    ##image(longitude, latitude, conf, col=rgb(1, 1, 1, seq(1, 0, by=-.1)), add=T)#
    legend("bottomleft", legend=round((breaks[-1] + breaks[-12]) / 2, digits=2), fill=colors, cex=1.5)#
    text(-180, 27, mains[ii], pos=4, cex=2)#
    dev.off()
png(paste0("outputs/", fileprefix, ".png"), width=4320/2, height=900)#
    mapperImage(map, colors, breaks=breaks)#
    #mapperImage(conf, rgb(1, 1, 1, seq(1, 0, by=-.1)), add=T)#
    #addMap(border="#00000060")#
    addSeams(col="#00000040")#
#
    ##map("worldHires", ylim=c(-30, 30), mar=rep(0,4), bg="#8080FF")#
    ##image(longitude, latitude, map, col=colors, breaks=breaks, add=T)#
    ##image(longitude, latitude, is.na(map), col="blue", add=T)#
    ##image(longitude, latitude, conf, col=rgb(1, 1, 1, seq(1, 0, by=-.1)), add=T)#
    legend("bottomleft", legend=round((breaks[-1] + breaks[-12]) / 2, digits=2), fill=colors, cex=1.5)#
    text(-180, 27, mains[ii], pos=4, cex=2)#
    dev.off()
png(paste0("outputs/", fileprefix, ".png"), width=4320/2, height=900)#
    mapperImage(map, colors, breaks=breaks)#
    mapperImage(conf, rgb(1, 1, 1, seq(1, 0, by=-.1)), add=T)#
    #addMap(border="#00000060")#
    addSeams(col="#00000040")#
#
    ##map("worldHires", ylim=c(-30, 30), mar=rep(0,4), bg="#8080FF")#
    ##image(longitude, latitude, map, col=colors, breaks=breaks, add=T)#
    ##image(longitude, latitude, is.na(map), col="blue", add=T)#
    ##image(longitude, latitude, conf, col=rgb(1, 1, 1, seq(1, 0, by=-.1)), add=T)#
    legend("bottomleft", legend=round((breaks[-1] + breaks[-12]) / 2, digits=2), fill=colors, cex=1.5)#
    text(-180, 27, mains[ii], pos=4, cex=2)#
    dev.off()
mapperImage <- function(array, colors, breaks=NULL, add=F) {#
    if (is.null(breaks)) {#
        image(seq(-169.5, 61.5, length.out=dim(map)[1]) * pi / 180, seq(-1.035, 1.0, length.out=dim(map)[2]),#
              array, col=colors, asp=1, ylim=c(-1, 1), xlim=c(-3, 1), xaxt="n", yaxt="n", add=add)#
    } else {#
        image(seq(-169.5, 61.5, length.out=dim(map)[1]) * pi / 180, seq(-1.035, 1.0, length.out=dim(map)[2]),#
              array, col=colors, breaks=breaks, asp=1, ylim=c(-1, 1), xlim=c(-3, 1), xaxt="n", yaxt="n", add=add)#
    }#
}
png(paste0("outputs/", fileprefix, ".png"), width=4320/2, height=900)#
    mapperImage(map, colors, breaks=breaks)#
    mapperImage(conf, rgb(1, 1, 1, seq(1, 0, by=-.1)), add=T)#
    #addMap(border="#00000060")#
    addSeams(col="#00000040")#
#
    ##map("worldHires", ylim=c(-30, 30), mar=rep(0,4), bg="#8080FF")#
    ##image(longitude, latitude, map, col=colors, breaks=breaks, add=T)#
    ##image(longitude, latitude, is.na(map), col="blue", add=T)#
    ##image(longitude, latitude, conf, col=rgb(1, 1, 1, seq(1, 0, by=-.1)), add=T)#
    legend("bottomleft", legend=round((breaks[-1] + breaks[-12]) / 2, digits=2), fill=colors, cex=1.5)#
    text(-180, 27, mains[ii], pos=4, cex=2)#
    dev.off()
png(paste0("outputs/", fileprefix, ".png"), width=4320/2, height=900)#
    mapperImage(map, colors, breaks=breaks)#
    mapperImage(conf, rgb(1, 1, 1, seq(1, 0, by=-.1)), add=T)#
    addMap(border="#00000060")#
    addSeams(col="#00000040")#
#
    ##map("worldHires", ylim=c(-30, 30), mar=rep(0,4), bg="#8080FF")#
    ##image(longitude, latitude, map, col=colors, breaks=breaks, add=T)#
    ##image(longitude, latitude, is.na(map), col="blue", add=T)#
    ##image(longitude, latitude, conf, col=rgb(1, 1, 1, seq(1, 0, by=-.1)), add=T)#
    legend("bottomleft", legend=round((breaks[-1] + breaks[-12]) / 2, digits=2), fill=colors, cex=1.5)#
    text(-180, 27, mains[ii], pos=4, cex=2)#
    dev.off()
?addPolys
plotMap <- function(border) {#
    par(mar=rep(0, 4))#
#
    oldshape.gp <- oldshape#
    oldshape.gp$X <- oldshape.gp$X - 1.5#
    oldshape.gp$X <- oldshape.gp$X * pi / 180#
    oldshape.gp$Y <- 2 * sin(oldshape.gp$Y * pi / 180)#
    oldshape.gp$Y[oldshape.gp$Y > 0] <- oldshape.gp$Y[oldshape.gp$Y > 0] - .05 * sin(oldshape.gp$Y[oldshape.gp$Y > 0] * pi)#
    oldshape.gp$Y[oldshape.gp$Y > -.25 & oldshape.gp$Y < .25] <- oldshape.gp$Y[oldshape.gp$Y > -.25 & oldshape.gp$Y < .25] - .015 * sin((oldshape.gp$Y[oldshape.gp$Y > -.25 & oldshape.gp$Y < .25] + .25) * 2 * pi)#
    plotPolys(oldshape.gp, ylim=c(-1, 1), xlim=c(-165, 65), border=border)#
#
    addMap2(border)#
}#
#
addMap <- function(border) {#
    oldshape.gp <- oldshape#
    oldshape.gp$X <- oldshape.gp$X - 1.5#
    oldshape.gp$X <- oldshape.gp$X * pi / 180#
    oldshape.gp$Y <- 2 * sin(oldshape.gp$Y * pi / 180)#
    oldshape.gp$Y[oldshape.gp$Y > 0] <- oldshape.gp$Y[oldshape.gp$Y > 0] - .05 * sin(oldshape.gp$Y[oldshape.gp$Y > 0] * pi)#
    oldshape.gp$Y[oldshape.gp$Y > -.25 & oldshape.gp$Y < .25] <- oldshape.gp$Y[oldshape.gp$Y > -.25 & oldshape.gp$Y < .25] - .015 * sin((oldshape.gp$Y[oldshape.gp$Y > -.25 & oldshape.gp$Y < .25] + .25) * 2 * pi)#
    addPolys(oldshape.gp, border=border, col="#00000000")#
#
    addMap2(border)#
}#
#
addMap2 <- function(border) {#
    oldshape2.gp <- oldshape#
    oldshape2.gp$X <- oldshape2.gp$X - 265 + 30 + 1#
    ##oldshape2.gp$X <- oldshape2.gp$X + .01 * (oldshape2.gp$X - -170)#
    oldshape2.gp$X <- oldshape2.gp$X * pi / 180#
    oldshape2.gp$Y <- 2 * sin(oldshape2.gp$Y * pi / 180)#
    oldshape2.gp$Y[oldshape2.gp$Y > 0] <- oldshape2.gp$Y[oldshape2.gp$Y > 0] - .05 * sin(oldshape2.gp$Y[oldshape2.gp$Y > 0] * pi)#
    oldshape2.gp$Y[oldshape2.gp$Y > -.25 & oldshape2.gp$Y < .25] <- oldshape2.gp$Y[oldshape2.gp$Y > -.25 & oldshape2.gp$Y < .25] - .015 * sin((oldshape2.gp$Y[oldshape2.gp$Y > -.25 & oldshape2.gp$Y < .25] + .25) * 2 * pi)#
    addPolys(oldshape2.gp, border=border, col="#00000000")#
#
    nudged.gp <- ausshape#
    nudged.gp$X <- nudged.gp$X - 265 + 30 + 1#
    nudged.gp$X <- nudged.gp$X * pi / 180#
    nudged.gp$Y <- 2 * sin(nudged.gp$Y * pi / 180)#
    nudged.gp$Y[nudged.gp$Y > 0] <- nudged.gp$Y[nudged.gp$Y > 0] - .05 * sin(nudged.gp$Y[nudged.gp$Y > 0] * pi)#
    nudged.gp$Y[nudged.gp$Y > -.25 & nudged.gp$Y < .25] <- nudged.gp$Y[nudged.gp$Y > -.25 & nudged.gp$Y < .25] - .015 * sin((nudged.gp$Y[nudged.gp$Y > -.25 & nudged.gp$Y < .25] + .25) * 2 * pi)#
    addPolys(nudged.gp, border=border, col="#00000000")#
#
    shiftright.gp <- shiftright#
    shiftright.gp$X <- shiftright.gp$X + .15#
    shiftright.gp$X <- shiftright.gp$X * pi / 180#
    shiftright.gp$Y <- 2 * sin(shiftright.gp$Y * pi / 180)#
    shiftright.gp$Y[shiftright.gp$Y > 0] <- shiftright.gp$Y[shiftright.gp$Y > 0] - .05 * sin(shiftright.gp$Y[shiftright.gp$Y > 0] * pi)#
    shiftright.gp$Y[shiftright.gp$Y > -.25 & shiftright.gp$Y < .25] <- shiftright.gp$Y[shiftright.gp$Y > -.25 & shiftright.gp$Y < .25] - .015 * sin((shiftright.gp$Y[shiftright.gp$Y > -.25 & shiftright.gp$Y < .25] + .25) * 2 * pi)#
    addPolys(shiftright.gp, border=border, col="#00000000")#
#
    shiftleft.gp <- shiftleft#
    shiftleft.gp$X <- shiftleft.gp$X - 5 + 1#
    shiftleft.gp$X <- shiftleft.gp$X * pi / 180#
    shiftleft.gp$Y <- 2 * sin(shiftleft.gp$Y * pi / 180)#
    shiftleft.gp$Y[shiftleft.gp$Y > 0] <- shiftleft.gp$Y[shiftleft.gp$Y > 0] - .05 * sin(shiftleft.gp$Y[shiftleft.gp$Y > 0] * pi)#
    shiftleft.gp$Y[shiftleft.gp$Y > -.25 & shiftleft.gp$Y < .25] <- shiftleft.gp$Y[shiftleft.gp$Y > -.25 & shiftleft.gp$Y < .25] - .015 * sin((shiftleft.gp$Y[shiftleft.gp$Y > -.25 & shiftleft.gp$Y < .25] + .25) * 2 * pi)#
    addPolys(shiftleft.gp, border=border, col="#00000000")#
#
    dropped.gp <- hawshape#
    dropped.gp$X <- dropped.gp$X + 58.1#
    dropped.gp$X <- dropped.gp$X * pi / 180#
    dropped.gp$Y <- dropped.gp$Y + .7#
    dropped.gp$Y <- 2 * sin((dropped.gp$Y - 2) * pi / 180)#
    addPolys(dropped.gp, border=border, col="#00000000")#
}#
#
addSeams <- function(col) {#
    ## Left old to New#
    lines(c(-1.65, -.8, -.8), c(1, -.75, -1), col=col)#
    ## New to right old#
    lines(c(-.5, -.5, 0, 0), c(1, .4, -.25, -1), col=col)#
    ## Hawaii#
    lines(c(-1.625, -1.825, -1.825, -1.625, -1.625), c(.55, .55, .75, .75, .55), col=col)#
}#
#
mapperImage <- function(array, colors, breaks=NULL, add=F) {#
    if (is.null(breaks)) {#
        image(seq(-169.5, 61.5, length.out=dim(map)[1]) * pi / 180, seq(-1.035, 1.0, length.out=dim(map)[2]),#
              array, col=colors, asp=1, ylim=c(-1, 1), xlim=c(-3, 1), xaxt="n", yaxt="n", add=add)#
    } else {#
        image(seq(-169.5, 61.5, length.out=dim(map)[1]) * pi / 180, seq(-1.035, 1.0, length.out=dim(map)[2]),#
              array, col=colors, breaks=breaks, asp=1, ylim=c(-1, 1), xlim=c(-3, 1), xaxt="n", yaxt="n", add=add)#
    }#
}
png(paste0("outputs/", fileprefix, ".png"), width=4320/2, height=900)#
    mapperImage(map, colors, breaks=breaks)#
    mapperImage(conf, rgb(1, 1, 1, seq(1, 0, by=-.1)), add=T)#
    addMap(border="#00000060")#
    addSeams(col="#00000040")#
#
    ##map("worldHires", ylim=c(-30, 30), mar=rep(0,4), bg="#8080FF")#
    ##image(longitude, latitude, map, col=colors, breaks=breaks, add=T)#
    ##image(longitude, latitude, is.na(map), col="blue", add=T)#
    ##image(longitude, latitude, conf, col=rgb(1, 1, 1, seq(1, 0, by=-.1)), add=T)#
    legend("bottomleft", legend=round((breaks[-1] + breaks[-12]) / 2, digits=2), fill=colors, cex=1.5)#
    text(-180, 27, mains[ii], pos=4, cex=2)#
    dev.off()
mapperImage <- function(array, colors, breaks=NULL, add=F) {#
    if (is.null(breaks)) {#
        image(seq(-169.5, 61.5, length.out=dim(map)[1]) * pi / 180, seq(-1.035, 1.0, length.out=dim(map)[2]),#
              array, col=colors, asp=1, ylim=c(-1, 1), xlim=c(-3, 1), xaxt="n", yaxt="n", add=add)#
    } else {#
        image(seq(-169.5, 61.5, length.out=dim(map)[1]) * pi / 180, seq(-1.035, 1.0, length.out=dim(map)[2]),#
              array, col=colors, breaks=breaks, asp=1, ylim=c(-1, 1), xlim=c(-3, 1), xaxt="n", yaxt="n", add=add)#
    }#
    par(usr=c(-3, 1, -1, 1))#
}
mapperImage(map, colors, breaks=breaks)#
    mapperImage(conf, rgb(1, 1, 1, seq(1, 0, by=-.1)), add=T)#
    addMap(border="#00000060")#
    addSeams(col="#00000040")
mapperImage <- function(array, colors, breaks=NULL, add=F) {#
    par(usr=c(-3, 1, -1, 1))#
    if (is.null(breaks)) {#
        image(seq(-169.5, 61.5, length.out=dim(map)[1]) * pi / 180, seq(-1.035, 1.0, length.out=dim(map)[2]),#
              array, col=colors, asp=1, ylim=c(-1, 1), xlim=c(-3, 1), xaxt="n", yaxt="n", add=add)#
    } else {#
        image(seq(-169.5, 61.5, length.out=dim(map)[1]) * pi / 180, seq(-1.035, 1.0, length.out=dim(map)[2]),#
              array, col=colors, breaks=breaks, asp=1, ylim=c(-1, 1), xlim=c(-3, 1), xaxt="n", yaxt="n", add=add)#
    }#
}
mapperImage(map, colors, breaks=breaks)#
    mapperImage(conf, rgb(1, 1, 1, seq(1, 0, by=-.1)), add=T)#
    addMap(border="#00000060")#
    addSeams(col="#00000040")
mapperImage(map, colors, breaks=breaks)#
    mapperImage(conf, rgb(1, 1, 1, seq(1, 0, by=-.1)), add=T)#
    addMap(border="#00000060")#
    addSeams(col="#00000040")
mapperImage <- function(array, colors, breaks=NULL, add=F) {#
    par(usr=c(-3, 1, -1, 1))#
    if (is.null(breaks)) {#
        image(seq(-169.5, 61.5, length.out=dim(map)[1]) * pi / 180, seq(-1.035, 1.0, length.out=dim(map)[2]),#
              array, col=colors, asp=1, ylim=c(-1, 1), xlim=c(-3, 1), add=add) # xaxt="n", yaxt="n"#
    } else {#
        image(seq(-169.5, 61.5, length.out=dim(map)[1]) * pi / 180, seq(-1.035, 1.0, length.out=dim(map)[2]),#
              array, col=colors, breaks=breaks, asp=1, ylim=c(-1, 1), xlim=c(-3, 1), add=add) # xaxt="n", yaxt="n",#
    }#
}
mapperImage(map, colors, breaks=breaks)#
    mapperImage(conf, rgb(1, 1, 1, seq(1, 0, by=-.1)), add=T)#
    addMap(border="#00000060")#
    addSeams(col="#00000040")
png(paste0("outputs/", fileprefix, ".png"), width=4320/2, height=900)#
    mapperImage(map, colors, breaks=breaks)#
    mapperImage(conf, rgb(1, 1, 1, seq(1, 0, by=-.1)), add=T)#
    addMap(border="#00000060")#
    addSeams(col="#00000040")#
#
    ##map("worldHires", ylim=c(-30, 30), mar=rep(0,4), bg="#8080FF")#
    ##image(longitude, latitude, map, col=colors, breaks=breaks, add=T)#
    ##image(longitude, latitude, is.na(map), col="blue", add=T)#
    ##image(longitude, latitude, conf, col=rgb(1, 1, 1, seq(1, 0, by=-.1)), add=T)#
    legend("bottomleft", legend=round((breaks[-1] + breaks[-12]) / 2, digits=2), fill=colors, cex=1.5)#
    text(-180, 27, mains[ii], pos=4, cex=2)#
    dev.off()
png(paste0("outputs/", fileprefix, ".png"), width=2079, height=900)#
    mapperImage(map, colors, breaks=breaks)#
    mapperImage(conf, rgb(1, 1, 1, seq(1, 0, by=-.1)), add=T)#
    addMap(border="#00000060")#
    addSeams(col="#00000040")#
#
    ##map("worldHires", ylim=c(-30, 30), mar=rep(0,4), bg="#8080FF")#
    ##image(longitude, latitude, map, col=colors, breaks=breaks, add=T)#
    ##image(longitude, latitude, is.na(map), col="blue", add=T)#
    ##image(longitude, latitude, conf, col=rgb(1, 1, 1, seq(1, 0, by=-.1)), add=T)#
    legend("bottomleft", legend=round((breaks[-1] + breaks[-12]) / 2, digits=2), fill=colors, cex=1.5)#
    text(-180, 27, mains[ii], pos=4, cex=2)#
    dev.off()
mapperImage <- function(array, colors, breaks=NULL, add=F) {#
    ##par(usr=c(-3, 1, -1, 1))#
    if (is.null(breaks)) {#
        image(seq(-169.5, 61.5, length.out=dim(map)[1]) * pi / 180, seq(-1.035, 1.0, length.out=dim(map)[2]),#
              array, col=colors, asp=1, ylim=c(-1, 1), xlim=c(-3, 1), add=add) # xaxt="n", yaxt="n"#
    } else {#
        image(seq(-169.5, 61.5, length.out=dim(map)[1]) * pi / 180, seq(-1.035, 1.0, length.out=dim(map)[2]),#
              array, col=colors, breaks=breaks, asp=1, ylim=c(-1, 1), xlim=c(-3, 1), add=add) # xaxt="n", yaxt="n",#
    }#
}
png(paste0("outputs/", fileprefix, ".png"), width=2079, height=900)#
    mapperImage(map, colors, breaks=breaks)#
    mapperImage(conf, rgb(1, 1, 1, seq(1, 0, by=-.1)), add=T)#
    addMap(border="#00000060")#
    addSeams(col="#00000040")#
#
    ##map("worldHires", ylim=c(-30, 30), mar=rep(0,4), bg="#8080FF")#
    ##image(longitude, latitude, map, col=colors, breaks=breaks, add=T)#
    ##image(longitude, latitude, is.na(map), col="blue", add=T)#
    ##image(longitude, latitude, conf, col=rgb(1, 1, 1, seq(1, 0, by=-.1)), add=T)#
    legend("bottomleft", legend=round((breaks[-1] + breaks[-12]) / 2, digits=2), fill=colors, cex=1.5)#
    text(-180, 27, mains[ii], pos=4, cex=2)#
    dev.off()
png(paste0("outputs/", fileprefix, ".png"), width=1700, height=900)#
    mapperImage(map, colors, breaks=breaks)#
    mapperImage(conf, rgb(1, 1, 1, seq(1, 0, by=-.1)), add=T)#
    addMap(border="#00000060")#
    addSeams(col="#00000040")#
#
    ##map("worldHires", ylim=c(-30, 30), mar=rep(0,4), bg="#8080FF")#
    ##image(longitude, latitude, map, col=colors, breaks=breaks, add=T)#
    ##image(longitude, latitude, is.na(map), col="blue", add=T)#
    ##image(longitude, latitude, conf, col=rgb(1, 1, 1, seq(1, 0, by=-.1)), add=T)#
    legend("bottomleft", legend=round((breaks[-1] + breaks[-12]) / 2, digits=2), fill=colors, cex=1.5)#
    text(-180, 27, mains[ii], pos=4, cex=2)#
    dev.off()
mapperImage <- function(array, colors, breaks=NULL, add=F) {#
    if (is.null(breaks)) {#
        image(seq(-169.5, 61.5, length.out=dim(map)[1]) * pi / 180, seq(-1.035, 1.0, length.out=dim(map)[2]),#
              array, col=colors, asp=1, ylim=c(-1, 1), xlim=c(-2.95, 1.05), add=add) # xaxt="n", yaxt="n"#
    } else {#
        image(seq(-169.5, 61.5, length.out=dim(map)[1]) * pi / 180, seq(-1.035, 1.0, length.out=dim(map)[2]),#
              array, col=colors, breaks=breaks, asp=1, ylim=c(-1, 1), xlim=c(-2.95, 1.05), add=add) # xaxt="n", yaxt="n",#
    }#
}
png(paste0("outputs/", fileprefix, ".png"), width=1670, height=900)#
    mapperImage(map, colors, breaks=breaks)#
    mapperImage(conf, rgb(1, 1, 1, seq(1, 0, by=-.1)), add=T)#
    addMap(border="#00000060")#
    addSeams(col="#00000040")#
#
    ##map("worldHires", ylim=c(-30, 30), mar=rep(0,4), bg="#8080FF")#
    ##image(longitude, latitude, map, col=colors, breaks=breaks, add=T)#
    ##image(longitude, latitude, is.na(map), col="blue", add=T)#
    ##image(longitude, latitude, conf, col=rgb(1, 1, 1, seq(1, 0, by=-.1)), add=T)#
    legend("bottomleft", legend=round((breaks[-1] + breaks[-12]) / 2, digits=2), fill=colors, cex=1.5)#
    text(-180, 27, mains[ii], pos=4, cex=2)#
    dev.off()
mapperImage <- function(array, colors, breaks=NULL, add=F) {#
    if (is.null(breaks)) {#
        image(seq(-169.5, 61.5, length.out=dim(map)[1]) * pi / 180, seq(-1.035, 1.0, length.out=dim(map)[2]),#
              array, col=colors, asp=1, ylim=c(-1, 1), xlim=c(-2.95, 1.05), add=add, xaxt="n", yaxt="n", xlab="", ylab="")#
    } else {#
        image(seq(-169.5, 61.5, length.out=dim(map)[1]) * pi / 180, seq(-1.035, 1.0, length.out=dim(map)[2]),#
              array, col=colors, breaks=breaks, asp=1, ylim=c(-1, 1), xlim=c(-2.95, 1.05), add=add, xaxt="n", yaxt="n", xlab="", ylab="")#
    }#
}
png(paste0("outputs/", fileprefix, ".png"), width=1670, height=900)#
    mapperImage(map, colors, breaks=breaks)#
    mapperImage(conf, rgb(1, 1, 1, seq(1, 0, by=-.1)), add=T)#
    addMap(border="#00000060")#
    addSeams(col="#00000040")#
#
    ##map("worldHires", ylim=c(-30, 30), mar=rep(0,4), bg="#8080FF")#
    ##image(longitude, latitude, map, col=colors, breaks=breaks, add=T)#
    ##image(longitude, latitude, is.na(map), col="blue", add=T)#
    ##image(longitude, latitude, conf, col=rgb(1, 1, 1, seq(1, 0, by=-.1)), add=T)#
    legend("bottomleft", legend=round((breaks[-1] + breaks[-12]) / 2, digits=2), fill=colors, cex=1.5)#
    text(-180, 27, mains[ii], pos=4, cex=2)#
    dev.off()
png(paste0("outputs/", fileprefix, ".png"), width=1670, height=900)#
    par(mar=c(0, 0, 0, 0))#
    mapperImage(map, colors, breaks=breaks)#
    mapperImage(conf, rgb(1, 1, 1, seq(1, 0, by=-.1)), add=T)#
    addMap(border="#00000060")#
    addSeams(col="#00000040")#
#
    ##map("worldHires", ylim=c(-30, 30), mar=rep(0,4), bg="#8080FF")#
    ##image(longitude, latitude, map, col=colors, breaks=breaks, add=T)#
    ##image(longitude, latitude, is.na(map), col="blue", add=T)#
    ##image(longitude, latitude, conf, col=rgb(1, 1, 1, seq(1, 0, by=-.1)), add=T)#
    legend("bottomleft", legend=round((breaks[-1] + breaks[-12]) / 2, digits=2), fill=colors, cex=1.5)#
    text(-180, 27, mains[ii], pos=4, cex=2)#
    dev.off()
png(paste0("outputs/", fileprefix, ".png"), width=1690, height=900)#
    par(mar=c(0, 0, 0, 0))#
    mapperImage(map, colors, breaks=breaks)#
    mapperImage(conf, rgb(1, 1, 1, seq(1, 0, by=-.1)), add=T)#
    addMap(border="#00000060")#
    addSeams(col="#00000040")#
#
    ##map("worldHires", ylim=c(-30, 30), mar=rep(0,4), bg="#8080FF")#
    ##image(longitude, latitude, map, col=colors, breaks=breaks, add=T)#
    ##image(longitude, latitude, is.na(map), col="blue", add=T)#
    ##image(longitude, latitude, conf, col=rgb(1, 1, 1, seq(1, 0, by=-.1)), add=T)#
    legend("bottomleft", legend=round((breaks[-1] + breaks[-12]) / 2, digits=2), fill=colors, cex=1.5)#
    text(-180, 27, mains[ii], pos=4, cex=2)#
    dev.off()
png(paste0("outputs/", fileprefix, ".png"), width=1750, height=900)#
    par(mar=c(0, 0, 0, 0))#
    mapperImage(map, colors, breaks=breaks)#
    mapperImage(conf, rgb(1, 1, 1, seq(1, 0, by=-.1)), add=T)#
    addMap(border="#00000060")#
    addSeams(col="#00000040")#
#
    ##map("worldHires", ylim=c(-30, 30), mar=rep(0,4), bg="#8080FF")#
    ##image(longitude, latitude, map, col=colors, breaks=breaks, add=T)#
    ##image(longitude, latitude, is.na(map), col="blue", add=T)#
    ##image(longitude, latitude, conf, col=rgb(1, 1, 1, seq(1, 0, by=-.1)), add=T)#
    legend("bottomleft", legend=round((breaks[-1] + breaks[-12]) / 2, digits=2), fill=colors, cex=1.5)#
    text(-180, 27, mains[ii], pos=4, cex=2)#
    dev.off()
png(paste0("outputs/", fileprefix, ".png"), width=1800, height=900)#
    par(mar=c(0, 0, 0, 0))#
    mapperImage(map, colors, breaks=breaks)#
    mapperImage(conf, rgb(1, 1, 1, seq(1, 0, by=-.1)), add=T)#
    addMap(border="#00000060")#
    addSeams(col="#00000040")#
#
    ##map("worldHires", ylim=c(-30, 30), mar=rep(0,4), bg="#8080FF")#
    ##image(longitude, latitude, map, col=colors, breaks=breaks, add=T)#
    ##image(longitude, latitude, is.na(map), col="blue", add=T)#
    ##image(longitude, latitude, conf, col=rgb(1, 1, 1, seq(1, 0, by=-.1)), add=T)#
    legend("bottomleft", legend=round((breaks[-1] + breaks[-12]) / 2, digits=2), fill=colors, cex=1.5)#
    text(-180, 27, mains[ii], pos=4, cex=2)#
    dev.off()
png(paste0("outputs/", fileprefix, ".png"), width=1850, height=900)#
    par(mar=c(0, 0, 0, 0))#
    mapperImage(map, colors, breaks=breaks)#
    mapperImage(conf, rgb(1, 1, 1, seq(1, 0, by=-.1)), add=T)#
    addMap(border="#00000060")#
    addSeams(col="#00000040")#
#
    ##map("worldHires", ylim=c(-30, 30), mar=rep(0,4), bg="#8080FF")#
    ##image(longitude, latitude, map, col=colors, breaks=breaks, add=T)#
    ##image(longitude, latitude, is.na(map), col="blue", add=T)#
    ##image(longitude, latitude, conf, col=rgb(1, 1, 1, seq(1, 0, by=-.1)), add=T)#
    legend("bottomleft", legend=round((breaks[-1] + breaks[-12]) / 2, digits=2), fill=colors, cex=1.5)#
    text(-180, 27, mains[ii], pos=4, cex=2)#
    dev.off()
png(paste0("outputs/", fileprefix, ".png"), width=1850, height=900)#
    par(mar=c(0, 0, 0, 0))#
    mapperImage(map, colors, breaks=breaks)#
    mapperImage(conf, rgb(1, 1, 1, seq(1, 0, by=-.1)), add=T)#
    addMap(border="#00000060")#
    addSeams(col="#00000040")#
#
    ##map("worldHires", ylim=c(-30, 30), mar=rep(0,4), bg="#8080FF")#
    ##image(longitude, latitude, map, col=colors, breaks=breaks, add=T)#
    ##image(longitude, latitude, is.na(map), col="blue", add=T)#
    ##image(longitude, latitude, conf, col=rgb(1, 1, 1, seq(1, 0, by=-.1)), add=T)#
    legend("bottomleft", legend=round((breaks[-1] + breaks[-12]) / 2, digits=2), fill=colors, cex=1.5)#
    text(-180, 27, mains[ii], pos=4, cex=3)#
    dev.off()
png(paste0("outputs/", fileprefix, ".png"), width=1850, height=900)#
    par(mar=c(0, 0, 0, 0))#
    mapperImage(map, colors, breaks=breaks)#
    mapperImage(conf, rgb(1, 1, 1, seq(1, 0, by=-.1)), add=T)#
    addMap(border="#00000060")#
    addSeams(col="#00000040")#
#
    ##map("worldHires", ylim=c(-30, 30), mar=rep(0,4), bg="#8080FF")#
    ##image(longitude, latitude, map, col=colors, breaks=breaks, add=T)#
    ##image(longitude, latitude, is.na(map), col="blue", add=T)#
    ##image(longitude, latitude, conf, col=rgb(1, 1, 1, seq(1, 0, by=-.1)), add=T)#
    legend("bottomleft", legend=round((breaks[-1] + breaks[-12]) / 2, digits=2), fill=colors, cex=2)#
    text(-2.94, -.5, mains[ii], pos=4, cex=2.5)#
    dev.off()
png(paste0("outputs/", fileprefix, ".png"), width=1850, height=900)#
    par(mar=c(0, 0, 0, 0))#
    mapperImage(map, colors, breaks=breaks)#
    mapperImage(conf, rgb(1, 1, 1, seq(1, 0, by=-.1)), add=T)#
    addMap(border="#00000060")#
    addSeams(col="#00000040")#
#
    ##map("worldHires", ylim=c(-30, 30), mar=rep(0,4), bg="#8080FF")#
    ##image(longitude, latitude, map, col=colors, breaks=breaks, add=T)#
    ##image(longitude, latitude, is.na(map), col="blue", add=T)#
    ##image(longitude, latitude, conf, col=rgb(1, 1, 1, seq(1, 0, by=-.1)), add=T)#
    legend("bottomleft", legend=round((breaks[-1] + breaks[-12]) / 2, digits=2), fill=colors, cex=1.7)#
    text(-3.05, -.2, mains[ii], pos=4, cex=2.5)#
    dev.off()
png(paste0("outputs/", fileprefix, ".png"), width=1850, height=900)#
    par(mar=c(0, 0, 0, 0))#
    mapperImage(map, colors, breaks=breaks)#
    mapperImage(conf, rgb(1, 1, 1, seq(1, 0, by=-.1)), add=T)#
    addMap(border="#00000060")#
    addSeams(col="#00000040")#
#
    ##map("worldHires", ylim=c(-30, 30), mar=rep(0,4), bg="#8080FF")#
    ##image(longitude, latitude, map, col=colors, breaks=breaks, add=T)#
    ##image(longitude, latitude, is.na(map), col="blue", add=T)#
    ##image(longitude, latitude, conf, col=rgb(1, 1, 1, seq(1, 0, by=-.1)), add=T)#
    legend("bottomleft", legend=round((breaks[-1] + breaks[-12]) / 2, digits=2), fill=colors, cex=1.7)#
    text(-3.0, -.3, mains[ii], pos=4, cex=2.5)#
    dev.off()
for (ii in 1:length(mains)) {#
    fileprefix <- fileprefixes[ii]#
    database <- nc_open(paste0("outputs/", fileprefix, ".nc4"))#
    map <- ncvar_get(database, "change")#
    conf <- ncvar_get(database, "confidence")#
#
    conf[conf > 1] <- 1#
#
    longitude <- seq(-180 + .5 / 12, 180 - .5 / 12, by=1/12)#
    latitude <- seq(-30 + .5 / 12, 30 - .5 / 12, by=1/12)#
#
    library(mapdata)#
#
    absmap <- abs(map)#
    maxmap <- max(absmap[absmap < Inf], na.rm=T)#
#
    if (isprecips[ii]) {#
        maxmap <- .5 * maxmap#
        colors <- brewer.pal(11,"RdYlBu") #rev(brewer.pal(11,"RdYlBu")), for precip#
    } else {#
        colors <- rev(brewer.pal(11,"RdYlBu"))#
    }#
#
    breaks <- seq(-maxmap, maxmap, length.out=12)#
#
    png(paste0("outputs/", fileprefix, ".png"), width=1850, height=900)#
    par(mar=c(0, 0, 0, 0))#
    mapperImage(map, colors, breaks=breaks)#
    mapperImage(conf, rgb(1, 1, 1, seq(1, 0, by=-.1)), add=T)#
    addMap(border="#00000060")#
    addSeams(col="#00000040")#
#
    ##map("worldHires", ylim=c(-30, 30), mar=rep(0,4), bg="#8080FF")#
    ##image(longitude, latitude, map, col=colors, breaks=breaks, add=T)#
    ##image(longitude, latitude, is.na(map), col="blue", add=T)#
    ##image(longitude, latitude, conf, col=rgb(1, 1, 1, seq(1, 0, by=-.1)), add=T)#
    legend("bottomleft", legend=round((breaks[-1] + breaks[-12]) / 2, digits=2), fill=colors, cex=1.7)#
    text(-3.0, -.3, mains[ii], pos=4, cex=2.5)#
    dev.off()#
}
