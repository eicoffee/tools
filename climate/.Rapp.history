lm(Sepal.Length ~ Petal.Length + Sepal.Width : Species, data=iris)
calc.fo.weights(Sepal.Length ~ Petal.Length + Sepal.Width : Species, "Sepal.Width:Species", 5, data=iris)
#' Create fictional observations for a hyper relationship#
#'#
#' Return a data frame with fictional observations#
#'#
#' @param nonhyper name of the non-hyper column#
#' @param hyper name of the hyper column#
#' @param weight weight to be used in the rows#
#' @param data a data frame for inspecting levels#
#' @return Fictional observations in a data frame#
#' @examples#
#' make.hyper.rows("Species", "hyperSpecies", 5, iris)#
#
make.hyper.rows <- function(nonhyper, hyper, weight, data, sep="") {#
    ## Construct extra from diagonal factor matrix#
    extras <- diag(weight, length(unique(data[, nonhyper])))#
    extras <- as.data.frame(extras)#
#
    names(extras) <- paste(nonhyper, unique(data[, nonhyper]), sep=sep)#
#
    ## Add in the hyper column#
    extras[, hyper] <- -weight#
#
    extras#
}
make.hyper.rows("Species", "hyperSpecies", 5, iris)
#' Fit an hierarchical model#
#'#
#' Interpret a hierarchical formula and fit it with the given data and weight ratios.#
#'#
#' @param formula an hierlm-style formula#
#' @param datas a data frame or a list of data frames, for each lm-style formula contained in the hierlm#
#' @param ratios a vector a ratios for the effect of fictional#
#'   observations, with length as large as the number of hyper#
#'   expressions.#
#' @return A fitted lm model#
#' @examples#
#' hierlm(Sepal.Length ~ Petal.Length + Species + Sepal.Width : Species | Species - ., iris, 1)#
#' hierlm(Sepal.Length ~ Petal.Length + Species + Sepal.Width : Species | Species - . | Sepal.Width : Species - ., iris, c(1, 2))#
#
hierlm <- function(formula, datas, ratios, sep="") {#
    if (is.data.frame(datas))#
        datas <- list(datas)#
#
    data.ii <- 1#
    ratio.ii <- 1#
#
    data <- datas[data.ii]#
#
    ## Split the formula by |#
    labels <- attr(terms(formula), 'term.labels')#
    if (length(labels) == 1) { # otherwise it's just an lm formula#
        chunks <- strsplit(labels, "\\|")[[1]]#
        formula <- as.formula(chunks[1], env=attr(formula1, '.Environment'))#
        for (chunk in chunks[-1]) {#
            formula <- combine.formulae(formula, chunk)#
            terms <- get.hyper.terms(chunk)#
            if (length(terms) == 3) {#
                ## Build the new relationship#
                weight <- calc.fo.weights(formula, terms[1], ratios[ratio.ii], datas[[data.ii]]) # use original data#
                extras <- make.hyper.rows(terms[1], terms[2], weight, datas[[data.ii]])#
#
                ## Done with this ratio#
                ratio.ii <- ratio.ii + 1#
#
                ## Create indicators for nonhyper, if not already done#
                if (terms[1] %in% data)#
                    data <- replace.factor(terms[1], data, 1, sep=sep)#
#
                data <- combine.data.frames(data, extras)#
            } else {#
                ## Add in the next formula#
                data.ii <- data.ii + 1#
                data <- combine.data.frame(data, datas[[data.ii]])#
            }#
        }#
    }#
#
    lm(formula, data=data)#
}
hierlm(Sepal.Length ~ Petal.Length + Species + Sepal.Width : Species | Species - ., iris, 1)
iris
formula = Sepal.Length ~ Petal.Length + Species + Sepal.Width : Species | Species - .
data = iris
ratios = 1
if (is.data.frame(datas))#
        datas <- list(datas)#
#
    data.ii <- 1#
    ratio.ii <- 1#
#
    data <- datas[data.ii]
datas = iris
if (is.data.frame(datas))#
        datas <- list(datas)#
#
    data.ii <- 1#
    ratio.ii <- 1#
#
    data <- datas[data.ii]
## Split the formula by |#
    labels <- attr(terms(formula), 'term.labels')#
    if (length(labels) == 1) { # otherwise it's just an lm formula#
        chunks <- strsplit(labels, "\\|")[[1]]#
        formula <- as.formula(chunks[1], env=attr(formula1, '.Environment'))#
        for (chunk in chunks[-1]) {#
            formula <- combine.formulae(formula, chunk)#
            terms <- get.hyper.terms(chunk)#
            if (length(terms) == 3) {#
                ## Build the new relationship#
                weight <- calc.fo.weights(formula, terms[1], ratios[ratio.ii], datas[[data.ii]]) # use original data#
                extras <- make.hyper.rows(terms[1], terms[2], weight, datas[[data.ii]])#
#
                ## Done with this ratio#
                ratio.ii <- ratio.ii + 1#
#
                ## Create indicators for nonhyper, if not already done#
                if (terms[1] %in% data)#
                    data <- replace.factor(terms[1], data, 1, sep=sep)#
#
                data <- combine.data.frames(data, extras)#
            } else {#
                ## Add in the next formula#
                data.ii <- data.ii + 1#
                data <- combine.data.frame(data, datas[[data.ii]])#
            }#
        }#
    }
#' Fit an hierarchical model#
#'#
#' Interpret a hierarchical formula and fit it with the given data and weight ratios.#
#'#
#' @param formula an hierlm-style formula#
#' @param datas a data frame or a list of data frames, for each lm-style formula contained in the hierlm#
#' @param ratios a vector a ratios for the effect of fictional#
#'   observations, with length as large as the number of hyper#
#'   expressions.#
#' @return A fitted lm model#
#' @examples#
#' hierlm(Sepal.Length ~ Petal.Length + Species + Sepal.Width : Species | Species - ., iris, 1)#
#' hierlm(Sepal.Length ~ Petal.Length + Species + Sepal.Width : Species | Species - . | Sepal.Width : Species - ., iris, c(1, 2))#
#
hierlm <- function(formula, datas, ratios, sep="") {#
    if (is.data.frame(datas))#
        datas <- list(datas)#
#
    data.ii <- 1#
    ratio.ii <- 1#
#
    data <- datas[data.ii]#
#
    ## Split the formula by |#
    labels <- attr(terms(formula), 'term.labels')#
    if (length(labels) == 1) { # otherwise it's just an lm formula#
        chunks <- strsplit(labels, "\\|")[[1]]#
        formula <- as.formula(chunks[1], env=attr(formula1, '.Environment'))#
        for (chunk in chunks[-1]) {#
            print(chunk)#
            formula <- combine.formulae(formula, chunk)#
            terms <- get.hyper.terms(chunk)#
            if (length(terms) == 3) {#
                ## Build the new relationship#
                weight <- calc.fo.weights(formula, terms[1], ratios[ratio.ii], datas[[data.ii]]) # use original data#
                extras <- make.hyper.rows(terms[1], terms[2], weight, datas[[data.ii]])#
#
                ## Done with this ratio#
                ratio.ii <- ratio.ii + 1#
#
                ## Create indicators for nonhyper, if not already done#
                if (terms[1] %in% data)#
                    data <- replace.factor(terms[1], data, 1, sep=sep)#
#
                data <- combine.data.frames(data, extras)#
            } else {#
                ## Add in the next formula#
                data.ii <- data.ii + 1#
                data <- combine.data.frame(data, datas[[data.ii]])#
            }#
        }#
    }#
#
    lm(formula, data=data)#
}
formula = Sepal.Length ~ Petal.Length + Species + Sepal.Width : Species | Species - .
hierlm(Sepal.Length ~ Petal.Length + Species + Sepal.Width : Species | Species - ., iris, 1)
#' Fit an hierarchical model#
#'#
#' Interpret a hierarchical formula and fit it with the given data and weight ratios.#
#'#
#' @param formula an hierlm-style formula#
#' @param datas a data frame or a list of data frames, for each lm-style formula contained in the hierlm#
#' @param ratios a vector a ratios for the effect of fictional#
#'   observations, with length as large as the number of hyper#
#'   expressions.#
#' @return A fitted lm model#
#' @examples#
#' hierlm(Sepal.Length ~ Petal.Length + Species + Sepal.Width : Species | Species - ., iris, 1)#
#' hierlm(Sepal.Length ~ Petal.Length + Species + Sepal.Width : Species | Species - . | Sepal.Width : Species - ., iris, c(1, 2))#
#
hierlm <- function(formula, datas, ratios, sep="") {#
    if (is.data.frame(datas))#
        datas <- list(datas)#
#
    data.ii <- 1#
    ratio.ii <- 1#
#
    data <- datas[data.ii]#
#
    ## Split the formula by |#
    labels <- attr(terms(formula), 'term.labels')#
    if (length(labels) == 1) { # otherwise it's just an lm formula#
        chunks <- strsplit(labels, "\\|")[[1]]#
        print(chunks)#
        formula <- as.formula(chunks[1], env=attr(formula1, '.Environment'))#
        for (chunk in chunks[-1]) {#
            print(chunk)#
            formula <- combine.formulae(formula, chunk)#
            terms <- get.hyper.terms(chunk)#
            if (length(terms) == 3) {#
                ## Build the new relationship#
                weight <- calc.fo.weights(formula, terms[1], ratios[ratio.ii], datas[[data.ii]]) # use original data#
                extras <- make.hyper.rows(terms[1], terms[2], weight, datas[[data.ii]])#
#
                ## Done with this ratio#
                ratio.ii <- ratio.ii + 1#
#
                ## Create indicators for nonhyper, if not already done#
                if (terms[1] %in% data)#
                    data <- replace.factor(terms[1], data, 1, sep=sep)#
#
                data <- combine.data.frames(data, extras)#
            } else {#
                ## Add in the next formula#
                data.ii <- data.ii + 1#
                data <- combine.data.frame(data, datas[[data.ii]])#
            }#
        }#
    }#
#
    lm(formula, data=data)#
}
hierlm(Sepal.Length ~ Petal.Length + Species + Sepal.Width : Species | Species - ., iris, 1)
#' Fit an hierarchical model#
#'#
#' Interpret a hierarchical formula and fit it with the given data and weight ratios.#
#'#
#' @param formula an hierlm-style formula#
#' @param datas a data frame or a list of data frames, for each lm-style formula contained in the hierlm#
#' @param ratios a vector a ratios for the effect of fictional#
#'   observations, with length as large as the number of hyper#
#'   expressions.#
#' @return A fitted lm model#
#' @examples#
#' hierlm(Sepal.Length ~ Petal.Length + Species + Sepal.Width : Species | Species - ., iris, 1)#
#' hierlm(Sepal.Length ~ Petal.Length + Species + Sepal.Width : Species | Species - . | Sepal.Width : Species - ., iris, c(1, 2))#
#
hierlm <- function(formula, datas, ratios, sep="") {#
    if (is.data.frame(datas))#
        datas <- list(datas)#
#
    data.ii <- 1#
    ratio.ii <- 1#
#
    data <- datas[data.ii]#
#
    ## Split the formula by |#
    labels <- attr(terms(formula), 'term.labels')#
    if (length(labels) == 1) { # otherwise it's just an lm formula#
        chunks <- strsplit(labels, "\\|")[[1]]#
        print(chunks)#
        formula <- as.formula(chunks[1], env=attr(formula, '.Environment'))#
        for (chunk in chunks[-1]) {#
            print(chunk)#
            formula <- combine.formulae(formula, chunk)#
            terms <- get.hyper.terms(chunk)#
            if (length(terms) == 3) {#
                ## Build the new relationship#
                weight <- calc.fo.weights(formula, terms[1], ratios[ratio.ii], datas[[data.ii]]) # use original data#
                extras <- make.hyper.rows(terms[1], terms[2], weight, datas[[data.ii]])#
#
                ## Done with this ratio#
                ratio.ii <- ratio.ii + 1#
#
                ## Create indicators for nonhyper, if not already done#
                if (terms[1] %in% data)#
                    data <- replace.factor(terms[1], data, 1, sep=sep)#
#
                data <- combine.data.frames(data, extras)#
            } else {#
                ## Add in the next formula#
                data.ii <- data.ii + 1#
                data <- combine.data.frame(data, datas[[data.ii]])#
            }#
        }#
    }#
#
    lm(formula, data=data)#
}
hierlm(Sepal.Length ~ Petal.Length + Species + Sepal.Width : Species | Species - ., iris, 1)
Sepal.Length ~ Petal.Length + Species + Sepal.Width : Species | Species - .
datas
if (is.data.frame(datas))#
        datas <- list(datas)#
#
    data.ii <- 1#
    ratio.ii <- 1#
#
    data <- datas[data.ii]#
#
    ## Split the formula by |#
    labels <- attr(terms(formula), 'term.labels')
labels
chunks <- strsplit(labels, "\\|")[[1]]
formula <- as.formula(chunks[1], env=attr(formula, '.Environment'))
as.formula(chunks[1])
formula
Sepal.Length ~ Petal.Length + Species + Sepal.Width:Species
as.formula(Sepal.Length ~ Petal.Length + Species + Sepal.Width:Species)
as.formula(Sepal.Length ~ Petal.Length + Species + Sepal.Width:Species, env=attr(formula, '.Environment'))
as.formula("Sepal.Length ~ Petal.Length + Species + Sepal.Width:Species", env=attr(formula, '.Environment'))
as.formula(chunks[1], env=attr(formula, '.Environment'))
chunks[1]
labels
terms(formula)
length(labels)
#' Fit an hierarchical model#
#'#
#' Interpret a hierarchical formula and fit it with the given data and weight ratios.#
#'#
#' @param formula an hierlm-style formula#
#' @param datas a data frame or a list of data frames, for each lm-style formula contained in the hierlm#
#' @param ratios a vector a ratios for the effect of fictional#
#'   observations, with length as large as the number of hyper#
#'   expressions.#
#' @return A fitted lm model#
#' @examples#
#' hierlm(Sepal.Length ~ Petal.Length + Species + Sepal.Width : Species | Species - ., iris, 1)#
#' hierlm(Sepal.Length ~ Petal.Length + Species + Sepal.Width : Species | Species - . | Sepal.Width : Species - ., iris, c(1, 2))#
#
hierlm <- function(formula, datas, ratios, sep="") {#
    if (is.data.frame(datas))#
        datas <- list(datas)#
#
    data.ii <- 1#
    ratio.ii <- 1#
#
    data <- datas[data.ii]#
#
    ## Split the formula by |#
    labels <- attr(terms(formula), 'term.labels')#
    if (length(labels) == 1) { # otherwise it's just an lm formula#
        lhs <- as.character(formula)[2]#
        chunks <- strsplit(labels, "\\|")[[1]]#
        formula <- as.formula(paste(lhs, "~", chunks[1]), env=attr(formula, '.Environment'))#
        for (chunk in chunks[-1]) {#
            print(chunk)#
            formula <- combine.formulae(formula, chunk)#
            terms <- get.hyper.terms(chunk)#
            if (length(terms) == 3) {#
                ## Build the new relationship#
                weight <- calc.fo.weights(formula, terms[1], ratios[ratio.ii], datas[[data.ii]]) # use original data#
                extras <- make.hyper.rows(terms[1], terms[2], weight, datas[[data.ii]])#
#
                ## Done with this ratio#
                ratio.ii <- ratio.ii + 1#
#
                ## Create indicators for nonhyper, if not already done#
                if (terms[1] %in% data)#
                    data <- replace.factor(terms[1], data, 1, sep=sep)#
#
                data <- combine.data.frames(data, extras)#
            } else {#
                ## Add in the next formula#
                data.ii <- data.ii + 1#
                data <- combine.data.frame(data, datas[[data.ii]])#
            }#
        }#
    }#
#
    lm(formula, data=data)#
}
hierlm(Sepal.Length ~ Petal.Length + Species + Sepal.Width : Species | Species - ., iris, 1)
#' Fit an hierarchical model#
#'#
#' Interpret a hierarchical formula and fit it with the given data and weight ratios.#
#'#
#' @param formula an hierlm-style formula#
#' @param datas a data frame or a list of data frames, for each lm-style formula contained in the hierlm#
#' @param ratios a vector a ratios for the effect of fictional#
#'   observations, with length as large as the number of hyper#
#'   expressions.#
#' @return A fitted lm model#
#' @examples#
#' hierlm(Sepal.Length ~ Petal.Length + Species + Sepal.Width : Species | Species - ., iris, 1)#
#' hierlm(Sepal.Length ~ Petal.Length + Species + Sepal.Width : Species | Species - . | Sepal.Width : Species - ., iris, c(1, 2))#
#
hierlm <- function(formula, datas, ratios, sep="") {#
    if (is.data.frame(datas))#
        datas <- list(datas)#
#
    data.ii <- 1#
    ratio.ii <- 1#
#
    data <- datas[data.ii]#
#
    ## Split the formula by |#
    labels <- attr(terms(formula), 'term.labels')#
    if (length(labels) == 1) { # otherwise it's just an lm formula#
        lhs <- as.character(formula)[2]#
        chunks <- strsplit(labels, "\\|")[[1]]#
        formula <- as.formula(paste(lhs, "~", chunks[1]), env=attr(formula, '.Environment'))#
        for (chunk in chunks[-1]) {#
            formula <- combine.formulae(formula, chunk)#
            terms <- get.hyper.terms(chunk)#
            if (length(terms) == 3) {#
                ## Build the new relationship#
                weight <- calc.fo.weights(formula, terms[1], ratios[ratio.ii], datas[[data.ii]]) # use original data#
                extras <- make.hyper.rows(terms[1], terms[2], weight, datas[[data.ii]])#
#
                ## Done with this ratio#
                ratio.ii <- ratio.ii + 1#
#
                ## Create indicators for nonhyper, if not already done#
                if (terms[1] %in% data)#
                    data <- replace.factor(terms[1], data, 1, sep=sep)#
#
                data <- combine.data.frames(data, extras)#
            } else {#
                ## Add in the next formula#
                data.ii <- data.ii + 1#
                data <- combine.data.frame(data, datas[[data.ii]])#
            }#
        }#
    }#
#
    print(formula)#
    lm(formula, data=data)#
}
hierlm(Sepal.Length ~ Petal.Length + Species + Sepal.Width : Species | Species - ., iris, 1)
formula
labels <- attr(terms(formula), 'term.labels')#
    if (length(labels) == 1) { # otherwise it's just an lm formula#
        lhs <- as.character(formula)[2]#
        chunks <- strsplit(labels, "\\|")[[1]]#
        formula <- as.formula(paste(lhs, "~", chunks[1]), env=attr(formula, '.Environment'))#
        for (chunk in chunks[-1]) {#
            formula <- combine.formulae(formula, chunk)#
            terms <- get.hyper.terms(chunk)#
            if (length(terms) == 3) {#
                ## Build the new relationship#
                weight <- calc.fo.weights(formula, terms[1], ratios[ratio.ii], datas[[data.ii]]) # use original data#
                extras <- make.hyper.rows(terms[1], terms[2], weight, datas[[data.ii]])#
#
                ## Done with this ratio#
                ratio.ii <- ratio.ii + 1#
#
                ## Create indicators for nonhyper, if not already done#
                if (terms[1] %in% data)#
                    data <- replace.factor(terms[1], data, 1, sep=sep)#
#
                data <- combine.data.frames(data, extras)#
            } else {#
                ## Add in the next formula#
                data.ii <- data.ii + 1#
                data <- combine.data.frame(data, datas[[data.ii]])#
            }#
        }#
    }
formula
terms
extras
weight
#' Fit an hierarchical model#
#'#
#' Interpret a hierarchical formula and fit it with the given data and weight ratios.#
#'#
#' @param formula an hierlm-style formula#
#' @param datas a data frame or a list of data frames, for each lm-style formula contained in the hierlm#
#' @param ratios a vector a ratios for the effect of fictional#
#'   observations, with length as large as the number of hyper#
#'   expressions.#
#' @return A fitted lm model#
#' @examples#
#' hierlm(Sepal.Length ~ Petal.Length + Species + Sepal.Width : Species | Species - ., iris, 1)#
#' hierlm(Sepal.Length ~ Petal.Length + Species + Sepal.Width : Species | Species - . | Sepal.Width : Species - ., iris, c(1, 2))#
#
hierlm <- function(formula, datas, ratios, sep="") {#
    if (is.data.frame(datas))#
        datas <- list(datas)#
#
    data.ii <- 1#
    ratio.ii <- 1#
#
    data <- datas[data.ii]#
#
    ## Split the formula by |#
    labels <- attr(terms(formula), 'term.labels')#
    if (length(labels) == 1) { # otherwise it's just an lm formula#
        lhs <- as.character(formula)[2]#
        chunks <- strsplit(labels, "\\|")[[1]]#
        formula <- as.formula(paste(lhs, "~", chunks[1]), env=attr(formula, '.Environment'))#
        for (chunk in chunks[-1]) {#
            # Make the new formula#
            oldformula <- formula#
            formula <- combine.formulae(formula, chunk)#
            if (!("constant" %in% names(data)) && "constant" %in% get.formula.terms(formula))#
                data$constant <- 1#
#
            terms <- get.hyper.terms(chunk)#
            if (length(terms) == 3) {#
                ## Build the new relationship#
                weight <- calc.fo.weights(oldformula, terms[1], ratios[ratio.ii], datas[[data.ii]]) # use original data#
                extras <- make.hyper.rows(terms[1], terms[2], weight, datas[[data.ii]])#
#
                ## Done with this ratio#
                ratio.ii <- ratio.ii + 1#
#
                ## Create indicators for nonhyper, if not already done#
                if (terms[1] %in% data)#
                    data <- replace.factor(terms[1], data, 1, sep=sep)#
#
                data <- combine.data.frames(data, extras)#
#
            } else {#
                ## Add in the next formula#
                data.ii <- data.ii + 1#
                data <- combine.data.frame(data, datas[[data.ii]])#
            }#
        }#
    }#
#
    print(formula)#
    lm(formula, data=data)#
}
hierlm(Sepal.Length ~ Petal.Length + Species + Sepal.Width : Species | Species - ., iris, 1)
#' Fit an hierarchical model#
#'#
#' Interpret a hierarchical formula and fit it with the given data and weight ratios.#
#'#
#' @param formula an hierlm-style formula#
#' @param datas a data frame or a list of data frames, for each lm-style formula contained in the hierlm#
#' @param ratios a vector a ratios for the effect of fictional#
#'   observations, with length as large as the number of hyper#
#'   expressions.#
#' @return A fitted lm model#
#' @examples#
#' hierlm(Sepal.Length ~ Petal.Length + Species + Sepal.Width : Species | Species - ., iris, 1)#
#' hierlm(Sepal.Length ~ Petal.Length + Species + Sepal.Width : Species | Species - . | Sepal.Width : Species - ., iris, c(1, 2))#
#
hierlm <- function(formula, datas, ratios, sep="") {#
    if (is.data.frame(datas))#
        datas <- list(datas)#
#
    data.ii <- 1#
    ratio.ii <- 1#
#
    data <- datas[data.ii]#
#
    ## Split the formula by |#
    labels <- attr(terms(formula), 'term.labels')#
    if (length(labels) == 1) { # otherwise it's just an lm formula#
        lhs <- as.character(formula)[2]#
        chunks <- strsplit(labels, "\\|")[[1]]#
        formula <- as.formula(paste(lhs, "~", chunks[1]), env=attr(formula, '.Environment'))#
        for (chunk in chunks[-1]) {#
            # Make the new formula#
            oldformula <- formula#
            formula <- combine.formulae(formula, chunk)#
            if (!("constant" %in% names(data)) && "constant" %in% get.formula.terms(formula))#
                data$constant <- 1#
#
            terms <- get.hyper.terms(chunk)#
            if (length(terms) == 3) {#
                ## Build the new relationship#
                weight <- calc.fo.weights(oldformula, terms[1], ratios[ratio.ii], datas[[data.ii]]) # use original data#
                extras <- make.hyper.rows(terms[1], terms[2], weight, datas[[data.ii]])#
#
                ## Done with this ratio#
                ratio.ii <- ratio.ii + 1#
#
                ## Create indicators for nonhyper, if not already done#
                if (terms[1] %in% data)#
                    data <- replace.factor(terms[1], data, 1, sep=sep)#
#
                print(data)#
                data <- combine.data.frames(data, extras)#
#
            } else {#
                ## Add in the next formula#
                data.ii <- data.ii + 1#
                data <- combine.data.frame(data, datas[[data.ii]])#
            }#
        }#
    }#
#
    print(formula)#
    lm(formula, data=data)#
}
hierlm(Sepal.Length ~ Petal.Length + Species + Sepal.Width : Species | Species - ., iris, 1)
#' Fit an hierarchical model#
#'#
#' Interpret a hierarchical formula and fit it with the given data and weight ratios.#
#'#
#' @param formula an hierlm-style formula#
#' @param datas a data frame or a list of data frames, for each lm-style formula contained in the hierlm#
#' @param ratios a vector a ratios for the effect of fictional#
#'   observations, with length as large as the number of hyper#
#'   expressions.#
#' @return A fitted lm model#
#' @examples#
#' hierlm(Sepal.Length ~ Petal.Length + Species + Sepal.Width : Species | Species - ., iris, 1)#
#' hierlm(Sepal.Length ~ Petal.Length + Species + Sepal.Width : Species | Species - . | Sepal.Width : Species - ., iris, c(1, 2))#
#
hierlm <- function(formula, datas, ratios, sep="") {#
    if (is.data.frame(datas))#
        datas <- list(datas)#
#
    data.ii <- 1#
    ratio.ii <- 1#
#
    data <- datas[[data.ii]]#
#
    ## Split the formula by |#
    labels <- attr(terms(formula), 'term.labels')#
    if (length(labels) == 1) { # otherwise it's just an lm formula#
        lhs <- as.character(formula)[2]#
        chunks <- strsplit(labels, "\\|")[[1]]#
        formula <- as.formula(paste(lhs, "~", chunks[1]), env=attr(formula, '.Environment'))#
        for (chunk in chunks[-1]) {#
            # Make the new formula#
            oldformula <- formula#
            formula <- combine.formulae(formula, chunk)#
            if (!("constant" %in% names(data)) && "constant" %in% get.formula.terms(formula))#
                data$constant <- 1#
#
            terms <- get.hyper.terms(chunk)#
            if (length(terms) == 3) {#
                ## Build the new relationship#
                weight <- calc.fo.weights(oldformula, terms[1], ratios[ratio.ii], datas[[data.ii]]) # use original data#
                extras <- make.hyper.rows(terms[1], terms[2], weight, datas[[data.ii]])#
#
                ## Done with this ratio#
                ratio.ii <- ratio.ii + 1#
#
                ## Create indicators for nonhyper, if not already done#
                if (terms[1] %in% data)#
                    data <- replace.factor(terms[1], data, 1, sep=sep)#
#
                data <- combine.data.frames(data, extras)#
            } else {#
                ## Add in the next formula#
                data.ii <- data.ii + 1#
                data <- combine.data.frame(data, datas[[data.ii]])#
            }#
        }#
    }#
#
    print(formula)#
    lm(formula, data=data)#
}
hierlm(Sepal.Length ~ Petal.Length + Species + Sepal.Width : Species | Species - ., iris, 1)
#' Fit an hierarchical model#
#'#
#' Interpret a hierarchical formula and fit it with the given data and weight ratios.#
#'#
#' @param formula an hierlm-style formula#
#' @param datas a data frame or a list of data frames, for each lm-style formula contained in the hierlm#
#' @param ratios a vector a ratios for the effect of fictional#
#'   observations, with length as large as the number of hyper#
#'   expressions.#
#' @return A fitted lm model#
#' @examples#
#' hierlm(Sepal.Length ~ Petal.Length + Species + Sepal.Width : Species | Species - ., iris, 1)#
#' hierlm(Sepal.Length ~ Petal.Length + Species + Sepal.Width : Species | Species - . | Sepal.Width : Species - ., iris, c(1, 2))#
#
hierlm <- function(formula, datas, ratios, sep="") {#
    if (is.data.frame(datas))#
        datas <- list(datas)#
#
    data.ii <- 1#
    ratio.ii <- 1#
#
    data <- datas[[data.ii]]#
#
    ## Split the formula by |#
    labels <- attr(terms(formula), 'term.labels')#
    if (length(labels) == 1) { # otherwise it's just an lm formula#
        lhs <- as.character(formula)[2]#
        chunks <- strsplit(labels, "\\|")[[1]]#
        formula <- as.formula(paste(lhs, "~", chunks[1]), env=attr(formula, '.Environment'))#
        for (chunk in chunks[-1]) {#
            # Make the new formula#
            oldformula <- formula#
            formula <- combine.formulae(formula, chunk)#
            if (!("constant" %in% names(data)) && "constant" %in% get.formula.terms(formula))#
                data$constant <- 1#
#
            terms <- get.hyper.terms(chunk)#
            if (length(terms) == 3) {#
                ## Build the new relationship#
                weight <- calc.fo.weights(oldformula, terms[1], ratios[ratio.ii], datas[[data.ii]]) # use original data#
                extras <- make.hyper.rows(terms[1], terms[2], weight, datas[[data.ii]])#
#
                ## Done with this ratio#
                ratio.ii <- ratio.ii + 1#
#
                ## Create indicators for nonhyper, if not already done#
                if (terms[1] %in% data)#
                    data <- replace.factor(terms[1], data, 1, sep=sep)#
#
                data <- combine.data.frames(data, extras)#
            } else {#
                ## Add in the next formula#
                data.ii <- data.ii + 1#
                data <- combine.data.frame(data, datas[[data.ii]])#
            }#
        }#
    }#
#
    print(head(data))#
    print(formula)#
    lm(formula, data=data)#
}
hierlm(Sepal.Length ~ Petal.Length + Species + Sepal.Width : Species | Species - ., iris, 1)
#' Fit an hierarchical model#
#'#
#' Interpret a hierarchical formula and fit it with the given data and weight ratios.#
#'#
#' @param formula an hierlm-style formula#
#' @param datas a data frame or a list of data frames, for each lm-style formula contained in the hierlm#
#' @param ratios a vector a ratios for the effect of fictional#
#'   observations, with length as large as the number of hyper#
#'   expressions.#
#' @return A fitted lm model#
#' @examples#
#' hierlm(Sepal.Length ~ Petal.Length + Species + Sepal.Width : Species | Species - ., iris, 1)#
#' hierlm(Sepal.Length ~ Petal.Length + Species + Sepal.Width : Species | Species - . | Sepal.Width : Species - ., iris, c(1, 2))#
#
hierlm <- function(formula, datas, ratios, sep="") {#
    if (is.data.frame(datas))#
        datas <- list(datas)#
#
    data.ii <- 1#
    ratio.ii <- 1#
#
    data <- datas[[data.ii]]#
#
    ## Split the formula by |#
    labels <- attr(terms(formula), 'term.labels')#
    if (length(labels) == 1) { # otherwise it's just an lm formula#
        lhs <- as.character(formula)[2]#
        chunks <- strsplit(labels, "\\|")[[1]]#
        formula <- as.formula(paste(lhs, "~", chunks[1]), env=attr(formula, '.Environment'))#
        for (chunk in chunks[-1]) {#
            # Make the new formula#
            oldformula <- formula#
            formula <- combine.formulae(formula, chunk)#
            if (!("constant" %in% names(data)) && "constant" %in% get.formula.terms(formula))#
                data$constant <- 1#
#
            terms <- get.hyper.terms(chunk)#
            if (length(terms) == 3) {#
                ## Build the new relationship#
                weight <- calc.fo.weights(oldformula, terms[1], ratios[ratio.ii], datas[[data.ii]]) # use original data#
                extras <- make.hyper.rows(terms[1], terms[2], weight, datas[[data.ii]])#
#
                ## Done with this ratio#
                ratio.ii <- ratio.ii + 1#
#
                ## Create indicators for nonhyper, if not already done#
                if (terms[1] %in% data)#
                    data <- replace.factor(terms[1], data, 1, sep=sep)#
#
                print(extras)#
                data <- combine.data.frames(data, extras)#
            } else {#
                ## Add in the next formula#
                data.ii <- data.ii + 1#
                data <- combine.data.frame(data, datas[[data.ii]])#
            }#
        }#
    }#
#
    print(head(data))#
    print(formula)#
    lm(formula, data=data)#
}
hierlm(Sepal.Length ~ Petal.Length + Species + Sepal.Width : Species | Species - ., iris, 1)
#' Fit an hierarchical model#
#'#
#' Interpret a hierarchical formula and fit it with the given data and weight ratios.#
#'#
#' @param formula an hierlm-style formula#
#' @param datas a data frame or a list of data frames, for each lm-style formula contained in the hierlm#
#' @param ratios a vector a ratios for the effect of fictional#
#'   observations, with length as large as the number of hyper#
#'   expressions.#
#' @return A fitted lm model#
#' @examples#
#' hierlm(Sepal.Length ~ Petal.Length + Species + Sepal.Width : Species | Species - ., iris, 1)#
#' hierlm(Sepal.Length ~ Petal.Length + Species + Sepal.Width : Species | Species - . | Sepal.Width : Species - ., iris, c(1, 2))#
#
hierlm <- function(formula, datas, ratios, sep="") {#
    if (is.data.frame(datas))#
        datas <- list(datas)#
#
    data.ii <- 1#
    ratio.ii <- 1#
#
    data <- datas[[data.ii]]#
#
    ## Split the formula by |#
    labels <- attr(terms(formula), 'term.labels')#
    if (length(labels) == 1) { # otherwise it's just an lm formula#
        lhs <- as.character(formula)[2]#
        chunks <- strsplit(labels, "\\|")[[1]]#
        formula <- as.formula(paste(lhs, "~", chunks[1]), env=attr(formula, '.Environment'))#
        for (chunk in chunks[-1]) {#
            # Make the new formula#
            oldformula <- formula#
            formula <- combine.formulae(formula, chunk)#
            if (!("constant" %in% names(data)) && "constant" %in% get.formula.terms(formula))#
                data$constant <- 1#
#
            terms <- get.hyper.terms(chunk)#
            if (length(terms) == 3) {#
                ## Build the new relationship#
                weight <- calc.fo.weights(oldformula, terms[1], ratios[ratio.ii], datas[[data.ii]]) # use original data#
                extras <- make.hyper.rows(terms[1], terms[2], weight, datas[[data.ii]])#
#
                ## Done with this ratio#
                ratio.ii <- ratio.ii + 1#
#
                ## Create indicators for nonhyper, if not already done#
                if (terms[1] %in% data)#
                    data <- replace.factor(terms[1], data, 1, sep=sep)#
#
                data <- combine.data.frames(data, extras)#
            } else {#
                ## Add in the next formula#
                data.ii <- data.ii + 1#
                data <- combine.data.frame(data, datas[[data.ii]])#
            }#
        }#
    }#
#
    print(head(data))#
    print(tail(data))#
    print(formula)#
    lm(formula, data=data)#
}
hierlm(Sepal.Length ~ Petal.Length + Species + Sepal.Width : Species | Species - ., iris, 1)
formula = Sepal.Length ~ Petal.Length : Species
get.formula.terms(formula)
#' Fit an hierarchical model#
#'#
#' Interpret a hierarchical formula and fit it with the given data and weight ratios.#
#'#
#' @param formula an hierlm-style formula#
#' @param datas a data frame or a list of data frames, for each lm-style formula contained in the hierlm#
#' @param ratios a vector a ratios for the effect of fictional#
#'   observations, with length as large as the number of hyper#
#'   expressions.#
#' @return A fitted lm model#
#' @examples#
#' hierlm(Sepal.Length ~ Petal.Length + Species + Sepal.Width : Species | Species - ., iris, 1)#
#' hierlm(Sepal.Length ~ Petal.Length + Species + Sepal.Width : Species | Species - . | Sepal.Width : Species - ., iris, c(1, 2))#
#
hierlm <- function(formula, datas, ratios, sep="") {#
    if (is.data.frame(datas))#
        datas <- list(datas)#
#
    data.ii <- 1#
    ratio.ii <- 1#
#
    data <- datas[[data.ii]]#
#
    ## Split the formula by |#
    labels <- attr(terms(formula), 'term.labels')#
    if (length(labels) == 1) { # otherwise it's just an lm formula#
        lhs <- as.character(formula)[2]#
        chunks <- strsplit(labels, "\\|")[[1]]#
        formula <- as.formula(paste(lhs, "~", chunks[1]), env=attr(formula, '.Environment'))#
        for (chunk in chunks[-1]) {#
            ## Keep these around#
            oldformula <- formula#
            olddata <- data#
#
            ## Make the new formula#
            formula <- combine.formulae(formula, chunk)#
            if (!("constant" %in% names(data)) && "constant" %in% get.formula.terms(formula))#
                data$constant <- 1#
#
            terms <- get.hyper.terms(chunk)#
            if (length(terms) == 3) {#
                ## Build the new relationship#
                weight <- calc.fo.weights(oldformula, terms[1], ratios[ratio.ii], datas[[data.ii]]) # use original data#
                extras <- make.hyper.rows(terms[1], terms[2], weight, datas[[data.ii]])#
#
                ## Done with this ratio#
                ratio.ii <- ratio.ii + 1#
#
                ## Create indicators for nonhyper, if not already done#
                if (terms[1] %in% data)#
                    data <- replace.factor(terms[1], data, 1, sep=sep)#
#
                data <- combine.data.frames(data, extras)#
            } else {#
                ## Add in the next formula#
                data.ii <- data.ii + 1#
                data <- combine.data.frame(data, datas[[data.ii]])#
            }#
#
            ## Have any of the terms in the formula been factorized?#
            checks <- get.formula.terms(formula)#
            for (check in checks) {#
                if (is.factor(olddata[, check]))#
                    formula <- replace.factor.formula(check, formula, data)#
            }#
        }#
    }#
#
    print(head(data))#
    print(tail(data))#
    print(formula)#
    lm(formula, data=data)#
}
hierlm(Sepal.Length ~ Petal.Length + Species + Sepal.Width : Species | Species - ., iris, 1)
#' Fit an hierarchical model#
#'#
#' Interpret a hierarchical formula and fit it with the given data and weight ratios.#
#'#
#' @param formula an hierlm-style formula#
#' @param datas a data frame or a list of data frames, for each lm-style formula contained in the hierlm#
#' @param ratios a vector a ratios for the effect of fictional#
#'   observations, with length as large as the number of hyper#
#'   expressions.#
#' @return A fitted lm model#
#' @examples#
#' hierlm(Sepal.Length ~ Petal.Length + Species + Sepal.Width : Species | Species - ., iris, 1)#
#' hierlm(Sepal.Length ~ Petal.Length + Species + Sepal.Width : Species | Species - . | Sepal.Width : Species - ., iris, c(1, 2))#
#
hierlm <- function(formula, datas, ratios, sep="") {#
    if (is.data.frame(datas))#
        datas <- list(datas)#
#
    data.ii <- 1#
    ratio.ii <- 1#
#
    data <- datas[[data.ii]]#
#
    ## Split the formula by |#
    labels <- attr(terms(formula), 'term.labels')#
    if (length(labels) == 1) { # otherwise it's just an lm formula#
        lhs <- as.character(formula)[2]#
        chunks <- strsplit(labels, "\\|")[[1]]#
        formula <- as.formula(paste(lhs, "~", chunks[1]), env=attr(formula, '.Environment'))#
        for (chunk in chunks[-1]) {#
            ## Keep these around#
            oldformula <- formula#
            olddata <- data#
#
            ## Make the new formula#
            formula <- combine.formulae(formula, chunk)#
            if (!("constant" %in% names(data)) && "constant" %in% get.formula.terms(formula))#
                data$constant <- 1#
#
            terms <- get.hyper.terms(chunk)#
            if (length(terms) == 3) {#
                ## Build the new relationship#
                weight <- calc.fo.weights(oldformula, terms[1], ratios[ratio.ii], datas[[data.ii]]) # use original data#
                extras <- make.hyper.rows(terms[1], terms[2], weight, datas[[data.ii]])#
#
                ## Done with this ratio#
                ratio.ii <- ratio.ii + 1#
#
                ## Create indicators for nonhyper, if not already done#
                if (terms[1] %in% data)#
                    data <- replace.factor(terms[1], data, 1, sep=sep)#
#
                data <- combine.data.frames(data, extras)#
            } else {#
                ## Add in the next formula#
                data.ii <- data.ii + 1#
                data <- combine.data.frame(data, datas[[data.ii]])#
            }#
#
            ## Have any of the terms in the formula been factorized?#
            checks <- get.formula.terms(formula)#
            for (check in checks) {#
                print(check)#
                if (is.factor(olddata[, check]))#
                    formula <- replace.factor.formula(check, formula, data)#
            }#
        }#
    }#
#
    print(head(data))#
    print(tail(data))#
    print(formula)#
    lm(formula, data=data)#
}
hierlm(Sepal.Length ~ Petal.Length + Species + Sepal.Width : Species | Species - ., iris, 1)
#' Fit an hierarchical model#
#'#
#' Interpret a hierarchical formula and fit it with the given data and weight ratios.#
#'#
#' @param formula an hierlm-style formula#
#' @param datas a data frame or a list of data frames, for each lm-style formula contained in the hierlm#
#' @param ratios a vector a ratios for the effect of fictional#
#'   observations, with length as large as the number of hyper#
#'   expressions.#
#' @return A fitted lm model#
#' @examples#
#' hierlm(Sepal.Length ~ Petal.Length + Species + Sepal.Width : Species | Species - ., iris, 1)#
#' hierlm(Sepal.Length ~ Petal.Length + Species + Sepal.Width : Species | Species - . | Sepal.Width : Species - ., iris, c(1, 2))#
#
hierlm <- function(formula, datas, ratios, sep="") {#
    if (is.data.frame(datas))#
        datas <- list(datas)#
#
    data.ii <- 1#
    ratio.ii <- 1#
#
    data <- datas[[data.ii]]#
#
    ## Split the formula by |#
    labels <- attr(terms(formula), 'term.labels')#
    if (length(labels) == 1) { # otherwise it's just an lm formula#
        lhs <- as.character(formula)[2]#
        chunks <- strsplit(labels, "\\|")[[1]]#
        formula <- as.formula(paste(lhs, "~", chunks[1]), env=attr(formula, '.Environment'))#
        for (chunk in chunks[-1]) {#
            ## Keep these around#
            oldformula <- formula#
            olddata <- data#
#
            ## Make the new formula#
            formula <- combine.formulae(formula, chunk)#
            if (!("constant" %in% names(data)) && "constant" %in% get.formula.terms(formula))#
                data$constant <- 1#
#
            terms <- get.hyper.terms(chunk)#
            if (length(terms) == 3) {#
                ## Build the new relationship#
                weight <- calc.fo.weights(oldformula, terms[1], ratios[ratio.ii], datas[[data.ii]]) # use original data#
                extras <- make.hyper.rows(terms[1], terms[2], weight, datas[[data.ii]])#
#
                ## Done with this ratio#
                ratio.ii <- ratio.ii + 1#
#
                ## Create indicators for nonhyper, if not already done#
                if (terms[1] %in% data)#
                    data <- replace.factor(terms[1], data, 1, sep=sep)#
#
                data <- combine.data.frames(data, extras)#
            } else {#
                ## Add in the next formula#
                data.ii <- data.ii + 1#
                data <- combine.data.frame(data, datas[[data.ii]])#
            }#
#
            ## Have any of the terms in the formula been factorized?#
            checks <- get.formula.terms(formula)#
            for (check in checks) {#
                if (check %in% names(olddata) && is.factor(olddata[, check]))#
                    formula <- replace.factor.formula(check, formula, data)#
            }#
        }#
    }#
#
    print(head(data))#
    print(tail(data))#
    print(formula)#
    lm(formula, data=data)#
}
hierlm(Sepal.Length ~ Petal.Length + Species + Sepal.Width : Species | Species - ., iris, 1)
#' Replace a factor term#
#'#
#' Constructs indicator terms for a factor variable.#
#'#
#' @param name term name#
#' @param formula formula#
#' @param sep paste sep used to construct factor names#
#' @return Modified formula#
#' @examples#
#' replace.factor.formula("Species", Sepal.Length ~ Species)#
#' replace.factor.formula("Species", Sepal.Length ~ Petal.Length : Species)#
#
replace.factor.formula <- function(name, formula, data, sep="") {#
    terms <- c()#
#
    for (term in get.formula.terms(formula)) {#
        if (term == name) {#
            terms <- c(terms, make.factor.names(name, data))#
        } else if (grepl(':', term)) {#
            subterms <- split.interaction.term(term)#
            if (subterms[1] == name) {#
                terms <- c(terms, paste(make.factor.names(subterms[1], data), subterms[2], sep=':'))#
            } else if (subterms[2] == name) {#
                terms <- c(terms, paste(subterms[1], make.factor.names(subterms[2], data), sep=':'))#
            } else {#
                terms <- c(terms, term)#
            }#
        } else {#
            terms <- c(terms, term)#
        }#
    }#
#
    chunks <- as.character(formula)#
    paste(chunks[2], paste(terms, collapse=" + "), sep=" ~ ")#
}
hierlm(Sepal.Length ~ Petal.Length + Species + Sepal.Width : Species | Species - ., iris, 1)
#' Make a factor name#
#'#
#' Construct a factor name for each level#
#'#
#' @param name the factor to be decomposed#
#' @param data data frame with that as a column#
#' @return Vector of the factor names#
#' @examples#
#' make.factor.names("Species", iris)#
#
make.factor.names <- function(name, data, sep="") {#
    paste(name, unique(data[, name]), sep=sep)#
}
hierlm(Sepal.Length ~ Petal.Length + Species + Sepal.Width : Species | Species - ., iris, 1)
#' Make a factor name#
#'#
#' Construct a factor name for each level#
#'#
#' @param name the factor to be decomposed#
#' @param data data frame with that as a column#
#' @return Vector of the factor names#
#' @examples#
#' make.factor.names("Species", iris)#
#
make.factor.names <- function(name, data, sep="") {#
    print(1)#
    x = paste(name, unique(data[, name]), sep=sep)#
    print(2)#
    x#
}
hierlm(Sepal.Length ~ Petal.Length + Species + Sepal.Width : Species | Species - ., iris, 1)
#' Make a factor name#
#'#
#' Construct a factor name for each level#
#'#
#' @param name the factor to be decomposed#
#' @param data data frame with that as a column#
#' @return Vector of the factor names#
#' @examples#
#' make.factor.names("Species", iris)#
#
make.factor.names <- function(name, data, sep="") {#
    print(names(data))#
    x = paste(name, unique(data[, name]), sep=sep)#
    print(2)#
    x#
}
hierlm(Sepal.Length ~ Petal.Length + Species + Sepal.Width : Species | Species - ., iris, 1)
#' Make a factor name#
#'#
#' Construct a factor name for each level#
#'#
#' @param name the factor to be decomposed#
#' @param data data frame with that as a column#
#' @return Vector of the factor names#
#' @examples#
#' make.factor.names("Species", iris)#
#
make.factor.names <- function(name, data, sep="") {#
    print(name)#
    print(names(data))#
    x = paste(name, unique(data[, name]), sep=sep)#
    print(2)#
    x#
}
hierlm(Sepal.Length ~ Petal.Length + Species + Sepal.Width : Species | Species - ., iris, 1)
#' Replace a factor term#
#'#
#' Constructs indicator terms for a factor variable.#
#'#
#' @param name term name#
#' @param formula formula#
#' @param sep paste sep used to construct factor names#
#' @return Modified formula#
#' @examples#
#' replace.factor.formula("Species", Sepal.Length ~ Species)#
#' replace.factor.formula("Species", Sepal.Length ~ Petal.Length : Species)#
#
replace.factor.formula <- function(name, formula, data, sep="") {#
    print(1)#
    terms <- c()#
#
    for (term in get.formula.terms(formula)) {#
        if (term == name) {#
            terms <- c(terms, make.factor.names(name, data))#
        } else if (grepl(':', term)) {#
            subterms <- split.interaction.term(term)#
            if (subterms[1] == name) {#
                terms <- c(terms, paste(make.factor.names(subterms[1], data), subterms[2], sep=':'))#
            } else if (subterms[2] == name) {#
                terms <- c(terms, paste(subterms[1], make.factor.names(subterms[2], data), sep=':'))#
            } else {#
                terms <- c(terms, term)#
            }#
        } else {#
            terms <- c(terms, term)#
        }#
    }#
#
    chunks <- as.character(formula)#
    print(2)#
    paste(chunks[2], paste(terms, collapse=" + "), sep=" ~ ")#
}
hierlm(Sepal.Length ~ Petal.Length + Species + Sepal.Width : Species | Species - ., iris, 1)
#' Replace a factor term#
#'#
#' Constructs indicator terms for a factor variable.#
#'#
#' @param name term name#
#' @param formula formula#
#' @param sep paste sep used to construct factor names#
#' @return Modified formula#
#' @examples#
#' replace.factor.formula("Species", Sepal.Length ~ Species)#
#' replace.factor.formula("Species", Sepal.Length ~ Petal.Length : Species)#
#
replace.factor.formula <- function(name, formula, data, sep="") {#
    print(1)#
    print(names(data))#
    terms <- c()#
#
    for (term in get.formula.terms(formula)) {#
        if (term == name) {#
            terms <- c(terms, make.factor.names(name, data))#
        } else if (grepl(':', term)) {#
            subterms <- split.interaction.term(term)#
            if (subterms[1] == name) {#
                terms <- c(terms, paste(make.factor.names(subterms[1], data), subterms[2], sep=':'))#
            } else if (subterms[2] == name) {#
                terms <- c(terms, paste(subterms[1], make.factor.names(subterms[2], data), sep=':'))#
            } else {#
                terms <- c(terms, term)#
            }#
        } else {#
            terms <- c(terms, term)#
        }#
    }#
#
    chunks <- as.character(formula)#
    print(2)#
    paste(chunks[2], paste(terms, collapse=" + "), sep=" ~ ")#
}
hierlm(Sepal.Length ~ Petal.Length + Species + Sepal.Width : Species | Species - ., iris, 1)
#' Make a factor name#
#'#
#' Construct a factor name for each level#
#'#
#' @param name the factor to be decomposed#
#' @param data data frame with that as a column#
#' @return Vector of the factor names#
#' @examples#
#' make.factor.names("Species", iris)#
#
make.factor.names <- function(name, data, sep="") {#
    paste(name, unique(data[, name]), sep=sep)#
}
#' Fit an hierarchical model#
#'#
#' Interpret a hierarchical formula and fit it with the given data and weight ratios.#
#'#
#' @param formula an hierlm-style formula#
#' @param datas a data frame or a list of data frames, for each lm-style formula contained in the hierlm#
#' @param ratios a vector a ratios for the effect of fictional#
#'   observations, with length as large as the number of hyper#
#'   expressions.#
#' @return A fitted lm model#
#' @examples#
#' hierlm(Sepal.Length ~ Petal.Length + Species + Sepal.Width : Species | Species - ., iris, 1)#
#' hierlm(Sepal.Length ~ Petal.Length + Species + Sepal.Width : Species | Species - . | Sepal.Width : Species - ., iris, c(1, 2))#
#
hierlm <- function(formula, datas, ratios, sep="") {#
    if (is.data.frame(datas))#
        datas <- list(datas)#
#
    data.ii <- 1#
    ratio.ii <- 1#
#
    data <- datas[[data.ii]]#
#
    ## Split the formula by |#
    labels <- attr(terms(formula), 'term.labels')#
    if (length(labels) == 1) { # otherwise it's just an lm formula#
        lhs <- as.character(formula)[2]#
        chunks <- strsplit(labels, "\\|")[[1]]#
        formula <- as.formula(paste(lhs, "~", chunks[1]), env=attr(formula, '.Environment'))#
        for (chunk in chunks[-1]) {#
            ## Keep these around#
            oldformula <- formula#
            olddata <- data#
#
            ## Make the new formula#
            formula <- combine.formulae(formula, chunk)#
            if (!("constant" %in% names(data)) && "constant" %in% get.formula.terms(formula))#
                data$constant <- 1#
#
            terms <- get.hyper.terms(chunk)#
            if (length(terms) == 3) {#
                ## Build the new relationship#
                weight <- calc.fo.weights(oldformula, terms[1], ratios[ratio.ii], datas[[data.ii]]) # use original data#
                extras <- make.hyper.rows(terms[1], terms[2], weight, datas[[data.ii]])#
#
                ## Done with this ratio#
                ratio.ii <- ratio.ii + 1#
#
                ## Create indicators for nonhyper, if not already done#
                if (terms[1] %in% data)#
                    data <- replace.factor(terms[1], data, 1, sep=sep)#
#
                data <- combine.data.frames(data, extras)#
            } else {#
                ## Add in the next formula#
                data.ii <- data.ii + 1#
                data <- combine.data.frame(data, datas[[data.ii]])#
            }#
#
            ## Have any of the terms in the formula been factorized?#
            checks <- get.formula.terms(formula)#
            for (check in checks) {#
                if (check %in% names(olddata) && is.factor(olddata[, check]))#
                    formula <- replace.factor.formula(check, formula, olddata)#
            }#
        }#
    }#
#
    print(head(data))#
    print(tail(data))#
    print(formula)#
    lm(formula, data=data)#
}
hierlm(Sepal.Length ~ Petal.Length + Species + Sepal.Width : Species | Species - ., iris, 1)
#' Replace a factor term#
#'#
#' Constructs indicator terms for a factor variable.#
#'#
#' @param name term name#
#' @param formula formula#
#' @param sep paste sep used to construct factor names#
#' @return Modified formula#
#' @examples#
#' replace.factor.formula("Species", Sepal.Length ~ Species)#
#' replace.factor.formula("Species", Sepal.Length ~ Petal.Length : Species)#
#
replace.factor.formula <- function(name, formula, data, sep="") {#
    terms <- c()#
#
    for (term in get.formula.terms(formula)) {#
        if (term == name) {#
            terms <- c(terms, make.factor.names(name, data))#
        } else if (grepl(':', term)) {#
            subterms <- split.interaction.term(term)#
            if (subterms[1] == name) {#
                terms <- c(terms, paste(make.factor.names(subterms[1], data), subterms[2], sep=':'))#
            } else if (subterms[2] == name) {#
                terms <- c(terms, paste(subterms[1], make.factor.names(subterms[2], data), sep=':'))#
            } else {#
                terms <- c(terms, term)#
            }#
        } else {#
            terms <- c(terms, term)#
        }#
    }#
#
    chunks <- as.character(formula)#
    paste(chunks[2], paste(terms, collapse=" + "), sep=" ~ ")#
}
hierlm(Sepal.Length ~ Petal.Length + Species + Sepal.Width : Species | Species - ., iris, 1)
#' Split an Interaction Term#
#'#
#' Extract the two pieces of an interaction term#
#'#
#' @param term An interaction (a:b) term#
#' @return Vector of the subterms (c(a, b))#
#' @examples#
#' split.interaction.term("Petal.Length : Species")#
#
split.interaction.term <- function(term) {#
    subterms <- strsplit(term, ":")[[1]]#
    gsub("^\\s+|\\s+$", "", subterms)#
}
hierlm(Sepal.Length ~ Petal.Length + Species + Sepal.Width : Species | Species - ., iris, 1)
summary(hierlm(Sepal.Length ~ Petal.Length + Species + Sepal.Width : Species | Species - ., iris, 1))
summary(hierlm(Sepal.Length ~ 0 + Petal.Length + Species + Sepal.Width : Species | Species - ., iris, 1))
hierlm(Sepal.Length ~ 0 + Petal.Length + Species + Sepal.Width : Species | Species - . | Sepal.Width : Species - ., iris, c(1, 2))
formula = Sepal.Length ~ 0 + Petal.Length + Species + Sepal.Width : Species | Species - . | Sepal.Width : Species - .
datas = iris
ratios = c(1, 2)
if (is.data.frame(datas))#
        datas <- list(datas)#
#
    data.ii <- 1#
    ratio.ii <- 1#
#
    data <- datas[[data.ii]]#
#
    ## Split the formula by |#
    labels <- attr(terms(formula), 'term.labels')#
    if (length(labels) == 1) { # otherwise it's just an lm formula#
        lhs <- as.character(formula)[2]#
        chunks <- strsplit(labels, "\\|")[[1]]#
        formula <- as.formula(paste(lhs, "~", chunks[1]), env=attr(formula, '.Environment'))#
        for (chunk in chunks[-1]) {#
            ## Keep these around#
            oldformula <- formula#
            olddata <- data#
#
            ## Make the new formula#
            formula <- combine.formulae(formula, chunk)#
            if (!("constant" %in% names(data)) && "constant" %in% get.formula.terms(formula))#
                data$constant <- 1#
#
            terms <- get.hyper.terms(chunk)#
            if (length(terms) == 3) {#
                ## Build the new relationship#
                weight <- calc.fo.weights(oldformula, terms[1], ratios[ratio.ii], datas[[data.ii]]) # use original data#
                extras <- make.hyper.rows(terms[1], terms[2], weight, datas[[data.ii]])#
#
                ## Done with this ratio#
                ratio.ii <- ratio.ii + 1#
#
                ## Create indicators for nonhyper, if not already done#
                if (terms[1] %in% data)#
                    data <- replace.factor(terms[1], data, 1, sep=sep)#
#
                data <- combine.data.frames(data, extras)#
            } else {#
                ## Add in the next formula#
                data.ii <- data.ii + 1#
                data <- combine.data.frame(data, datas[[data.ii]])#
            }#
#
            ## Have any of the terms in the formula been factorized?#
            checks <- get.formula.terms(formula)#
            for (check in checks) {#
                if (check %in% names(olddata) && is.factor(olddata[, check]))#
                    formula <- replace.factor.formula(check, formula, olddata)#
            }#
        }#
    }#
#
    print(head(data))#
    print(tail(data))#
    print(formula)#
    lm(formula, data=data)
#' Fit an hierarchical model#
#'#
#' Interpret a hierarchical formula and fit it with the given data and weight ratios.#
#'#
#' @param formula an hierlm-style formula#
#' @param datas a data frame or a list of data frames, for each lm-style formula contained in the hierlm#
#' @param ratios a vector a ratios for the effect of fictional#
#'   observations, with length as large as the number of hyper#
#'   expressions.#
#' @return A fitted lm model#
#' @examples#
#' hierlm(Sepal.Length ~ 0 + Petal.Length + Species + Sepal.Width : Species | Species - ., iris, 1)#
#' hierlm(Sepal.Length ~ 0 + Petal.Length + Species + Sepal.Width : Species | Species - . | Sepal.Width : Species - ., iris, c(1, 2))#
#
hierlm <- function(formula, datas, ratios, sep="") {#
    if (is.data.frame(datas))#
        datas <- list(datas)#
#
    data.ii <- 1#
    ratio.ii <- 1#
#
    data <- datas[[data.ii]]#
#
    ## Split the formula by |#
    labels <- attr(terms(formula), 'term.labels')#
    if (length(labels) == 1) { # otherwise it's just an lm formula#
        lhs <- as.character(formula)[2]#
        chunks <- strsplit(labels, "\\|")[[1]]#
        formula <- as.formula(paste(lhs, "~", chunks[1]), env=attr(formula, '.Environment'))#
        for (chunk in chunks[-1]) {#
            ## Keep these around#
            oldformula <- formula#
            olddata <- data#
#
            ## Make the new formula#
            formula <- combine.formulae(formula, chunk)#
            if (!("constant" %in% names(data)) && "constant" %in% get.formula.terms(formula))#
                data$constant <- 1#
#
            terms <- get.hyper.terms(chunk)#
            if (length(terms) == 3) {#
                ## Build the new relationship#
                weight <- calc.fo.weights(oldformula, terms[1], ratios[ratio.ii], datas[[data.ii]]) # use original data#
                extras <- make.hyper.rows(terms[1], terms[2], weight, datas[[data.ii]])#
#
                ## Done with this ratio#
                ratio.ii <- ratio.ii + 1#
#
                ## Create indicators for nonhyper, if not already done#
                if (terms[1] %in% data)#
                    data <- replace.factor(terms[1], data, 1, sep=sep)#
#
                data <- combine.data.frames(data, extras)#
            } else {#
                ## Add in the next formula#
                data.ii <- data.ii + 1#
                data <- combine.data.frame(data, datas[[data.ii]])#
            }#
#
            ## Have any of the terms in the formula been factorized?#
            checks <- get.formula.terms(formula)#
            for (check in checks) {#
                if (check %in% names(olddata) && is.factor(olddata[, check]))#
                    formula <- replace.factor.formula(check, formula, olddata)#
            }#
        }#
    }#
#
    print(head(data))#
    print(tail(data))#
    print(formula)#
    lm(formula, data=data)#
}
hierlm(Sepal.Length ~ 0 + Petal.Length + Species + Sepal.Width : Species | Species - . | Sepal.Width : Species - ., iris, c(1, 2))
#' Fit an hierarchical model#
#'#
#' Interpret a hierarchical formula and fit it with the given data and weight ratios.#
#'#
#' @param formula an hierlm-style formula#
#' @param datas a data frame or a list of data frames, for each lm-style formula contained in the hierlm#
#' @param ratios a vector a ratios for the effect of fictional#
#'   observations, with length as large as the number of hyper#
#'   expressions.#
#' @return A fitted lm model#
#' @examples#
#' hierlm(Sepal.Length ~ 0 + Petal.Length + Species + Sepal.Width : Species | Species - ., iris, 1)#
#' hierlm(Sepal.Length ~ 0 + Petal.Length + Species + Sepal.Width : Species | Species - . | Sepal.Width : Species - ., iris, c(1, 2))#
#
hierlm <- function(formula, datas, ratios, sep="") {#
    if (is.data.frame(datas))#
        datas <- list(datas)#
#
    data.ii <- 1#
    ratio.ii <- 1#
#
    data <- datas[[data.ii]]#
#
    ## Split the formula by |#
    labels <- attr(terms(formula), 'term.labels')#
    if (length(labels) == 1) { # otherwise it's just an lm formula#
        lhs <- as.character(formula)[2]#
        chunks <- strsplit(labels, "\\|")[[1]]#
        formula <- as.formula(paste(lhs, "~", chunks[1]), env=attr(formula, '.Environment'))#
        for (chunk in chunks[-1]) {#
            print(chunk)#
            ## Keep these around#
            oldformula <- formula#
            olddata <- data#
#
            ## Make the new formula#
            formula <- combine.formulae(formula, chunk)#
            if (!("constant" %in% names(data)) && "constant" %in% get.formula.terms(formula))#
                data$constant <- 1#
#
            terms <- get.hyper.terms(chunk)#
            if (length(terms) == 3) {#
                ## Build the new relationship#
                weight <- calc.fo.weights(oldformula, terms[1], ratios[ratio.ii], datas[[data.ii]]) # use original data#
                extras <- make.hyper.rows(terms[1], terms[2], weight, datas[[data.ii]])#
#
                ## Done with this ratio#
                ratio.ii <- ratio.ii + 1#
#
                ## Create indicators for nonhyper, if not already done#
                if (terms[1] %in% data)#
                    data <- replace.factor(terms[1], data, 1, sep=sep)#
#
                data <- combine.data.frames(data, extras)#
            } else {#
                ## Add in the next formula#
                data.ii <- data.ii + 1#
                data <- combine.data.frame(data, datas[[data.ii]])#
            }#
#
            ## Have any of the terms in the formula been factorized?#
            checks <- get.formula.terms(formula)#
            for (check in checks) {#
                if (check %in% names(olddata) && is.factor(olddata[, check]))#
                    formula <- replace.factor.formula(check, formula, olddata)#
            }#
        }#
    }#
#
    print(head(data))#
    print(tail(data))#
    print(formula)#
    lm(formula, data=data)#
}
hierlm(Sepal.Length ~ 0 + Petal.Length + Species + Sepal.Width : Species | Species - . | Sepal.Width : Species - ., iris, c(1, 2))
#' Fit an hierarchical model#
#'#
#' Interpret a hierarchical formula and fit it with the given data and weight ratios.#
#'#
#' @param formula an hierlm-style formula#
#' @param datas a data frame or a list of data frames, for each lm-style formula contained in the hierlm#
#' @param ratios a vector a ratios for the effect of fictional#
#'   observations, with length as large as the number of hyper#
#'   expressions.#
#' @return A fitted lm model#
#' @examples#
#' hierlm(Sepal.Length ~ 0 + Petal.Length + Species + Sepal.Width : Species | Species - ., iris, 1)#
#' hierlm(Sepal.Length ~ 0 + Petal.Length + Species + Sepal.Width : Species | Species - . | Sepal.Width : Species - ., iris, c(1, 2))#
#
hierlm <- function(formula, datas, ratios, sep="") {#
    if (is.data.frame(datas))#
        datas <- list(datas)#
#
    data.ii <- 1#
    ratio.ii <- 1#
#
    data <- datas[[data.ii]]#
#
    ## Split the formula by |#
    labels <- attr(terms(formula), 'term.labels')#
    if (length(labels) == 1) { # otherwise it's just an lm formula#
        lhs <- as.character(formula)[2]#
        chunks <- strsplit(labels, "\\|")[[1]]#
        formula <- as.formula(paste(lhs, "~", chunks[1]), env=attr(formula, '.Environment'))#
        for (chunk in chunks[-1]) {#
            print(chunk)#
            ## Keep these around#
            oldformula <- formula#
            olddata <- data#
#
            ## Make the new formula#
            formula <- combine.formulae(formula, chunk)#
            if (!("constant" %in% names(data)) && "constant" %in% get.formula.terms(formula))#
                data$constant <- 1#
#
            terms <- get.hyper.terms(chunk)#
            if (length(terms) == 3) {#
                ## Build the new relationship#
                weight <- calc.fo.weights(oldformula, terms[1], ratios[ratio.ii], datas[[data.ii]]) # use original data#
                print("ao")#
                extras <- make.hyper.rows(terms[1], terms[2], weight, datas[[data.ii]])#
#
                ## Done with this ratio#
                ratio.ii <- ratio.ii + 1#
#
                ## Create indicators for nonhyper, if not already done#
                if (terms[1] %in% data)#
                    data <- replace.factor(terms[1], data, 1, sep=sep)#
#
                data <- combine.data.frames(data, extras)#
            } else {#
                ## Add in the next formula#
                data.ii <- data.ii + 1#
                data <- combine.data.frame(data, datas[[data.ii]])#
            }#
#
            ## Have any of the terms in the formula been factorized?#
            checks <- get.formula.terms(formula)#
            for (check in checks) {#
                if (check %in% names(olddata) && is.factor(olddata[, check]))#
                    formula <- replace.factor.formula(check, formula, olddata)#
            }#
        }#
    }#
#
    print(head(data))#
    print(tail(data))#
    print(formula)#
    lm(formula, data=data)#
}
hierlm(Sepal.Length ~ 0 + Petal.Length + Species + Sepal.Width : Species | Species - . | Sepal.Width : Species - ., iris, c(1, 2))
#' Fit an hierarchical model#
#'#
#' Interpret a hierarchical formula and fit it with the given data and weight ratios.#
#'#
#' @param formula an hierlm-style formula#
#' @param datas a data frame or a list of data frames, for each lm-style formula contained in the hierlm#
#' @param ratios a vector a ratios for the effect of fictional#
#'   observations, with length as large as the number of hyper#
#'   expressions.#
#' @return A fitted lm model#
#' @examples#
#' hierlm(Sepal.Length ~ 0 + Petal.Length + Species + Sepal.Width : Species | Species - ., iris, 1)#
#' hierlm(Sepal.Length ~ 0 + Petal.Length + Species + Sepal.Width : Species | Species - . | Sepal.Width : Species - ., iris, c(1, 2))#
#
hierlm <- function(formula, datas, ratios, sep="") {#
    if (is.data.frame(datas))#
        datas <- list(datas)#
#
    data.ii <- 1#
    ratio.ii <- 1#
#
    data <- datas[[data.ii]]#
#
    ## Split the formula by |#
    labels <- attr(terms(formula), 'term.labels')#
    if (length(labels) == 1) { # otherwise it's just an lm formula#
        lhs <- as.character(formula)[2]#
        chunks <- strsplit(labels, "\\|")[[1]]#
        formula <- as.formula(paste(lhs, "~", chunks[1]), env=attr(formula, '.Environment'))#
        for (chunk in chunks[-1]) {#
            print(chunk)#
            ## Keep these around#
            oldformula <- formula#
            olddata <- data#
#
            ## Make the new formula#
            formula <- combine.formulae(formula, chunk)#
            if (!("constant" %in% names(data)) && "constant" %in% get.formula.terms(formula))#
                data$constant <- 1#
#
            terms <- get.hyper.terms(chunk)#
            if (length(terms) == 3) {#
                print("ab")#
                ## Build the new relationship#
                weight <- calc.fo.weights(oldformula, terms[1], ratios[ratio.ii], datas[[data.ii]]) # use original data#
                print("ao")#
                extras <- make.hyper.rows(terms[1], terms[2], weight, datas[[data.ii]])#
#
                ## Done with this ratio#
                ratio.ii <- ratio.ii + 1#
#
                ## Create indicators for nonhyper, if not already done#
                if (terms[1] %in% data)#
                    data <- replace.factor(terms[1], data, 1, sep=sep)#
#
                data <- combine.data.frames(data, extras)#
            } else {#
                ## Add in the next formula#
                data.ii <- data.ii + 1#
                data <- combine.data.frame(data, datas[[data.ii]])#
            }#
#
            ## Have any of the terms in the formula been factorized?#
            checks <- get.formula.terms(formula)#
            for (check in checks) {#
                if (check %in% names(olddata) && is.factor(olddata[, check]))#
                    formula <- replace.factor.formula(check, formula, olddata)#
            }#
        }#
    }#
#
    print(head(data))#
    print(tail(data))#
    print(formula)#
    lm(formula, data=data)#
}
hierlm(Sepal.Length ~ 0 + Petal.Length + Species + Sepal.Width : Species | Species - . | Sepal.Width : Species - ., iris, c(1, 2))
#' Fit an hierarchical model#
#'#
#' Interpret a hierarchical formula and fit it with the given data and weight ratios.#
#'#
#' @param formula an hierlm-style formula#
#' @param datas a data frame or a list of data frames, for each lm-style formula contained in the hierlm#
#' @param ratios a vector a ratios for the effect of fictional#
#'   observations, with length as large as the number of hyper#
#'   expressions.#
#' @return A fitted lm model#
#' @examples#
#' hierlm(Sepal.Length ~ 0 + Petal.Length + Species + Sepal.Width : Species | Species - ., iris, 1)#
#' hierlm(Sepal.Length ~ 0 + Petal.Length + Species + Sepal.Width : Species | Species - . | Sepal.Width : Species - ., iris, c(1, 2))#
#
hierlm <- function(formula, datas, ratios, sep="") {#
    if (is.data.frame(datas))#
        datas <- list(datas)#
#
    data.ii <- 1#
    ratio.ii <- 1#
#
    data <- datas[[data.ii]]#
#
    ## Split the formula by |#
    labels <- attr(terms(formula), 'term.labels')#
    if (length(labels) == 1) { # otherwise it's just an lm formula#
        lhs <- as.character(formula)[2]#
        chunks <- strsplit(labels, "\\|")[[1]]#
        formula <- as.formula(paste(lhs, "~", chunks[1]), env=attr(formula, '.Environment'))#
        for (chunk in chunks[-1]) {#
            print(chunk)#
            ## Keep these around#
            oldformula <- formula#
            olddata <- data#
#
            ## Make the new formula#
            formula <- combine.formulae(formula, chunk)#
            if (!("constant" %in% names(data)) && "constant" %in% get.formula.terms(formula))#
                data$constant <- 1#
#
            print("xx")#
            terms <- get.hyper.terms(chunk)#
            if (length(terms) == 3) {#
                print("ab")#
                ## Build the new relationship#
                weight <- calc.fo.weights(oldformula, terms[1], ratios[ratio.ii], datas[[data.ii]]) # use original data#
                print("ao")#
                extras <- make.hyper.rows(terms[1], terms[2], weight, datas[[data.ii]])#
#
                ## Done with this ratio#
                ratio.ii <- ratio.ii + 1#
#
                ## Create indicators for nonhyper, if not already done#
                if (terms[1] %in% data)#
                    data <- replace.factor(terms[1], data, 1, sep=sep)#
#
                data <- combine.data.frames(data, extras)#
            } else {#
                ## Add in the next formula#
                data.ii <- data.ii + 1#
                data <- combine.data.frame(data, datas[[data.ii]])#
            }#
#
            ## Have any of the terms in the formula been factorized?#
            checks <- get.formula.terms(formula)#
            for (check in checks) {#
                if (check %in% names(olddata) && is.factor(olddata[, check]))#
                    formula <- replace.factor.formula(check, formula, olddata)#
            }#
        }#
    }#
#
    print(head(data))#
    print(tail(data))#
    print(formula)#
    lm(formula, data=data)#
}
hierlm(Sepal.Length ~ 0 + Petal.Length + Species + Sepal.Width : Species | Species - . | Sepal.Width : Species - ., iris, c(1, 2))
#' Fit an hierarchical model#
#'#
#' Interpret a hierarchical formula and fit it with the given data and weight ratios.#
#'#
#' @param formula an hierlm-style formula#
#' @param datas a data frame or a list of data frames, for each lm-style formula contained in the hierlm#
#' @param ratios a vector a ratios for the effect of fictional#
#'   observations, with length as large as the number of hyper#
#'   expressions.#
#' @return A fitted lm model#
#' @examples#
#' hierlm(Sepal.Length ~ 0 + Petal.Length + Species + Sepal.Width : Species | Species - ., iris, 1)#
#' hierlm(Sepal.Length ~ 0 + Petal.Length + Species + Sepal.Width : Species | Species - . | Sepal.Width : Species - ., iris, c(1, 2))#
#
hierlm <- function(formula, datas, ratios, sep="") {#
    if (is.data.frame(datas))#
        datas <- list(datas)#
#
    data.ii <- 1#
    ratio.ii <- 1#
#
    data <- datas[[data.ii]]#
#
    ## Split the formula by |#
    labels <- attr(terms(formula), 'term.labels')#
    if (length(labels) == 1) { # otherwise it's just an lm formula#
        lhs <- as.character(formula)[2]#
        chunks <- strsplit(labels, "\\|")[[1]]#
        formula <- as.formula(paste(lhs, "~", chunks[1]), env=attr(formula, '.Environment'))#
        for (chunk in chunks[-1]) {#
            print(chunk)#
            ## Keep these around#
            oldformula <- formula#
            olddata <- data#
#
            ## Make the new formula#
            formula <- combine.formulae(formula, chunk)#
            print("vv")#
            if (!("constant" %in% names(data)) && "constant" %in% get.formula.terms(formula))#
                data$constant <- 1#
#
            print("xx")#
            terms <- get.hyper.terms(chunk)#
            if (length(terms) == 3) {#
                print("ab")#
                ## Build the new relationship#
                weight <- calc.fo.weights(oldformula, terms[1], ratios[ratio.ii], datas[[data.ii]]) # use original data#
                print("ao")#
                extras <- make.hyper.rows(terms[1], terms[2], weight, datas[[data.ii]])#
#
                ## Done with this ratio#
                ratio.ii <- ratio.ii + 1#
#
                ## Create indicators for nonhyper, if not already done#
                if (terms[1] %in% data)#
                    data <- replace.factor(terms[1], data, 1, sep=sep)#
#
                data <- combine.data.frames(data, extras)#
            } else {#
                ## Add in the next formula#
                data.ii <- data.ii + 1#
                data <- combine.data.frame(data, datas[[data.ii]])#
            }#
#
            ## Have any of the terms in the formula been factorized?#
            checks <- get.formula.terms(formula)#
            for (check in checks) {#
                if (check %in% names(olddata) && is.factor(olddata[, check]))#
                    formula <- replace.factor.formula(check, formula, olddata)#
            }#
        }#
    }#
#
    print(head(data))#
    print(tail(data))#
    print(formula)#
    lm(formula, data=data)#
}
hierlm(Sepal.Length ~ 0 + Petal.Length + Species + Sepal.Width : Species | Species - . | Sepal.Width : Species - ., iris, c(1, 2))
#' Combine two formulas in hierlm-format#
#'#
#' Return the left and right side of a new combined formula.#
#' Left formula must be a standard formula.  Right formula may take the following forms:#
#' y ~ ... : an lm-style formula; the left-hand-side variables much match#
#' f - b : A requirement that two variables be close together (typically one is a factor)#
#' f - . : A requirement that a variable (or set of factors) be close to a new hyper-variable#
#' a : f - [b or .] : A requirement that the results of an interaction be near a hyper-variable#
#' TODO:#
#' a + B : A requirement that the factors in 'a' are similar to eachother by smoothness 'B'#
#'#
#' @param formula1 an lm-style formula#
#' @param formula2 an additional formula or hierlm term#
#' @return Augmented formula#
#' @examples#
#' combine.formulae(combine.formulae(combine.formulae(y ~ a + b, "b - c"), y ~ c + d), "c : d - .")#
#
combine.formulae <- function(formula1, formula2, sep="") {#
    chunks1 <- as.character(formula1)#
#
    if (is.character(formula2))#
        if (grepl("~", formula2))#
            formula2 <- as.formula(formula2)#
#
    if (class(formula2) == "formula") {#
        chunks2 <- as.character(formula2)#
        if (chunks2[2] != chunks1[2])#
            error("Left-hand-side variables do not match.")#
#
        terms1 <- get.formula.terms(formula1)#
        terms2 <- get.formula.terms(formula2)#
    } else {#
        print("yy")#
        terms2 <- get.hyper.terms(formula2, sep=sep)#
        if (length(terms2) != 3)#
            error(paste("Cannot understand expression:", formula2))#
#
        terms2 <- terms2[-3]#
#
        terms1 <- get.formula.terms(formula1)#
        if (attr(terms(formula1), 'intercept') == 0) {#
            if (!("0" %in% terms1))#
                terms1 <- c("0", terms1)#
        } else {#
            if (!("0" %in% terms1 && "constant" %in% terms1))#
                terms1 <- c("0", "constant", terms1)#
        }#
    }#
#
    for (term in terms2)#
        if (!(term %in% terms1))#
            terms1 <- c(terms1, term)#
#
    as.formula(paste(chunks1[2], "~", paste(terms1, collapse=" + ")),#
               env=attr(formula1, '.Environment'))#
}
hierlm(Sepal.Length ~ 0 + Petal.Length + Species + Sepal.Width : Species | Species - . | Sepal.Width : Species - ., iris, c(1, 2))
#' Combine two formulas in hierlm-format#
#'#
#' Return the left and right side of a new combined formula.#
#' Left formula must be a standard formula.  Right formula may take the following forms:#
#' y ~ ... : an lm-style formula; the left-hand-side variables much match#
#' f - b : A requirement that two variables be close together (typically one is a factor)#
#' f - . : A requirement that a variable (or set of factors) be close to a new hyper-variable#
#' a : f - [b or .] : A requirement that the results of an interaction be near a hyper-variable#
#' TODO:#
#' a + B : A requirement that the factors in 'a' are similar to eachother by smoothness 'B'#
#'#
#' @param formula1 an lm-style formula#
#' @param formula2 an additional formula or hierlm term#
#' @return Augmented formula#
#' @examples#
#' combine.formulae(combine.formulae(combine.formulae(y ~ a + b, "b - c"), y ~ c + d), "c : d - .")#
#
combine.formulae <- function(formula1, formula2, sep="") {#
    chunks1 <- as.character(formula1)#
#
    if (is.character(formula2))#
        if (grepl("~", formula2))#
            formula2 <- as.formula(formula2)#
#
    if (class(formula2) == "formula") {#
        chunks2 <- as.character(formula2)#
        if (chunks2[2] != chunks1[2])#
            error("Left-hand-side variables do not match.")#
#
        terms1 <- get.formula.terms(formula1)#
        terms2 <- get.formula.terms(formula2)#
    } else {#
        print("yy")#
        terms2 <- get.hyper.terms(formula2, sep=sep)#
        if (length(terms2) != 3)#
            error(paste("Cannot understand expression:", formula2))#
#
        terms2 <- terms2[-3]#
#
        terms1 <- get.formula.terms(formula1)#
        print("uu")#
        if (attr(terms(formula1), 'intercept') == 0) {#
            if (!("0" %in% terms1))#
                terms1 <- c("0", terms1)#
        } else {#
            if (!("0" %in% terms1 && "constant" %in% terms1))#
                terms1 <- c("0", "constant", terms1)#
        }#
    }#
#
    for (term in terms2)#
        if (!(term %in% terms1))#
            terms1 <- c(terms1, term)#
#
    as.formula(paste(chunks1[2], "~", paste(terms1, collapse=" + ")),#
               env=attr(formula1, '.Environment'))#
}
hierlm(Sepal.Length ~ 0 + Petal.Length + Species + Sepal.Width : Species | Species - . | Sepal.Width : Species - ., iris, c(1, 2))
#' Combine two formulas in hierlm-format#
#'#
#' Return the left and right side of a new combined formula.#
#' Left formula must be a standard formula.  Right formula may take the following forms:#
#' y ~ ... : an lm-style formula; the left-hand-side variables much match#
#' f - b : A requirement that two variables be close together (typically one is a factor)#
#' f - . : A requirement that a variable (or set of factors) be close to a new hyper-variable#
#' a : f - [b or .] : A requirement that the results of an interaction be near a hyper-variable#
#' TODO:#
#' a + B : A requirement that the factors in 'a' are similar to eachother by smoothness 'B'#
#'#
#' @param formula1 an lm-style formula#
#' @param formula2 an additional formula or hierlm term#
#' @return Augmented formula#
#' @examples#
#' combine.formulae(combine.formulae(combine.formulae(y ~ a + b, "b - c"), y ~ c + d), "c : d - .")#
#
combine.formulae <- function(formula1, formula2, sep="") {#
    chunks1 <- as.character(formula1)#
#
    if (is.character(formula2))#
        if (grepl("~", formula2))#
            formula2 <- as.formula(formula2)#
#
    if (class(formula2) == "formula") {#
        chunks2 <- as.character(formula2)#
        if (chunks2[2] != chunks1[2])#
            error("Left-hand-side variables do not match.")#
#
        terms1 <- get.formula.terms(formula1)#
        terms2 <- get.formula.terms(formula2)#
    } else {#
        print("yy")#
        terms2 <- get.hyper.terms(formula2, sep=sep)#
        if (length(terms2) != 3)#
            error(paste("Cannot understand expression:", formula2))#
#
        terms2 <- terms2[-3]#
#
        terms1 <- get.formula.terms(formula1)#
        print("uu")#
        if (attr(terms(formula1), 'intercept') == 0) {#
            if (!("0" %in% terms1))#
                terms1 <- c("0", terms1)#
        } else {#
            if (!("0" %in% terms1 && "constant" %in% terms1))#
                terms1 <- c("0", "constant", terms1)#
        }#
    }#
#
    print("tt")#
    for (term in terms2)#
        if (!(term %in% terms1))#
            terms1 <- c(terms1, term)#
#
    as.formula(paste(chunks1[2], "~", paste(terms1, collapse=" + ")),#
               env=attr(formula1, '.Environment'))#
}
hierlm(Sepal.Length ~ 0 + Petal.Length + Species + Sepal.Width : Species | Species - . | Sepal.Width : Species - ., iris, c(1, 2))
#' Combine two formulas in hierlm-format#
#'#
#' Return the left and right side of a new combined formula.#
#' Left formula must be a standard formula.  Right formula may take the following forms:#
#' y ~ ... : an lm-style formula; the left-hand-side variables much match#
#' f - b : A requirement that two variables be close together (typically one is a factor)#
#' f - . : A requirement that a variable (or set of factors) be close to a new hyper-variable#
#' a : f - [b or .] : A requirement that the results of an interaction be near a hyper-variable#
#' TODO:#
#' a + B : A requirement that the factors in 'a' are similar to eachother by smoothness 'B'#
#'#
#' @param formula1 an lm-style formula#
#' @param formula2 an additional formula or hierlm term#
#' @return Augmented formula#
#' @examples#
#' combine.formulae(combine.formulae(combine.formulae(y ~ a + b, "b - c"), y ~ c + d), "c : d - .")#
#
combine.formulae <- function(formula1, formula2, sep="") {#
    chunks1 <- as.character(formula1)#
#
    if (is.character(formula2))#
        if (grepl("~", formula2))#
            formula2 <- as.formula(formula2)#
#
    if (class(formula2) == "formula") {#
        chunks2 <- as.character(formula2)#
        if (chunks2[2] != chunks1[2])#
            error("Left-hand-side variables do not match.")#
#
        terms1 <- get.formula.terms(formula1)#
        terms2 <- get.formula.terms(formula2)#
    } else {#
        print("yy")#
        terms2 <- get.hyper.terms(formula2, sep=sep)#
        if (length(terms2) != 3)#
            error(paste("Cannot understand expression:", formula2))#
#
        terms2 <- terms2[-3]#
#
        terms1 <- get.formula.terms(formula1)#
        print("uu")#
        if (attr(terms(formula1), 'intercept') == 0) {#
            print("ss")#
            if (!("0" %in% terms1))#
                terms1 <- c("0", terms1)#
        } else {#
            if (!("0" %in% terms1 && "constant" %in% terms1))#
                terms1 <- c("0", "constant", terms1)#
        }#
    }#
#
    print("tt")#
    for (term in terms2)#
        if (!(term %in% terms1))#
            terms1 <- c(terms1, term)#
#
    as.formula(paste(chunks1[2], "~", paste(terms1, collapse=" + ")),#
               env=attr(formula1, '.Environment'))#
}
hierlm(Sepal.Length ~ 0 + Petal.Length + Species + Sepal.Width : Species | Species - . | Sepal.Width : Species - ., iris, c(1, 2))
#' Combine two formulas in hierlm-format#
#'#
#' Return the left and right side of a new combined formula.#
#' Left formula must be a standard formula.  Right formula may take the following forms:#
#' y ~ ... : an lm-style formula; the left-hand-side variables much match#
#' f - b : A requirement that two variables be close together (typically one is a factor)#
#' f - . : A requirement that a variable (or set of factors) be close to a new hyper-variable#
#' a : f - [b or .] : A requirement that the results of an interaction be near a hyper-variable#
#' TODO:#
#' a + B : A requirement that the factors in 'a' are similar to eachother by smoothness 'B'#
#'#
#' @param formula1 an lm-style formula#
#' @param formula2 an additional formula or hierlm term#
#' @return Augmented formula#
#' @examples#
#' combine.formulae(combine.formulae(combine.formulae(y ~ a + b, "b - c"), y ~ c + d), "c : d - .")#
#
combine.formulae <- function(formula1, formula2, sep="") {#
    chunks1 <- as.character(formula1)#
#
    if (is.character(formula2))#
        if (grepl("~", formula2))#
            formula2 <- as.formula(formula2)#
#
    if (class(formula2) == "formula") {#
        chunks2 <- as.character(formula2)#
        if (chunks2[2] != chunks1[2])#
            error("Left-hand-side variables do not match.")#
#
        terms1 <- get.formula.terms(formula1)#
        terms2 <- get.formula.terms(formula2)#
    } else {#
        print("yy")#
        terms2 <- get.hyper.terms(formula2, sep=sep)#
        if (length(terms2) != 3)#
            error(paste("Cannot understand expression:", formula2))#
#
        terms2 <- terms2[-3]#
#
        terms1 <- get.formula.terms(formula1)#
        print("uu")#
        print(attr(terms(formula1), 'intercept'))#
        if (attr(terms(formula1), 'intercept') == 0) {#
            print("ss")#
            if (!("0" %in% terms1))#
                terms1 <- c("0", terms1)#
        } else {#
            if (!("0" %in% terms1 && "constant" %in% terms1))#
                terms1 <- c("0", "constant", terms1)#
        }#
    }#
#
    print("tt")#
    for (term in terms2)#
        if (!(term %in% terms1))#
            terms1 <- c(terms1, term)#
#
    as.formula(paste(chunks1[2], "~", paste(terms1, collapse=" + ")),#
               env=attr(formula1, '.Environment'))#
}
hierlm(Sepal.Length ~ 0 + Petal.Length + Species + Sepal.Width : Species | Species - . | Sepal.Width : Species - ., iris, c(1, 2))
#' Combine two formulas in hierlm-format#
#'#
#' Return the left and right side of a new combined formula.#
#' Left formula must be a standard formula.  Right formula may take the following forms:#
#' y ~ ... : an lm-style formula; the left-hand-side variables much match#
#' f - b : A requirement that two variables be close together (typically one is a factor)#
#' f - . : A requirement that a variable (or set of factors) be close to a new hyper-variable#
#' a : f - [b or .] : A requirement that the results of an interaction be near a hyper-variable#
#' TODO:#
#' a + B : A requirement that the factors in 'a' are similar to eachother by smoothness 'B'#
#'#
#' @param formula1 an lm-style formula#
#' @param formula2 an additional formula or hierlm term#
#' @return Augmented formula#
#' @examples#
#' combine.formulae(combine.formulae(combine.formulae(y ~ a + b, "b - c"), y ~ c + d), "c : d - .")#
#
combine.formulae <- function(formula1, formula2, sep="") {#
    chunks1 <- as.character(formula1)#
#
    if (is.character(formula2))#
        if (grepl("~", formula2))#
            formula2 <- as.formula(formula2)#
#
    if (class(formula2) == "formula") {#
        chunks2 <- as.character(formula2)#
        if (chunks2[2] != chunks1[2])#
            error("Left-hand-side variables do not match.")#
#
        terms1 <- get.formula.terms(formula1)#
        terms2 <- get.formula.terms(formula2)#
    } else {#
        print("yy")#
        terms2 <- get.hyper.terms(formula2, sep=sep)#
        if (length(terms2) != 3)#
            error(paste("Cannot understand expression:", formula2))#
#
        terms2 <- terms2[-3]#
#
        terms1 <- get.formula.terms(formula1)#
        print("uu")#
        print(formula1)#
        print(attr(terms(formula1), 'intercept'))#
        if (attr(terms(formula1), 'intercept') == 0) {#
            print("ss")#
            if (!("0" %in% terms1))#
                terms1 <- c("0", terms1)#
        } else {#
            if (!("0" %in% terms1 && "constant" %in% terms1))#
                terms1 <- c("0", "constant", terms1)#
        }#
    }#
#
    print("tt")#
    for (term in terms2)#
        if (!(term %in% terms1))#
            terms1 <- c(terms1, term)#
#
    as.formula(paste(chunks1[2], "~", paste(terms1, collapse=" + ")),#
               env=attr(formula1, '.Environment'))#
}
hierlm(Sepal.Length ~ 0 + Petal.Length + Species + Sepal.Width : Species | Species - . | Sepal.Width : Species - ., iris, c(1, 2))
#' Combine two formulas in hierlm-format#
#'#
#' Return the left and right side of a new combined formula.#
#' Left formula must be a standard formula.  Right formula may take the following forms:#
#' y ~ ... : an lm-style formula; the left-hand-side variables much match#
#' f - b : A requirement that two variables be close together (typically one is a factor)#
#' f - . : A requirement that a variable (or set of factors) be close to a new hyper-variable#
#' a : f - [b or .] : A requirement that the results of an interaction be near a hyper-variable#
#' TODO:#
#' a + B : A requirement that the factors in 'a' are similar to eachother by smoothness 'B'#
#'#
#' @param formula1 an lm-style formula#
#' @param formula2 an additional formula or hierlm term#
#' @return Augmented formula#
#' @examples#
#' combine.formulae(combine.formulae(combine.formulae(y ~ a + b, "b - c"), y ~ c + d), "c : d - .")#
#
combine.formulae <- function(formula1, formula2, sep="") {#
    chunks1 <- as.character(formula1)#
#
    if (is.character(formula2))#
        if (grepl("~", formula2))#
            formula2 <- as.formula(formula2)#
#
    if (class(formula2) == "formula") {#
        chunks2 <- as.character(formula2)#
        if (chunks2[2] != chunks1[2])#
            error("Left-hand-side variables do not match.")#
#
        terms1 <- get.formula.terms(formula1)#
        terms2 <- get.formula.terms(formula2)#
    } else {#
        print("yy")#
        terms2 <- get.hyper.terms(formula2, sep=sep)#
        if (length(terms2) != 3)#
            error(paste("Cannot understand expression:", formula2))#
#
        terms2 <- terms2[-3]#
#
        terms1 <- get.formula.terms(formula1)#
        print("uu")#
        print(class(formula1))#
        print(attr(terms(formula1), 'intercept'))#
        if (attr(terms(formula1), 'intercept') == 0) {#
            print("ss")#
            if (!("0" %in% terms1))#
                terms1 <- c("0", terms1)#
        } else {#
            if (!("0" %in% terms1 && "constant" %in% terms1))#
                terms1 <- c("0", "constant", terms1)#
        }#
    }#
#
    print("tt")#
    for (term in terms2)#
        if (!(term %in% terms1))#
            terms1 <- c(terms1, term)#
#
    as.formula(paste(chunks1[2], "~", paste(terms1, collapse=" + ")),#
               env=attr(formula1, '.Environment'))#
}
hierlm(Sepal.Length ~ 0 + Petal.Length + Species + Sepal.Width : Species | Species - . | Sepal.Width : Species - ., iris, c(1, 2))
#' Replace a factor term#
#'#
#' Constructs indicator terms for a factor variable.#
#'#
#' @param name term name#
#' @param formula formula#
#' @param sep paste sep used to construct factor names#
#' @return Modified formula#
#' @examples#
#' replace.factor.formula("Species", Sepal.Length ~ Species)#
#' replace.factor.formula("Species", Sepal.Length ~ Petal.Length : Species)#
#
replace.factor.formula <- function(name, formula, data, sep="") {#
    terms <- c()#
#
    for (term in get.formula.terms(formula)) {#
        if (term == name) {#
            terms <- c(terms, make.factor.names(name, data))#
        } else if (grepl(':', term)) {#
            subterms <- split.interaction.term(term)#
            if (subterms[1] == name) {#
                terms <- c(terms, paste(make.factor.names(subterms[1], data), subterms[2], sep=':'))#
            } else if (subterms[2] == name) {#
                terms <- c(terms, paste(subterms[1], make.factor.names(subterms[2], data), sep=':'))#
            } else {#
                terms <- c(terms, term)#
            }#
        } else {#
            terms <- c(terms, term)#
        }#
    }#
#
    chunks <- as.character(formula)#
    as.formula(paste(chunks[2], paste(terms, collapse=" + "), sep=" ~ "))#
}
hierlm(Sepal.Length ~ 0 + Petal.Length + Species + Sepal.Width : Species | Species - . | Sepal.Width : Species - ., iris, c(1, 2))
#' Combine two formulas in hierlm-format#
#'#
#' Return the left and right side of a new combined formula.#
#' Left formula must be a standard formula.  Right formula may take the following forms:#
#' y ~ ... : an lm-style formula; the left-hand-side variables much match#
#' f - b : A requirement that two variables be close together (typically one is a factor)#
#' f - . : A requirement that a variable (or set of factors) be close to a new hyper-variable#
#' a : f - [b or .] : A requirement that the results of an interaction be near a hyper-variable#
#' TODO:#
#' a + B : A requirement that the factors in 'a' are similar to eachother by smoothness 'B'#
#'#
#' @param formula1 an lm-style formula#
#' @param formula2 an additional formula or hierlm term#
#' @return Augmented formula#
#' @examples#
#' combine.formulae(combine.formulae(combine.formulae(y ~ a + b, "b - c"), y ~ c + d), "c : d - .")#
#
combine.formulae <- function(formula1, formula2, sep="") {#
    chunks1 <- as.character(formula1)#
#
    if (is.character(formula2))#
        if (grepl("~", formula2))#
            formula2 <- as.formula(formula2)#
#
    if (class(formula2) == "formula") {#
        chunks2 <- as.character(formula2)#
        if (chunks2[2] != chunks1[2])#
            error("Left-hand-side variables do not match.")#
#
        terms1 <- get.formula.terms(formula1)#
        terms2 <- get.formula.terms(formula2)#
    } else {#
        terms2 <- get.hyper.terms(formula2, sep=sep)#
        if (length(terms2) != 3)#
            error(paste("Cannot understand expression:", formula2))#
#
        terms2 <- terms2[-3]#
#
        terms1 <- get.formula.terms(formula1)#
        if (attr(terms(formula1), 'intercept') == 0) {#
            if (!("0" %in% terms1))#
                terms1 <- c("0", terms1)#
        } else {#
            if (!("0" %in% terms1 && "constant" %in% terms1))#
                terms1 <- c("0", "constant", terms1)#
        }#
    }#
#
    for (term in terms2)#
        if (!(term %in% terms1))#
            terms1 <- c(terms1, term)#
#
    as.formula(paste(chunks1[2], "~", paste(terms1, collapse=" + ")),#
               env=attr(formula1, '.Environment'))#
}
hierlm(Sepal.Length ~ 0 + Petal.Length + Species + Sepal.Width : Species | Species - . | Sepal.Width : Species - ., iris, c(1, 2))
#' Fit an hierarchical model#
#'#
#' Interpret a hierarchical formula and fit it with the given data and weight ratios.#
#'#
#' @param formula an hierlm-style formula#
#' @param datas a data frame or a list of data frames, for each lm-style formula contained in the hierlm#
#' @param ratios a vector a ratios for the effect of fictional#
#'   observations, with length as large as the number of hyper#
#'   expressions.#
#' @return A fitted lm model#
#' @examples#
#' hierlm(Sepal.Length ~ 0 + Petal.Length + Species + Sepal.Width : Species | Species - ., iris, 1)#
#' hierlm(Sepal.Length ~ 0 + Petal.Length + Species + Sepal.Width : Species | Species - . | Sepal.Width : Species - ., iris, c(1, 2))#
#
hierlm <- function(formula, datas, ratios, sep="") {#
    if (is.data.frame(datas))#
        datas <- list(datas)#
#
    data.ii <- 1#
    ratio.ii <- 1#
#
    data <- datas[[data.ii]]#
#
    ## Split the formula by |#
    labels <- attr(terms(formula), 'term.labels')#
    if (length(labels) == 1) { # otherwise it's just an lm formula#
        lhs <- as.character(formula)[2]#
        chunks <- strsplit(labels, "\\|")[[1]]#
        formula <- as.formula(paste(lhs, "~", chunks[1]), env=attr(formula, '.Environment'))#
        ## Keep this for weight calculations#
        oldformula <- formula#
        for (chunk in chunks[-1]) {#
            print(chunk)#
            ## Keep these around#
            olddata <- data#
#
            ## Make the new formula#
            formula <- combine.formulae(formula, chunk)#
            print("vv")#
            if (!("constant" %in% names(data)) && "constant" %in% get.formula.terms(formula))#
                data$constant <- 1#
#
            print("xx")#
#
            terms <- get.hyper.terms(chunk)#
            if (length(terms) == 3) {#
                print("ab")#
                ## Build the new relationship#
                weight <- calc.fo.weights(oldformula, terms[1], ratios[ratio.ii], datas[[data.ii]]) # use original data#
                print("ao")#
                extras <- make.hyper.rows(terms[1], terms[2], weight, datas[[data.ii]])#
#
                ## Done with this ratio#
                ratio.ii <- ratio.ii + 1#
#
                ## Create indicators for nonhyper, if not already done#
                if (terms[1] %in% data)#
                    data <- replace.factor(terms[1], data, 1, sep=sep)#
#
                data <- combine.data.frames(data, extras)#
            } else {#
                ## Add in the next formula#
                data.ii <- data.ii + 1#
                data <- combine.data.frame(data, datas[[data.ii]])#
            }#
#
            ## Have any of the terms in the formula been factorized?#
            checks <- get.formula.terms(formula)#
            for (check in checks) {#
                if (check %in% names(olddata) && is.factor(olddata[, check]))#
                    formula <- replace.factor.formula(check, formula, olddata)#
            }#
        }#
    }#
#
    print(head(data))#
    print(tail(data))#
    print(formula)#
    lm(formula, data=data)#
}
hierlm(Sepal.Length ~ 0 + Petal.Length + Species + Sepal.Width : Species | Species - . | Sepal.Width : Species - ., iris, c(1, 2))
#' Fit an hierarchical model#
#'#
#' Interpret a hierarchical formula and fit it with the given data and weight ratios.#
#'#
#' @param formula an hierlm-style formula#
#' @param datas a data frame or a list of data frames, for each lm-style formula contained in the hierlm#
#' @param ratios a vector a ratios for the effect of fictional#
#'   observations, with length as large as the number of hyper#
#'   expressions.#
#' @return A fitted lm model#
#' @examples#
#' hierlm(Sepal.Length ~ 0 + Petal.Length + Species + Sepal.Width : Species | Species - ., iris, 1)#
#' hierlm(Sepal.Length ~ 0 + Petal.Length + Species + Sepal.Width : Species | Species - . | Sepal.Width : Species - ., iris, c(1, 2))#
#
hierlm <- function(formula, datas, ratios, sep="") {#
    if (is.data.frame(datas))#
        datas <- list(datas)#
#
    data.ii <- 1#
    ratio.ii <- 1#
#
    data <- datas[[data.ii]]#
#
    ## Split the formula by |#
    labels <- attr(terms(formula), 'term.labels')#
    if (length(labels) == 1) { # otherwise it's just an lm formula#
        lhs <- as.character(formula)[2]#
        chunks <- strsplit(labels, "\\|")[[1]]#
        formula <- as.formula(paste(lhs, "~", chunks[1]), env=attr(formula, '.Environment'))#
        ## Keep this for weight calculations#
        oldformula <- formula#
        for (chunk in chunks[-1]) {#
            print(chunk)#
            ## Keep these around#
            olddata <- data#
#
            ## Make the new formula#
            formula <- combine.formulae(formula, chunk)#
            print("vv")#
            if (!("constant" %in% names(data)) && "constant" %in% get.formula.terms(formula))#
                data$constant <- 1#
#
            print("xx")#
#
            terms <- get.hyper.terms(chunk)#
            if (length(terms) == 3) {#
                print("ab")#
                ## Build the new relationship#
                weight <- calc.fo.weights(oldformula, terms[1], ratios[ratio.ii], datas[[data.ii]]) # use original data#
                print("ao")#
                print(terms)#
                extras <- make.hyper.rows(terms[1], terms[2], weight, datas[[data.ii]])#
#
                ## Done with this ratio#
                ratio.ii <- ratio.ii + 1#
#
                ## Create indicators for nonhyper, if not already done#
                if (terms[1] %in% data)#
                    data <- replace.factor(terms[1], data, 1, sep=sep)#
#
                data <- combine.data.frames(data, extras)#
            } else {#
                ## Add in the next formula#
                data.ii <- data.ii + 1#
                data <- combine.data.frame(data, datas[[data.ii]])#
            }#
#
            ## Have any of the terms in the formula been factorized?#
            checks <- get.formula.terms(formula)#
            for (check in checks) {#
                if (check %in% names(olddata) && is.factor(olddata[, check]))#
                    formula <- replace.factor.formula(check, formula, olddata)#
            }#
        }#
    }#
#
    print(head(data))#
    print(tail(data))#
    print(formula)#
    lm(formula, data=data)#
}
hierlm(Sepal.Length ~ 0 + Petal.Length + Species + Sepal.Width : Species | Species - . | Sepal.Width : Species - ., iris, c(1, 2))
make.hyper.rows("Species", "hyperSpecies", 5, iris)
#' Get any new hyper terms from formula#
#'#
#' If the "a - b" formula requires the creation of a new hyper terms#
#' (one of a or b is .), return them.#
#'#
#' @param formula Single component of a hierlm formula#
#' @return Vector of c(nonhyper, hyper, is.interaction), if a new one was created;#
#'   or c(left, right, NA) if both terms are given;#
#'   or c() if not an "a - b" expression#
#' @examples#
#' get.hyper.terms(Sepal.Length ~ Petal.Length + Species + Sepal.Width : Species)#
#
get.hyper.terms <- function(formula, sep="") {#
    if (class(formula) == "formula")#
        return(c())#
#
    terms <- strsplit(formula, "-")[[1]]#
    if (length(terms) != 2)#
        return(c())#
#
    terms <- gsub("^\\s+|\\s+$", "", terms)#
    if ("." %in% terms) {#
        nonhyper <- terms[terms != "."]#
        if (grepl(':', nonhyper)) {#
            subterms <- split.interaction.term(nonhyper)#
            hyper <- paste("hyper", paste(subterms, collapse=sep), sep=sep)#
            return(c(nonhyper, hyper, T))#
        } else {#
            hyper <- paste("hyper", nonhyper, sep=sep)#
            return(c(nonhyper, hyper, F))#
        }#
    }#
    return(c(terms, NA))#
}
get.hyper.terms(Sepal.Length ~ Petal.Length + Species + Sepal.Width : Species)
#' Create fictional observations for a hyper relationship#
#'#
#' Return a data frame with fictional observations#
#'#
#' @param nonhyper name of the non-hyper column#
#' @param hyper name of the hyper column#
#' @param weight weight to be used in the rows#
#' @param data a data frame for inspecting levels#
#' @return Fictional observations in a data frame#
#' @examples#
#' make.hyper.rows("Species", "hyperSpecies", 5, iris)#
#
make.hyper.rows <- function(nonhyper, hyper, weight, data, sep="") {#
    if (grepl(':', nonhyper)) {#
        for (subterm in split.interaction.term(nonhyper)) {#
            if (!is.numeric(data[, subterm]))#
                return(make.hyper.rows(subterm, hyper))#
        }#
    } else {#
        ## Construct extra from diagonal factor matrix#
        extras <- diag(weight, length(unique(data[, nonhyper])))#
        extras <- as.data.frame(extras)#
#
        names(extras) <- paste(nonhyper, unique(data[, nonhyper]), sep=sep)#
#
        ## Add in the hyper column#
        extras[, hyper] <- -weight#
#
        extras#
    }#
}
hierlm(Sepal.Length ~ 0 + Petal.Length + Species + Sepal.Width : Species | Species - . | Sepal.Width : Species - ., iris, c(1, 2))
#' Create fictional observations for a hyper relationship#
#'#
#' Return a data frame with fictional observations#
#'#
#' @param nonhyper name of the non-hyper column#
#' @param hyper name of the hyper column#
#' @param weight weight to be used in the rows#
#' @param data a data frame for inspecting levels#
#' @return Fictional observations in a data frame#
#' @examples#
#' make.hyper.rows("Species", "hyperSpecies", 5, iris)#
#
make.hyper.rows <- function(nonhyper, hyper, weight, data, sep="") {#
    if (grepl(':', nonhyper)) {#
        for (subterm in split.interaction.term(nonhyper)) {#
            if (!is.numeric(data[, subterm]))#
                return(make.hyper.rows(subterm, hyper, weight, data))#
        }#
    } else {#
        ## Construct extra from diagonal factor matrix#
        extras <- diag(weight, length(unique(data[, nonhyper])))#
        extras <- as.data.frame(extras)#
#
        names(extras) <- paste(nonhyper, unique(data[, nonhyper]), sep=sep)#
#
        ## Add in the hyper column#
        extras[, hyper] <- -weight#
#
        extras#
    }#
}
hierlm(Sepal.Length ~ 0 + Petal.Length + Species + Sepal.Width : Species | Species - . | Sepal.Width : Species - ., iris, c(1, 2))
#' Fit an hierarchical model#
#'#
#' Interpret a hierarchical formula and fit it with the given data and weight ratios.#
#'#
#' @param formula an hierlm-style formula#
#' @param datas a data frame or a list of data frames, for each lm-style formula contained in the hierlm#
#' @param ratios a vector a ratios for the effect of fictional#
#'   observations, with length as large as the number of hyper#
#'   expressions.#
#' @return A fitted lm model#
#' @examples#
#' hierlm(Sepal.Length ~ 0 + Petal.Length + Species + Sepal.Width : Species | Species - ., iris, 1)#
#' hierlm(Sepal.Length ~ 0 + Petal.Length + Species + Sepal.Width : Species | Species - . | Sepal.Width : Species - ., iris, c(1, 2))#
#
hierlm <- function(formula, datas, ratios, sep="") {#
    if (is.data.frame(datas))#
        datas <- list(datas)#
#
    data.ii <- 1#
    ratio.ii <- 1#
#
    data <- datas[[data.ii]]#
#
    ## Split the formula by |#
    labels <- attr(terms(formula), 'term.labels')#
    if (length(labels) == 1) { # otherwise it's just an lm formula#
        lhs <- as.character(formula)[2]#
        chunks <- strsplit(labels, "\\|")[[1]]#
        formula <- as.formula(paste(lhs, "~", chunks[1]), env=attr(formula, '.Environment'))#
        ## Keep this for weight calculations#
        oldformula <- formula#
        for (chunk in chunks[-1]) {#
            print(chunk)#
            ## Keep these around#
            olddata <- data#
#
            ## Make the new formula#
            formula <- combine.formulae(formula, chunk)#
            print("vv")#
            if (!("constant" %in% names(data)) && "constant" %in% get.formula.terms(formula))#
                data$constant <- 1#
#
            print("xx")#
#
            terms <- get.hyper.terms(chunk)#
            if (length(terms) == 3) {#
                print("ab")#
                ## Build the new relationship#
                weight <- calc.fo.weights(oldformula, terms[1], ratios[ratio.ii], datas[[data.ii]]) # use original data#
                print("ao")#
                print(terms)#
                extras <- make.hyper.rows(terms[1], terms[2], weight, datas[[data.ii]])#
#
                ## Done with this ratio#
                ratio.ii <- ratio.ii + 1#
#
                ## Create indicators for nonhyper, if not already done#
                if (terms[1] %in% data)#
                    data <- replace.factor(terms[1], data, 1, sep=sep)#
#
                data <- combine.data.frames(data, extras)#
            } else {#
                ## Add in the next formula#
                data.ii <- data.ii + 1#
                data <- combine.data.frame(data, datas[[data.ii]])#
            }#
#
            ## Have any of the terms in the formula been factorized?#
            checks <- get.formula.terms(formula)#
            for (check in checks) {#
                if (check %in% names(olddata) && !is.character(olddata[, check]))#
                    formula <- replace.factor.formula(check, formula, olddata)#
            }#
        }#
    }#
#
    print(head(data))#
    print(tail(data))#
    print(formula)#
    lm(formula, data=data)#
}
hierlm(Sepal.Length ~ 0 + Petal.Length + Species + Sepal.Width : Species | Species - . | Sepal.Width : Species - ., iris, c(1, 2))
#' Fit an hierarchical model#
#'#
#' Interpret a hierarchical formula and fit it with the given data and weight ratios.#
#'#
#' @param formula an hierlm-style formula#
#' @param datas a data frame or a list of data frames, for each lm-style formula contained in the hierlm#
#' @param ratios a vector a ratios for the effect of fictional#
#'   observations, with length as large as the number of hyper#
#'   expressions.#
#' @return A fitted lm model#
#' @examples#
#' hierlm(Sepal.Length ~ 0 + Petal.Length + Species + Sepal.Width : Species | Species - ., iris, 1)#
#' hierlm(Sepal.Length ~ 0 + Petal.Length + Species + Sepal.Width : Species | Species - . | Sepal.Width : Species - ., iris, c(1, 2))#
#
hierlm <- function(formula, datas, ratios, sep="") {#
    if (is.data.frame(datas))#
        datas <- list(datas)#
#
    data.ii <- 1#
    ratio.ii <- 1#
#
    data <- datas[[data.ii]]#
#
    ## Split the formula by |#
    labels <- attr(terms(formula), 'term.labels')#
    if (length(labels) == 1) { # otherwise it's just an lm formula#
        lhs <- as.character(formula)[2]#
        chunks <- strsplit(labels, "\\|")[[1]]#
        formula <- as.formula(paste(lhs, "~", chunks[1]), env=attr(formula, '.Environment'))#
        ## Keep this for weight calculations#
        oldformula <- formula#
        for (chunk in chunks[-1]) {#
            print(chunk)#
            ## Keep these around#
            olddata <- data#
#
            ## Make the new formula#
            formula <- combine.formulae(formula, chunk)#
            print("vv")#
            if (!("constant" %in% names(data)) && "constant" %in% get.formula.terms(formula))#
                data$constant <- 1#
#
            print("xx")#
#
            terms <- get.hyper.terms(chunk)#
            if (length(terms) == 3) {#
                print("ab")#
                ## Build the new relationship#
                weight <- calc.fo.weights(oldformula, terms[1], ratios[ratio.ii], datas[[data.ii]]) # use original data#
                print("ao")#
                print(terms)#
                extras <- make.hyper.rows(terms[1], terms[2], weight, datas[[data.ii]])#
#
                ## Done with this ratio#
                ratio.ii <- ratio.ii + 1#
#
                ## Create indicators for nonhyper, if not already done#
                if (terms[1] %in% data)#
                    data <- replace.factor(terms[1], data, 1, sep=sep)#
#
                data <- combine.data.frames(data, extras)#
            } else {#
                ## Add in the next formula#
                data.ii <- data.ii + 1#
                data <- combine.data.frame(data, datas[[data.ii]])#
            }#
#
            ## Have any of the terms in the formula been factorized?#
            checks <- get.formula.terms(formula)#
            for (check in checks) {#
                if (check %in% names(olddata) && !is.numeric(olddata[, check]))#
                    formula <- replace.factor.formula(check, formula, olddata)#
            }#
        }#
    }#
#
    print(head(data))#
    print(tail(data))#
    print(formula)#
    lm(formula, data=data)#
}
hierlm(Sepal.Length ~ 0 + Petal.Length + Species + Sepal.Width : Species | Species - . | Sepal.Width : Species - ., iris, c(1, 2))
#' Fit an hierarchical model#
#'#
#' Interpret a hierarchical formula and fit it with the given data and weight ratios.#
#'#
#' @param formula an hierlm-style formula#
#' @param datas a data frame or a list of data frames, for each lm-style formula contained in the hierlm#
#' @param ratios a vector a ratios for the effect of fictional#
#'   observations, with length as large as the number of hyper#
#'   expressions.#
#' @return A fitted lm model#
#' @examples#
#' hierlm(Sepal.Length ~ 0 + Petal.Length + Species + Sepal.Width : Species | Species - ., iris, 1)#
#' hierlm(Sepal.Length ~ 0 + Petal.Length + Species + Sepal.Width : Species | Species - . | Sepal.Width : Species - ., iris, c(1, 2))#
#
hierlm <- function(formula, datas, ratios, sep="") {#
    if (is.data.frame(datas))#
        datas <- list(datas)#
#
    data.ii <- 1#
    ratio.ii <- 1#
#
    data <- datas[[data.ii]]#
#
    ## Split the formula by |#
    labels <- attr(terms(formula), 'term.labels')#
    if (length(labels) == 1) { # otherwise it's just an lm formula#
        lhs <- as.character(formula)[2]#
        chunks <- strsplit(labels, "\\|")[[1]]#
        formula <- as.formula(paste(lhs, "~", chunks[1]), env=attr(formula, '.Environment'))#
        ## Keep this for weight calculations#
        oldformula <- formula#
        for (chunk in chunks[-1]) {#
            print(chunk)#
            ## Keep these around#
            olddata <- data#
#
            ## Make the new formula#
            formula <- combine.formulae(formula, chunk)#
            print("vv")#
            if (!("constant" %in% names(data)) && "constant" %in% get.formula.terms(formula))#
                data$constant <- 1#
#
            print("xx")#
#
            terms <- get.hyper.terms(chunk)#
            if (length(terms) == 3) {#
                print("ab")#
                ## Build the new relationship#
                weight <- calc.fo.weights(oldformula, terms[1], ratios[ratio.ii], datas[[data.ii]]) # use original data#
                print("ao")#
                print(terms)#
                extras <- make.hyper.rows(terms[1], terms[2], weight, datas[[data.ii]])#
#
                ## Done with this ratio#
                ratio.ii <- ratio.ii + 1#
#
                ## Create indicators for nonhyper, if not already done#
                if (terms[1] %in% data)#
                    data <- replace.factor(terms[1], data, 1, sep=sep)#
#
                data <- combine.data.frames(data, extras)#
            } else {#
                ## Add in the next formula#
                data.ii <- data.ii + 1#
                data <- combine.data.frame(data, datas[[data.ii]])#
            }#
#
            ## Have any of the terms in the formula been factorized?#
            checks <- get.formula.terms(formula)#
            for (check in checks) {#
                if (grepl(':', check)) {#
                    for (subterm in split.interaction.term(check))#
                        if (subterm %in% names(oldata) && !(subterm %in% names(data)) && !is.numeric(olddata[, check]))#
                            formula <- replace.factor.formula(subterm, formula, olddata)#
                } else {#
                    if (check %in% names(olddata) && !(check %in% names(data)) && !is.numeric(olddata[, check]))#
                        formula <- replace.factor.formula(check, formula, olddata)#
                }#
            }#
        }#
    }#
#
    print(head(data))#
    print(tail(data))#
    print(formula)#
    lm(formula, data=data)#
}
hierlm(Sepal.Length ~ 0 + Petal.Length + Species + Sepal.Width : Species | Species - . | Sepal.Width : Species - ., iris, c(1, 2))
#' Fit an hierarchical model#
#'#
#' Interpret a hierarchical formula and fit it with the given data and weight ratios.#
#'#
#' @param formula an hierlm-style formula#
#' @param datas a data frame or a list of data frames, for each lm-style formula contained in the hierlm#
#' @param ratios a vector a ratios for the effect of fictional#
#'   observations, with length as large as the number of hyper#
#'   expressions.#
#' @return A fitted lm model#
#' @examples#
#' hierlm(Sepal.Length ~ 0 + Petal.Length + Species + Sepal.Width : Species | Species - ., iris, 1)#
#' hierlm(Sepal.Length ~ 0 + Petal.Length + Species + Sepal.Width : Species | Species - . | Sepal.Width : Species - ., iris, c(1, 2))#
#
hierlm <- function(formula, datas, ratios, sep="") {#
    if (is.data.frame(datas))#
        datas <- list(datas)#
#
    data.ii <- 1#
    ratio.ii <- 1#
#
    data <- datas[[data.ii]]#
#
    ## Split the formula by |#
    labels <- attr(terms(formula), 'term.labels')#
    if (length(labels) == 1) { # otherwise it's just an lm formula#
        lhs <- as.character(formula)[2]#
        chunks <- strsplit(labels, "\\|")[[1]]#
        formula <- as.formula(paste(lhs, "~", chunks[1]), env=attr(formula, '.Environment'))#
        ## Keep this for weight calculations#
        oldformula <- formula#
        for (chunk in chunks[-1]) {#
            print(chunk)#
            ## Keep these around#
            olddata <- data#
#
            ## Make the new formula#
            formula <- combine.formulae(formula, chunk)#
            print("vv")#
            if (!("constant" %in% names(data)) && "constant" %in% get.formula.terms(formula))#
                data$constant <- 1#
#
            print("xx")#
#
            terms <- get.hyper.terms(chunk)#
            if (length(terms) == 3) {#
                print("ab")#
                ## Build the new relationship#
                weight <- calc.fo.weights(oldformula, terms[1], ratios[ratio.ii], datas[[data.ii]]) # use original data#
                print("ao")#
                print(terms)#
                extras <- make.hyper.rows(terms[1], terms[2], weight, datas[[data.ii]])#
#
                ## Done with this ratio#
                ratio.ii <- ratio.ii + 1#
#
                ## Create indicators for nonhyper, if not already done#
                if (terms[1] %in% data)#
                    data <- replace.factor(terms[1], data, 1, sep=sep)#
#
                data <- combine.data.frames(data, extras)#
            } else {#
                ## Add in the next formula#
                data.ii <- data.ii + 1#
                data <- combine.data.frame(data, datas[[data.ii]])#
            }#
#
            ## Have any of the terms in the formula been factorized?#
            checks <- get.formula.terms(formula)#
            for (check in checks) {#
                if (grepl(':', check)) {#
                    for (subterm in split.interaction.term(check))#
                        if (subterm %in% names(olddata) && !(subterm %in% names(data)) && !is.numeric(olddata[, check]))#
                            formula <- replace.factor.formula(subterm, formula, olddata)#
                } else {#
                    if (check %in% names(olddata) && !(check %in% names(data)) && !is.numeric(olddata[, check]))#
                        formula <- replace.factor.formula(check, formula, olddata)#
                }#
            }#
        }#
    }#
#
    print(head(data))#
    print(tail(data))#
    print(formula)#
    lm(formula, data=data)#
}
hierlm(Sepal.Length ~ 0 + Petal.Length + Species + Sepal.Width : Species | Species - . | Sepal.Width : Species - ., iris, c(1, 2))
#' Fit an hierarchical model#
#'#
#' Interpret a hierarchical formula and fit it with the given data and weight ratios.#
#'#
#' @param formula an hierlm-style formula#
#' @param datas a data frame or a list of data frames, for each lm-style formula contained in the hierlm#
#' @param ratios a vector a ratios for the effect of fictional#
#'   observations, with length as large as the number of hyper#
#'   expressions.#
#' @return A fitted lm model#
#' @examples#
#' hierlm(Sepal.Length ~ 0 + Petal.Length + Species + Sepal.Width : Species | Species - ., iris, 1)#
#' hierlm(Sepal.Length ~ 0 + Petal.Length + Species + Sepal.Width : Species | Species - . | Sepal.Width : Species - ., iris, c(1, 2))#
#
hierlm <- function(formula, datas, ratios, sep="") {#
    if (is.data.frame(datas))#
        datas <- list(datas)#
#
    data.ii <- 1#
    ratio.ii <- 1#
#
    data <- datas[[data.ii]]#
#
    ## Split the formula by |#
    labels <- attr(terms(formula), 'term.labels')#
    if (length(labels) == 1) { # otherwise it's just an lm formula#
        lhs <- as.character(formula)[2]#
        chunks <- strsplit(labels, "\\|")[[1]]#
        formula <- as.formula(paste(lhs, "~", chunks[1]), env=attr(formula, '.Environment'))#
        ## Keep this for weight calculations#
        oldformula <- formula#
        for (chunk in chunks[-1]) {#
            print(chunk)#
            ## Keep these around#
            olddata <- data#
#
            ## Make the new formula#
            formula <- combine.formulae(formula, chunk)#
            print("vv")#
            if (!("constant" %in% names(data)) && "constant" %in% get.formula.terms(formula))#
                data$constant <- 1#
#
            print("xx")#
#
            terms <- get.hyper.terms(chunk)#
            if (length(terms) == 3) {#
                print("ab")#
                ## Build the new relationship#
                weight <- calc.fo.weights(oldformula, terms[1], ratios[ratio.ii], datas[[data.ii]]) # use original data#
                print("ao")#
                print(terms)#
                extras <- make.hyper.rows(terms[1], terms[2], weight, datas[[data.ii]])#
#
                ## Done with this ratio#
                ratio.ii <- ratio.ii + 1#
#
                ## Create indicators for nonhyper, if not already done#
                if (terms[1] %in% data)#
                    data <- replace.factor(terms[1], data, 1, sep=sep)#
#
                data <- combine.data.frames(data, extras)#
            } else {#
                ## Add in the next formula#
                data.ii <- data.ii + 1#
                data <- combine.data.frame(data, datas[[data.ii]])#
            }#
#
            ## Have any of the terms in the formula been factorized?#
            checks <- get.formula.terms(formula)#
            for (check in checks) {#
                if (grepl(':', check)) {#
                    for (subterm in split.interaction.term(check))#
                        if (subterm %in% names(olddata) && !(subterm %in% names(data)) && !is.numeric(olddata[, subterm]))#
                            formula <- replace.factor.formula(subterm, formula, olddata)#
                } else {#
                    if (check %in% names(olddata) && !(check %in% names(data)) && !is.numeric(olddata[, check]))#
                        formula <- replace.factor.formula(check, formula, olddata)#
                }#
            }#
        }#
    }#
#
    print(head(data))#
    print(tail(data))#
    print(formula)#
    lm(formula, data=data)#
}
hierlm(Sepal.Length ~ 0 + Petal.Length + Species + Sepal.Width : Species | Species - . | Sepal.Width : Species - ., iris, c(1, 2))
#' Fit an hierarchical model#
#'#
#' Interpret a hierarchical formula and fit it with the given data and weight ratios.#
#'#
#' @param formula an hierlm-style formula#
#' @param datas a data frame or a list of data frames, for each lm-style formula contained in the hierlm#
#' @param ratios a vector a ratios for the effect of fictional#
#'   observations, with length as large as the number of hyper#
#'   expressions.#
#' @return A fitted lm model#
#' @examples#
#' hierlm(Sepal.Length ~ 0 + Petal.Length + Species + Sepal.Width : Species | Species - ., iris, 1)#
#' hierlm(Sepal.Length ~ 0 + Petal.Length + Species + Sepal.Width : Species | Species - . | Sepal.Width : Species - ., iris, c(1, 2))#
#
hierlm <- function(formula, datas, ratios, sep="") {#
    if (is.data.frame(datas))#
        datas <- list(datas)#
#
    data.ii <- 1#
    ratio.ii <- 1#
#
    data <- datas[[data.ii]]#
#
    ## Split the formula by |#
    labels <- attr(terms(formula), 'term.labels')#
    if (length(labels) == 1) { # otherwise it's just an lm formula#
        lhs <- as.character(formula)[2]#
        chunks <- strsplit(labels, "\\|")[[1]]#
        formula <- as.formula(paste(lhs, "~", chunks[1]), env=attr(formula, '.Environment'))#
        ## Keep this for weight calculations#
        oldformula <- formula#
        for (chunk in chunks[-1]) {#
            ## Keep these around#
            olddata <- data#
#
            ## Make the new formula#
            formula <- combine.formulae(formula, chunk)#
            if (!("constant" %in% names(data)) && "constant" %in% get.formula.terms(formula))#
                data$constant <- 1#
#
            terms <- get.hyper.terms(chunk)#
            if (length(terms) == 3) {#
                ## Build the new relationship#
                weight <- calc.fo.weights(oldformula, terms[1], ratios[ratio.ii], datas[[data.ii]]) # use original data#
                extras <- make.hyper.rows(terms[1], terms[2], weight, datas[[data.ii]])#
#
                ## Done with this ratio#
                ratio.ii <- ratio.ii + 1#
#
                ## Create indicators for nonhyper, if not already done#
                if (terms[1] %in% data)#
                    data <- replace.factor(terms[1], data, 1, sep=sep)#
#
                data <- combine.data.frames(data, extras)#
            } else {#
                ## Add in the next formula#
                data.ii <- data.ii + 1#
                data <- combine.data.frame(data, datas[[data.ii]])#
            }#
#
            ## Have any of the terms in the formula been factorized?#
            checks <- get.formula.terms(formula)#
            for (check in checks) {#
                if (grepl(':', check)) {#
                    for (subterm in split.interaction.term(check))#
                        if (subterm %in% names(olddata) && !(subterm %in% names(data)) && !is.numeric(olddata[, subterm])) {#
                            print(subterm)#
                            formula <- replace.factor.formula(subterm, formula, olddata)#
                            print(formula)#
                        }#
                } else {#
                    if (check %in% names(olddata) && !(check %in% names(data)) && !is.numeric(olddata[, check]))#
                        formula <- replace.factor.formula(check, formula, olddata)#
                }#
            }#
        }#
    }#
#
    print(head(data))#
    print(tail(data))#
    print(formula)#
    lm(formula, data=data)#
}
hierlm(Sepal.Length ~ 0 + Petal.Length + Species + Sepal.Width : Species | Species - . | Sepal.Width : Species - ., iris, c(1, 2))
#' Fit an hierarchical model#
#'#
#' Interpret a hierarchical formula and fit it with the given data and weight ratios.#
#'#
#' @param formula an hierlm-style formula#
#' @param datas a data frame or a list of data frames, for each lm-style formula contained in the hierlm#
#' @param ratios a vector a ratios for the effect of fictional#
#'   observations, with length as large as the number of hyper#
#'   expressions.#
#' @return A fitted lm model#
#' @examples#
#' hierlm(Sepal.Length ~ 0 + Petal.Length + Species + Sepal.Width : Species | Species - ., iris, 1)#
#' hierlm(Sepal.Length ~ 0 + Petal.Length + Species + Sepal.Width : Species | Species - . | Sepal.Width : Species - ., iris, c(1, 2))#
#
hierlm <- function(formula, datas, ratios, sep="") {#
    if (is.data.frame(datas))#
        datas <- list(datas)#
#
    data.ii <- 1#
    ratio.ii <- 1#
#
    data <- datas[[data.ii]]#
#
    ## Split the formula by |#
    labels <- attr(terms(formula), 'term.labels')#
    if (length(labels) == 1) { # otherwise it's just an lm formula#
        lhs <- as.character(formula)[2]#
        chunks <- strsplit(labels, "\\|")[[1]]#
        formula <- as.formula(paste(lhs, "~", chunks[1]), env=attr(formula, '.Environment'))#
        ## Keep this for weight calculations#
        oldformula <- formula#
        for (chunk in chunks[-1]) {#
            ## Keep these around#
            olddata <- data#
#
            ## Make the new formula#
            formula <- combine.formulae(formula, chunk)#
            if (!("constant" %in% names(data)) && "constant" %in% get.formula.terms(formula))#
                data$constant <- 1#
#
            terms <- get.hyper.terms(chunk)#
            if (length(terms) == 3) {#
                ## Build the new relationship#
                weight <- calc.fo.weights(oldformula, terms[1], ratios[ratio.ii], datas[[data.ii]]) # use original data#
                extras <- make.hyper.rows(terms[1], terms[2], weight, datas[[data.ii]])#
#
                ## Done with this ratio#
                ratio.ii <- ratio.ii + 1#
#
                ## Create indicators for nonhyper, if not already done#
                if (terms[1] %in% data)#
                    data <- replace.factor(terms[1], data, 1, sep=sep)#
#
                data <- combine.data.frames(data, extras)#
            } else {#
                ## Add in the next formula#
                data.ii <- data.ii + 1#
                data <- combine.data.frame(data, datas[[data.ii]])#
            }#
#
            ## Have any of the terms in the formula been factorized?#
            print("checking")#
            checks <- get.formula.terms(formula)#
            for (check in checks) {#
                if (grepl(':', check)) {#
                    for (subterm in split.interaction.term(check))#
                        if (subterm %in% names(olddata) && !(subterm %in% names(data)) && !is.numeric(olddata[, subterm])) {#
                            print(subterm)#
                            formula <- replace.factor.formula(subterm, formula, olddata)#
                            print(formula)#
                        }#
                } else {#
                    if (check %in% names(olddata) && !(check %in% names(data)) && !is.numeric(olddata[, check]))#
                        formula <- replace.factor.formula(check, formula, olddata)#
                }#
            }#
        }#
    }#
#
    print(head(data))#
    print(tail(data))#
    print(formula)#
    lm(formula, data=data)#
}
hierlm(Sepal.Length ~ 0 + Petal.Length + Species + Sepal.Width : Species | Species - . | Sepal.Width : Species - ., iris, c(1, 2))
#' Fit an hierarchical model#
#'#
#' Interpret a hierarchical formula and fit it with the given data and weight ratios.#
#'#
#' @param formula an hierlm-style formula#
#' @param datas a data frame or a list of data frames, for each lm-style formula contained in the hierlm#
#' @param ratios a vector a ratios for the effect of fictional#
#'   observations, with length as large as the number of hyper#
#'   expressions.#
#' @return A fitted lm model#
#' @examples#
#' hierlm(Sepal.Length ~ 0 + Petal.Length + Species + Sepal.Width : Species | Species - ., iris, 1)#
#' hierlm(Sepal.Length ~ 0 + Petal.Length + Species + Sepal.Width : Species | Species - . | Sepal.Width : Species - ., iris, c(1, 2))#
#
hierlm <- function(formula, datas, ratios, sep="") {#
    if (is.data.frame(datas))#
        datas <- list(datas)#
#
    data.ii <- 1#
    ratio.ii <- 1#
#
    data <- datas[[data.ii]]#
#
    ## Split the formula by |#
    labels <- attr(terms(formula), 'term.labels')#
    if (length(labels) == 1) { # otherwise it's just an lm formula#
        lhs <- as.character(formula)[2]#
        chunks <- strsplit(labels, "\\|")[[1]]#
        formula <- as.formula(paste(lhs, "~", chunks[1]), env=attr(formula, '.Environment'))#
        ## Keep this for weight calculations#
        oldformula <- formula#
        for (chunk in chunks[-1]) {#
            ## Make the new formula#
            formula <- combine.formulae(formula, chunk)#
            if (!("constant" %in% names(data)) && "constant" %in% get.formula.terms(formula))#
                data$constant <- 1#
#
            terms <- get.hyper.terms(chunk)#
            if (length(terms) == 3) {#
                ## Build the new relationship#
                weight <- calc.fo.weights(oldformula, terms[1], ratios[ratio.ii], datas[[data.ii]]) # use original data#
                extras <- make.hyper.rows(terms[1], terms[2], weight, datas[[data.ii]])#
#
                ## Done with this ratio#
                ratio.ii <- ratio.ii + 1#
#
                ## Create indicators for nonhyper, if not already done#
                if (terms[1] %in% data)#
                    data <- replace.factor(terms[1], data, 1, sep=sep)#
#
                data <- combine.data.frames(data, extras)#
            } else {#
                ## Add in the next formula#
                data.ii <- data.ii + 1#
                data <- combine.data.frame(data, datas[[data.ii]])#
            }#
#
            ## Have any of the terms in the formula been factorized?#
            print("checking")#
            checks <- get.formula.terms(formula)#
            for (check in checks) {#
                if (grepl(':', check)) {#
                    for (subterm in split.interaction.term(check))#
                        if (subterm %in% names(datas[[data.ii]]) && !(subterm %in% names(data)) && !is.numeric(datas[[data.ii]][, subterm])) {#
                            print(subterm)#
                            formula <- replace.factor.formula(subterm, formula, datas[[data.ii]])#
                            print(formula)#
                        }#
                } else {#
                    if (check %in% names(datas[[data.ii]]) && !(check %in% names(data)) && !is.numeric(datas[[data.ii]][, check]))#
                        formula <- replace.factor.formula(check, formula, datas[[data.ii]])#
                }#
            }#
        }#
    }#
#
    print(head(data))#
    print(tail(data))#
    print(formula)#
    lm(formula, data=data)#
}
hierlm(Sepal.Length ~ 0 + Petal.Length + Species + Sepal.Width : Species | Species - . | Sepal.Width : Species - ., iris, c(1, 2))
#' Fit an hierarchical model#
#'#
#' Interpret a hierarchical formula and fit it with the given data and weight ratios.#
#'#
#' @param formula an hierlm-style formula#
#' @param datas a data frame or a list of data frames, for each lm-style formula contained in the hierlm#
#' @param ratios a vector a ratios for the effect of fictional#
#'   observations, with length as large as the number of hyper#
#'   expressions.#
#' @return A fitted lm model#
#' @examples#
#' hierlm(Sepal.Length ~ 0 + Petal.Length + Species + Sepal.Width : Species | Species - ., iris, 1)#
#' hierlm(Sepal.Length ~ 0 + Petal.Length + Species + Sepal.Width : Species | Species - . | Sepal.Width : Species - ., iris, c(1, 2))#
#
hierlm <- function(formula, datas, ratios, sep="") {#
    if (is.data.frame(datas))#
        datas <- list(datas)#
#
    data.ii <- 1#
    ratio.ii <- 1#
#
    data <- datas[[data.ii]]#
#
    ## Split the formula by |#
    labels <- attr(terms(formula), 'term.labels')#
    if (length(labels) == 1) { # otherwise it's just an lm formula#
        lhs <- as.character(formula)[2]#
        chunks <- strsplit(labels, "\\|")[[1]]#
        formula <- as.formula(paste(lhs, "~", chunks[1]), env=attr(formula, '.Environment'))#
        ## Keep this for weight calculations#
        oldformula <- formula#
        for (chunk in chunks[-1]) {#
            ## Make the new formula#
            formula <- combine.formulae(formula, chunk)#
            if (!("constant" %in% names(data)) && "constant" %in% get.formula.terms(formula))#
                data$constant <- 1#
#
            terms <- get.hyper.terms(chunk)#
            if (length(terms) == 3) {#
                ## Build the new relationship#
                weight <- calc.fo.weights(oldformula, terms[1], ratios[ratio.ii], datas[[data.ii]]) # use original data#
                print(weight)#
                extras <- make.hyper.rows(terms[1], terms[2], weight, datas[[data.ii]])#
#
                ## Done with this ratio#
                ratio.ii <- ratio.ii + 1#
#
                ## Create indicators for nonhyper, if not already done#
                if (terms[1] %in% data)#
                    data <- replace.factor(terms[1], data, 1, sep=sep)#
#
                data <- combine.data.frames(data, extras)#
            } else {#
                ## Add in the next formula#
                data.ii <- data.ii + 1#
                data <- combine.data.frame(data, datas[[data.ii]])#
            }#
#
            ## Have any of the terms in the formula been factorized?#
            checks <- get.formula.terms(formula)#
            for (check in checks) {#
                if (grepl(':', check)) {#
                    for (subterm in split.interaction.term(check))#
                        if (subterm %in% names(datas[[data.ii]]) && !(subterm %in% names(data)) && !is.numeric(datas[[data.ii]][, subterm]))#
                            formula <- replace.factor.formula(subterm, formula, datas[[data.ii]])#
                } else {#
                    if (check %in% names(datas[[data.ii]]) && !(check %in% names(data)) && !is.numeric(datas[[data.ii]][, check]))#
                        formula <- replace.factor.formula(check, formula, datas[[data.ii]])#
                }#
            }#
        }#
    }#
#
    print(head(data))#
    print(tail(data))#
    print(formula)#
    lm(formula, data=data)#
}
hierlm(Sepal.Length ~ 0 + Petal.Length + Species + Sepal.Width : Species | Species - . | Sepal.Width : Species - ., iris, c(1, 2))
#' Fit an hierarchical model#
#'#
#' Interpret a hierarchical formula and fit it with the given data and weight ratios.#
#'#
#' @param formula an hierlm-style formula#
#' @param datas a data frame or a list of data frames, for each lm-style formula contained in the hierlm#
#' @param ratios a vector a ratios for the effect of fictional#
#'   observations, with length as large as the number of hyper#
#'   expressions.#
#' @return A fitted lm model#
#' @examples#
#' hierlm(Sepal.Length ~ 0 + Petal.Length + Species + Sepal.Width : Species | Species - ., iris, 1)#
#' hierlm(Sepal.Length ~ 0 + Petal.Length + Species + Sepal.Width : Species | Species - . | Sepal.Width : Species - ., iris, c(1, 2))#
#
hierlm <- function(formula, datas, ratios, sep="") {#
    if (is.data.frame(datas))#
        datas <- list(datas)#
#
    data.ii <- 1#
    ratio.ii <- 1#
#
    data <- datas[[data.ii]]#
#
    ## Split the formula by |#
    labels <- attr(terms(formula), 'term.labels')#
    if (length(labels) == 1) { # otherwise it's just an lm formula#
        lhs <- as.character(formula)[2]#
        chunks <- strsplit(labels, "\\|")[[1]]#
        formula <- as.formula(paste(lhs, "~", chunks[1]), env=attr(formula, '.Environment'))#
        ## Keep this for weight calculations#
        oldformula <- formula#
        for (chunk in chunks[-1]) {#
            ## Make the new formula#
            formula <- combine.formulae(formula, chunk)#
            if (!("constant" %in% names(data)) && "constant" %in% get.formula.terms(formula))#
                data$constant <- 1#
#
            terms <- get.hyper.terms(chunk)#
            if (length(terms) == 3) {#
                ## Build the new relationship#
                print(oldformula)#
                print(c(terms[1], ratios[ratio.ii]))#
                weight <- calc.fo.weights(oldformula, terms[1], ratios[ratio.ii], datas[[data.ii]]) # use original data#
                print(weight)#
                extras <- make.hyper.rows(terms[1], terms[2], weight, datas[[data.ii]])#
#
                ## Done with this ratio#
                ratio.ii <- ratio.ii + 1#
#
                ## Create indicators for nonhyper, if not already done#
                if (terms[1] %in% data)#
                    data <- replace.factor(terms[1], data, 1, sep=sep)#
#
                data <- combine.data.frames(data, extras)#
            } else {#
                ## Add in the next formula#
                data.ii <- data.ii + 1#
                data <- combine.data.frame(data, datas[[data.ii]])#
            }#
#
            ## Have any of the terms in the formula been factorized?#
            checks <- get.formula.terms(formula)#
            for (check in checks) {#
                if (grepl(':', check)) {#
                    for (subterm in split.interaction.term(check))#
                        if (subterm %in% names(datas[[data.ii]]) && !(subterm %in% names(data)) && !is.numeric(datas[[data.ii]][, subterm]))#
                            formula <- replace.factor.formula(subterm, formula, datas[[data.ii]])#
                } else {#
                    if (check %in% names(datas[[data.ii]]) && !(check %in% names(data)) && !is.numeric(datas[[data.ii]][, check]))#
                        formula <- replace.factor.formula(check, formula, datas[[data.ii]])#
                }#
            }#
        }#
    }#
#
    print(head(data))#
    print(tail(data))#
    print(formula)#
    lm(formula, data=data)#
}
hierlm(Sepal.Length ~ 0 + Petal.Length + Species + Sepal.Width : Species | Species - . | Sepal.Width : Species - ., iris, c(1, 2))
lm(Sepal.Length ~ 0 + Petal.Length + Species + Sepal.Width:Species, iris)
#' Calculate Fictional Observation Weights#
#'#
#' Determines the coeffiicients for terms in the fictional observations,#
#' to ensure a given weight relative to the normal observations.#
#'#
#' @param formula lm-style formula#
#' @param label the term to be used in fictional observations#
#' @param ratio desired ratio of observed and fictional data#
#' @param data optional data frame#
#' @return Coefficients for fictional observations#
#' @examples#
#' calc.fo.weights(Sepal.Length ~ Petal.Length + Sepal.Width : Species, "Sepal.Width:Species", 5, data=iris)#
#
calc.fo.weights <- function(formula, label, ratio, data) {#
    mod.lm <- lm(formula, data)#
    sumerr <- sum(mod.lm$residuals^2)#
#
    ## Collect the beta values for all of these#
    dummies <- substr(names(mod.lm$coefficients), 1, nchar(label)) == label#
    if (sum(dummies) == 0 && grepl(':', label)) {#
        ## Try flipping an interaction#
        subterms = split.interaction.term(label)#
        dummies <- grep(paste(subterms[2], ".*", subterms[1], sep=""), names(mod.lm$coefficients))#
    }#
    betas <- mod.lm$coefficients[dummies]#
#
    sumerr / (ratio * sum(dummies) * var(betas))#
}
hierlm(Sepal.Length ~ 0 + Petal.Length + Species + Sepal.Width : Species | Species - . | Sepal.Width : Species - ., iris, c(1, 2))
summary(hierlm(Sepal.Length ~ 0 + Petal.Length + Species + Sepal.Width : Species | Species - . | Sepal.Width : Species - ., iris, c(1, 2)))
summary(hierlm(Sepal.Length ~ 0 + Petal.Length + Species + Sepal.Width : Species | Species - ., iris, c(1, 2)))
hierlm(Sepal.Length ~ 0 + Petal.Length + Species + Sepal.Width : Species | Sepal.Width : Species - ., iris, 2)
summary(hierlm(Sepal.Length ~ 0 + Petal.Length + Species + Sepal.Width : Species | Sepal.Width : Species - ., iris, 2))
100 * exp((2 * 1:50 - 1) / 10) / exp(10)
2 * 1:50 - 1
arima
arima()
rand()
runif()
runif(1)
tt = seq(0, 8, length.out=100)
change = .0127 * tt - .0005 * tt^2
plot(tt, change)
tt = seq(0, 30, length.out=100)
change = .0127 * tt - .0005 * tt^2
plot(tt, change)
log(.75)
log(.75) / 50
sum(m[:impactedsocioeconomic, :income][150,:])
1.43804e5 / 2760.58
.01 * 52
?predict
library(rstan)
stan.code <- """#
data {#
  int<lower=0> J; // number of schools#
  real y[J]; // estimated treatment effects#
  real<lower=0> sigma[J]; // s.e. of effect estimates#
}#
parameters {#
  real mu;#
  real<lower=0> tau;#
  real eta[J];#
}#
transformed parameters {#
  real theta[J];#
  for (j in 1:J)#
    theta[j] <- mu + tau * eta[j];#
}#
model {#
  eta ~ normal(0, 1);#
  y ~ normal(theta, sigma);#
}#
"""
stan.code <- '#
data {#
  int<lower=0> J; // number of schools#
  real y[J]; // estimated treatment effects#
  real<lower=0> sigma[J]; // s.e. of effect estimates#
}#
parameters {#
  real mu;#
  real<lower=0> tau;#
  real eta[J];#
}#
transformed parameters {#
  real theta[J];#
  for (j in 1:J)#
    theta[j] <- mu + tau * eta[j];#
}#
model {#
  eta ~ normal(0, 1);#
  y ~ normal(theta, sigma);#
}#
'
schools_dat <- list(J = 8,#
                    y = c(28,  8, -3,  7, -1,  1, 18, 12),#
                    sigma = c(15, 10, 16, 11,  9, 11, 10, 18))#
#
fit <- stan(code = stan.code, data = schools_dat,#
            iter = 1000, chains = 4)
?stan
fit <- stan(model_code = stan.code, data = schools_dat,#
            iter = 1000, chains = 4)
plot(fit)
as.matrix
as.matrix(c(1, 2, 3, 4), 2, 2)
matrix(c(1, 2, 3, 4), 2, 2)
stan.code <- '#
data {#
  int<lower=0> J; // number of estimates#
  real y[J]; // estimated effects#
  real<lower=0> sigma[J]; // s.e. of effect estimates#
  int<lower=0> K; // number of coefficients#
  vector[K] portions[J];#
}#
parameters {#
  real mu[K];#
  real<lower=0> tau[K];#
  real eta[J];#
}#
transformed parameters {#
  real beta[J];#
  for (j in 1:J) {#
    beta[j] <- sum(mu * portions[j] + tau * portions[j])#
}#
model {#
  eta ~ normal(0, 1);#
  y ~ normal(beta, sigma);#
}#
'#
#
stan.dat <- list(J=2, y=c(0, 1), sigma=c(1, 1),#
                 K=2, portions=matrix(c(1, 0, .5, .5), 2, 2))#
#
fit <- stan(model_code = stan.code, data = stan.dat,#
            iter = 1000, chains = 4)
stan.code <- '#
data {#
  int<lower=0> J; // number of estimates#
  real y[J]; // estimated effects#
  real<lower=0> sigma[J]; // s.e. of effect estimates#
  int<lower=0> K; // number of coefficients#
  vector[K] portions[J];#
}#
parameters {#
  row_vector[K] mu;#
  row_vector[K]<lower=0> tau;#
  real eta[J];#
}#
transformed parameters {#
  real beta[J];#
  for (j in 1:J) {#
    beta[j] <- mu * portions[j] + tau * portions[j]#
}#
model {#
  eta ~ normal(0, 1);#
  y ~ normal(beta, sigma);#
}#
'#
#
stan.dat <- list(J=2, y=c(0, 1), sigma=c(1, 1),#
                 K=2, portions=matrix(c(1, 0, .5, .5), 2, 2))#
#
fit <- stan(model_code = stan.code, data = stan.dat,#
            iter = 1000, chains = 4)
stan.code <- '#
data {#
  int<lower=0> J; // number of estimates#
  real y[J]; // estimated effects#
  real<lower=0> sigma[J]; // s.e. of effect estimates#
  int<lower=0> K; // number of coefficients#
  vector[K] portions[J];#
}#
parameters {#
  row_vector[K] mu;#
  row_vector<lower=0>[K] tau;#
  real eta[J];#
}#
transformed parameters {#
  real beta[J];#
  for (j in 1:J) {#
    beta[j] <- mu * portions[j] + tau * portions[j]#
}#
model {#
  eta ~ normal(0, 1);#
  y ~ normal(beta, sigma);#
}#
'#
#
stan.dat <- list(J=2, y=c(0, 1), sigma=c(1, 1),#
                 K=2, portions=matrix(c(1, 0, .5, .5), 2, 2))#
#
fit <- stan(model_code = stan.code, data = stan.dat,#
            iter = 1000, chains = 4)
stan.code <- '#
data {#
  int<lower=0> J; // number of estimates#
  real y[J]; // estimated effects#
  real<lower=0> sigma[J]; // s.e. of effect estimates#
  int<lower=0> K; // number of coefficients#
  vector[K] portions[J];#
}#
parameters {#
  row_vector[K] mu;#
  row_vector<lower=0>[K] tau;#
  real eta[J];#
}#
transformed parameters {#
  real beta[J];#
  for (j in 1:J) {#
    beta[j] <- mu * portions[j] + tau * portions[j];#
}#
model {#
  eta ~ normal(0, 1);#
  y ~ normal(beta, sigma);#
}#
'#
#
stan.dat <- list(J=2, y=c(0, 1), sigma=c(1, 1),#
                 K=2, portions=matrix(c(1, 0, .5, .5), 2, 2))#
#
fit <- stan(model_code = stan.code, data = stan.dat,#
            iter = 1000, chains = 4)
stan.code <- '#
data {#
  int<lower=0> J; // number of estimates#
  real y[J]; // estimated effects#
  real<lower=0> sigma[J]; // s.e. of effect estimates#
  int<lower=0> K; // number of coefficients#
  vector[K] portions[J];#
}#
parameters {#
  row_vector[K] mu;#
  row_vector<lower=0>[K] tau;#
  real eta[J];#
}#
transformed parameters {#
  real beta[J];#
  for (j in 1:J)#
    beta[j] <- mu * portions[j] + tau * portions[j];#
}#
model {#
  eta ~ normal(0, 1);#
  y ~ normal(beta, sigma);#
}#
'#
#
stan.dat <- list(J=2, y=c(0, 1), sigma=c(1, 1),#
                 K=2, portions=matrix(c(1, 0, .5, .5), 2, 2))#
#
fit <- stan(model_code = stan.code, data = stan.dat,#
            iter = 1000, chains = 4)
plot(fit)
la <- extract(fit, permute=T)
names(la)
mean(la$mu)
dims(la$mu)
dim(la$mu)
colMeans(la$mu)
stan.dat <- list(J=3, y=c(0, 1, 0), sigma=c(1, 1, 2),#
                 protions=matrix(c(1, 1, 1), 3, 1))#
#
fit <- stan(model_code = stan.code, data = stan.dat,#
            iter = 1000, chains = 4)
stan.dat <- list(J=3, y=c(0, 1, 0), sigma=c(1, 1, 2),#
                 K=1, protions=matrix(c(1, 1, 1), 3, 1))#
#
fit <- stan(model_code = stan.code, data = stan.dat,#
            iter = 1000, chains = 4)
stan.dat
stan.dat <- list(J=3, y=c(0, 1, 0), sigma=c(1, 1, 2),#
                 K=1, portions=matrix(c(1, 1, 1), 3, 1))#
#
fit <- stan(model_code = stan.code, data = stan.dat,#
            iter = 1000, chains = 4)
la <- extract(fit, permute=T)#
colMeans(la$mu)
plot(fit)
stan.code <- '#
data {#
  int<lower=0> J; // number of estimates#
  real y[J]; // estimated effects#
  real<lower=0> sigma[J]; // s.e. of effect estimates#
  int<lower=0> K; // number of coefficients#
  vector[K] portions[J];#
}#
parameters {#
  row_vector[K] mu;#
  row_vector<lower=0>[K] tau;#
  real eta[J];#
}#
transformed parameters {#
  real beta[J];#
  for (j in 1:J)#
    beta[j] <- mu * portions[j] + tau * portions[j] * eta[j];#
}#
model {#
  eta ~ normal(0, 1);#
  y ~ normal(beta, sigma);#
}#
'#
#
##stan.dat <- list(J=2, y=c(0, 1), sigma=c(1, 1),#
##                 K=2, portions=matrix(c(1, 0, .5, .5), 2, 2))#
#
stan.dat <- list(J=3, y=c(0, 1, 0), sigma=c(1, 1, 2),#
                 K=1, portions=matrix(c(1, 1, 1), 3, 1))#
#
fit <- stan(model_code = stan.code, data = stan.dat,#
            iter = 1000, chains = 4)
plot(fit)
colMeans(la$mu)
names(la)
colMeans(la$beta)
?colMeans
colStds(la$beta)
la$beta
names(la)
la$eta[1:10,]
?stan
stan.dat <- list(J=2, y=c(0, 1), sigma=c(1, 1),#
                 K=2, portions=matrix(c(1, 0, .5, .5), 2, 2))
fit <- stan(fit=fit, data = stan.dat,#
            iter = 1000, chains = 4)
plot(fit)
colMeans(la$mu)
la <- extract(fit, permute=T)#
colMeans(la$mu)
stan.dat <- list(J=2, y=c(0, 1), sigma=c(1, 1),#
                 K=2, portions=matrix(c(1, .5, 0, .5), 2, 2))#
#
##stan.dat <- list(J=3, y=c(0, 1, 0), sigma=c(1, 1, 2),#
##                 K=1, portions=matrix(c(1, 1, 1), 3, 1))#
#
##fit <- stan(model_code = stan.code, data = stan.dat,#
##            iter = 1000, chains = 4)#
#
fit <- stan(fit=fit, data = stan.dat,#
            iter = 1000, chains = 4)
la <- extract(fit, permute=T)#
colMeans(la$mu)
plot(fit)
matrix(c(1, .5, 0, .5), 2, 2)
?image
library(foreign)#
xx = read.dta("~/groups/aggregator/trunk/acra/crops/NASS_1950_2005_from_wolfram.dta")
xx[1,]
library(PBSmapping)
?PBSmapping
setwd("~/projects/coffee/tools/climate")#
#
library(ggplot2)#
library(grid)#
library(xtable)#
#
filename <- "tropics.csv" # "colombia.csv"#
add.baseline <- T#
#
# Multiple plot function#
##
# ggplot objects can be passed in ..., or to plotlist (as a list of ggplot objects)#
# - cols:   Number of columns in layout#
# - layout: A matrix specifying the layout. If present, 'cols' is ignored.#
##
# If the layout is something like matrix(c(1,2,3,3), nrow=2, byrow=TRUE),#
# then plot 1 will go in the upper left, 2 will go in the upper right, and#
# 3 will go all the way across the bottom.#
##
multiplot <- function(..., plotlist=NULL, file, cols=1, layout=NULL) {#
  require(grid)#
#
  # Make a list from the ... arguments and plotlist#
  plots <- c(list(...), plotlist)#
#
  numPlots = length(plots)#
#
  # If layout is NULL, then use 'cols' to determine layout#
  if (is.null(layout)) {#
    # Make the panel#
    # ncol: Number of columns of plots#
    # nrow: Number of rows needed, calculated from # of cols#
    layout <- matrix(seq(1, cols * ceiling(numPlots/cols)),#
                    ncol = cols, nrow = ceiling(numPlots/cols))#
  }#
#
 if (numPlots==1) {#
    print(plots[[1]])#
#
  } else {#
    # Set up the page#
    grid.newpage()#
    pushViewport(viewport(layout = grid.layout(nrow(layout), ncol(layout))))#
#
    # Make each plot, in the correct location#
    for (i in 1:numPlots) {#
      # Get the i,j matrix positions of the regions that contain this subplot#
      matchidx <- as.data.frame(which(layout == i, arr.ind = TRUE))#
#
      print(plots[[i]], vp = viewport(layout.pos.row = matchidx$row,#
                                      layout.pos.col = matchidx$col))#
    }#
  }#
}
data <- read.csv(filename)#
#
seq(0, 1, length.out=17)[c(5, 13)]#
display <- data.frame(biovar=data$biovar, baseline=data$baseline, median=data$median, p25=NA, p75=NA)#
display[1, c('p25', 'p75')] <- sort(data[1, 4:20])[c(5, 13)]#
display[2, c('p25', 'p75')] <- sort(data[2, 4:20])[c(5, 13)]#
display$median[3] <- 100 * data$median[3] / data$baseline[3]#
display[3, c('p25', 'p75')] <- 100 * sort(data[3, 4:20])[c(5, 13)] / data$baseline[3]#
display[4, c('p25', 'p75')] <- sort(data[4, 4:20])[c(5, 13)]#
display[5, c('p25', 'p75')] <- sort(data[5, 4:20])[c(5, 13)]#
display$median[6] <- 100 * data$median[6] / data$baseline[6]#
display[6, c('p25', 'p75')] <- 100 * sort(data[6, 4:20])[c(5, 13)] / data$baseline[6]#
display$median[7] <- 100 * data$median[7] / data$baseline[7]#
display[7, c('p25', 'p75')] <- 100 * sort(data[7, 4:20])[c(5, 13)] / data$baseline[7]#
display$median[8] <- 100 * data$median[8] / data$baseline[8]#
display[8, c('p25', 'p75')] <- 100 * sort(data[8, 4:20])[c(5, 13)] / data$baseline[8]#
#
names(display) <- c("Quantity", "Baseline", "Change", "25 pct.", "75 pct.")#
print(xtable(display, digits=1), include.rownames=F)#
#
if (add.baseline) {#
    for (ii in 1:nrow(data))#
        data[ii, 3:20] <- data[ii, 3:20] + data$baseline[ii]#
}#
#
p1 <- ggplot(data.frame(x=as.numeric(data[1, 4:20]) + .05 * rnorm(17)), aes(x=x)) +#
    geom_density(alpha=.2, fill="#FF6666") + geom_rug() + geom_vline(colour='red', xintercept=data$baseline[1]) +#
xlab("Annual Mean Temperature (°C)") + ylab("") + theme(plot.margin=unit(c(.5,.5,-.1,.5), "cm"))#
#
p2 <- ggplot(data.frame(x=as.numeric(data[2, 4:20]) + .05 * rnorm(17)), aes(x=x)) +#
    geom_density(alpha=.2, fill="#FF6666") + geom_rug() + geom_vline(colour='red', xintercept=data$baseline[2]) +#
xlab("Mean Diurnal Range (°C)") + ylab("") + theme(plot.margin=unit(c(.5,.5,-.1,.5), "cm"))#
#
## divide by 100#
p3 <- ggplot(data.frame(x=as.numeric(data[3, 4:20]) / 100 + .05 * rnorm(17)), aes(x=x)) +#
    geom_density(alpha=.2, fill="#FF6666") + geom_rug() + geom_vline(colour='red', xintercept=data$baseline[3] / 100) +#
xlab("Temperature Seasonality (%)") + ylab("") + theme(plot.margin=unit(c(.5,.5,-.1,.5), "cm"))#
#
p4 <- ggplot(data.frame(x=as.numeric(data[4, 4:20]) + .05 * rnorm(17)), aes(x=x)) +#
    geom_density(alpha=.2, fill="#FF6666") + geom_rug() + geom_vline(colour='red', xintercept=data$baseline[4]) +#
xlab("Max Temperature of Warmest Month (°C)") + ylab("") + theme(plot.margin=unit(c(.5,.5,-.1,.5), "cm"))#
#
p5 <- ggplot(data.frame(x=as.numeric(data[5, 4:20]) + .05 * rnorm(17)), aes(x=x)) +#
    geom_density(alpha=.2, fill="#FF6666") + geom_rug() + geom_vline(colour='red', xintercept=data$baseline[5]) +#
xlab("Min Temperature of Coldest Month (°C)") + ylab("") + theme(plot.margin=unit(c(.5,.5,-.1,.5), "cm"))#
#
p6 <- ggplot(data.frame(x=as.numeric(data[6, 4:20]) + .05 * rnorm(17)), aes(x=x)) +#
    geom_density(alpha=.2, fill="#FF6666") + geom_rug() + geom_vline(colour='red', xintercept=data$baseline[6]) +#
xlab("Annual Precipitation (mm)") + ylab("") + theme(plot.margin=unit(c(.5,.5,-.1,.5), "cm"))#
#
p7 <- ggplot(data.frame(x=as.numeric(data[7, 4:20]) + .05 * rnorm(17)), aes(x=x)) +#
    geom_density(alpha=.2, fill="#FF6666") + geom_rug() + geom_vline(colour='red', xintercept=data$baseline[7]) +#
xlab("Precipitation of Wettest Month (mm)") + ylab("") + theme(plot.margin=unit(c(.5,.5,-.1,.5), "cm"))#
#
p8 <- ggplot(data.frame(x=as.numeric(data[8, 4:20]) + .05 * rnorm(17)), aes(x=x)) +#
    geom_density(alpha=.2, fill="#FF6666") + geom_rug() + geom_vline(colour='red', xintercept=data$baseline[8]) +#
xlab("Precipitation of Driest Month (mm)") + ylab("") + theme(plot.margin=unit(c(.5,.5,-.1,.5), "cm"))#
#
multiplot(p1, p4, p5, p2, p6, p7, p8, p3, cols=2)
p1 <- ggplot(data.frame(x=as.numeric(data[1, 4:20]) + .05 * rnorm(17)), aes(x=x)) +#
    geom_density(alpha=.2, fill="#FF6666") + geom_rug() + geom_vline(colour='red', xintercept=data$baseline[1]) +#
xlab("Annual Mean Temperature (°C)") + ylab("density") + theme(plot.margin=unit(c(.5,.5,-.1,.5), "cm"))#
#
p2 <- ggplot(data.frame(x=as.numeric(data[2, 4:20]) + .05 * rnorm(17)), aes(x=x)) +#
    geom_density(alpha=.2, fill="#FF6666") + geom_rug() + geom_vline(colour='red', xintercept=data$baseline[2]) +#
xlab("Mean Diurnal Range (°C)") + ylab("density") + theme(plot.margin=unit(c(.5,.5,-.1,.5), "cm"))#
#
## divide by 100#
p3 <- ggplot(data.frame(x=as.numeric(data[3, 4:20]) / 100 + .05 * rnorm(17)), aes(x=x)) +#
    geom_density(alpha=.2, fill="#FF6666") + geom_rug() + geom_vline(colour='red', xintercept=data$baseline[3] / 100) +#
xlab("Temperature Seasonality (%)") + ylab("density") + theme(plot.margin=unit(c(.5,.5,-.1,.5), "cm"))#
#
p4 <- ggplot(data.frame(x=as.numeric(data[4, 4:20]) + .05 * rnorm(17)), aes(x=x)) +#
    geom_density(alpha=.2, fill="#FF6666") + geom_rug() + geom_vline(colour='red', xintercept=data$baseline[4]) +#
xlab("Max Temperature of Warmest Month (°C)") + ylab("density") + theme(plot.margin=unit(c(.5,.5,-.1,.5), "cm"))#
#
p5 <- ggplot(data.frame(x=as.numeric(data[5, 4:20]) + .05 * rnorm(17)), aes(x=x)) +#
    geom_density(alpha=.2, fill="#FF6666") + geom_rug() + geom_vline(colour='red', xintercept=data$baseline[5]) +#
xlab("Min Temperature of Coldest Month (°C)") + ylab("density") + theme(plot.margin=unit(c(.5,.5,-.1,.5), "cm"))#
#
p6 <- ggplot(data.frame(x=as.numeric(data[6, 4:20]) + .05 * rnorm(17)), aes(x=x)) +#
    geom_density(alpha=.2, fill="#FF6666") + geom_rug() + geom_vline(colour='red', xintercept=data$baseline[6]) +#
xlab("Annual Precipitation (mm)") + ylab("density") + theme(plot.margin=unit(c(.5,.5,-.1,.5), "cm"))#
#
p7 <- ggplot(data.frame(x=as.numeric(data[7, 4:20]) + .05 * rnorm(17)), aes(x=x)) +#
    geom_density(alpha=.2, fill="#FF6666") + geom_rug() + geom_vline(colour='red', xintercept=data$baseline[7]) +#
xlab("Precipitation of Wettest Month (mm)") + ylab("density") + theme(plot.margin=unit(c(.5,.5,-.1,.5), "cm"))#
#
p8 <- ggplot(data.frame(x=as.numeric(data[8, 4:20]) + .05 * rnorm(17)), aes(x=x)) +#
    geom_density(alpha=.2, fill="#FF6666") + geom_rug() + geom_vline(colour='red', xintercept=data$baseline[8]) +#
xlab("Precipitation of Driest Month (mm)") + ylab("density") + theme(plot.margin=unit(c(.5,.5,-.1,.5), "cm"))#
#
multiplot(p1, p4, p5, p2, p6, p7, p8, p3, cols=2)
filename <- "colombia.csv" #"tropics.csv"#
add.baseline <- T#
#
# Multiple plot function#
##
# ggplot objects can be passed in ..., or to plotlist (as a list of ggplot objects)#
# - cols:   Number of columns in layout#
# - layout: A matrix specifying the layout. If present, 'cols' is ignored.#
##
# If the layout is something like matrix(c(1,2,3,3), nrow=2, byrow=TRUE),#
# then plot 1 will go in the upper left, 2 will go in the upper right, and#
# 3 will go all the way across the bottom.#
##
multiplot <- function(..., plotlist=NULL, file, cols=1, layout=NULL) {#
  require(grid)#
#
  # Make a list from the ... arguments and plotlist#
  plots <- c(list(...), plotlist)#
#
  numPlots = length(plots)#
#
  # If layout is NULL, then use 'cols' to determine layout#
  if (is.null(layout)) {#
    # Make the panel#
    # ncol: Number of columns of plots#
    # nrow: Number of rows needed, calculated from # of cols#
    layout <- matrix(seq(1, cols * ceiling(numPlots/cols)),#
                    ncol = cols, nrow = ceiling(numPlots/cols))#
  }#
#
 if (numPlots==1) {#
    print(plots[[1]])#
#
  } else {#
    # Set up the page#
    grid.newpage()#
    pushViewport(viewport(layout = grid.layout(nrow(layout), ncol(layout))))#
#
    # Make each plot, in the correct location#
    for (i in 1:numPlots) {#
      # Get the i,j matrix positions of the regions that contain this subplot#
      matchidx <- as.data.frame(which(layout == i, arr.ind = TRUE))#
#
      print(plots[[i]], vp = viewport(layout.pos.row = matchidx$row,#
                                      layout.pos.col = matchidx$col))#
    }#
  }#
}#
#
data <- read.csv(filename)#
#
seq(0, 1, length.out=17)[c(5, 13)]#
display <- data.frame(biovar=data$biovar, baseline=data$baseline, median=data$median, p25=NA, p75=NA)#
display[1, c('p25', 'p75')] <- sort(data[1, 4:20])[c(5, 13)]#
display[2, c('p25', 'p75')] <- sort(data[2, 4:20])[c(5, 13)]#
display$median[3] <- 100 * data$median[3] / data$baseline[3]#
display[3, c('p25', 'p75')] <- 100 * sort(data[3, 4:20])[c(5, 13)] / data$baseline[3]#
display[4, c('p25', 'p75')] <- sort(data[4, 4:20])[c(5, 13)]#
display[5, c('p25', 'p75')] <- sort(data[5, 4:20])[c(5, 13)]#
display$median[6] <- 100 * data$median[6] / data$baseline[6]#
display[6, c('p25', 'p75')] <- 100 * sort(data[6, 4:20])[c(5, 13)] / data$baseline[6]#
display$median[7] <- 100 * data$median[7] / data$baseline[7]#
display[7, c('p25', 'p75')] <- 100 * sort(data[7, 4:20])[c(5, 13)] / data$baseline[7]#
display$median[8] <- 100 * data$median[8] / data$baseline[8]#
display[8, c('p25', 'p75')] <- 100 * sort(data[8, 4:20])[c(5, 13)] / data$baseline[8]#
#
names(display) <- c("Quantity", "Baseline", "Change", "25 pct.", "75 pct.")#
print(xtable(display, digits=1), include.rownames=F)#
#
if (add.baseline) {#
    for (ii in 1:nrow(data))#
        data[ii, 3:20] <- data[ii, 3:20] + data$baseline[ii]#
}#
#
p1 <- ggplot(data.frame(x=as.numeric(data[1, 4:20]) + .05 * rnorm(17)), aes(x=x)) +#
    geom_density(alpha=.2, fill="#FF6666") + geom_rug() + geom_vline(colour='red', xintercept=data$baseline[1]) +#
xlab("Annual Mean Temperature (°C)") + ylab("density") + theme(plot.margin=unit(c(.5,.5,-.1,.5), "cm"))#
#
p2 <- ggplot(data.frame(x=as.numeric(data[2, 4:20]) + .05 * rnorm(17)), aes(x=x)) +#
    geom_density(alpha=.2, fill="#FF6666") + geom_rug() + geom_vline(colour='red', xintercept=data$baseline[2]) +#
xlab("Mean Diurnal Range (°C)") + ylab("density") + theme(plot.margin=unit(c(.5,.5,-.1,.5), "cm"))#
#
## divide by 100#
p3 <- ggplot(data.frame(x=as.numeric(data[3, 4:20]) / 100 + .05 * rnorm(17)), aes(x=x)) +#
    geom_density(alpha=.2, fill="#FF6666") + geom_rug() + geom_vline(colour='red', xintercept=data$baseline[3] / 100) +#
xlab("Temperature Seasonality (%)") + ylab("density") + theme(plot.margin=unit(c(.5,.5,-.1,.5), "cm"))#
#
p4 <- ggplot(data.frame(x=as.numeric(data[4, 4:20]) + .05 * rnorm(17)), aes(x=x)) +#
    geom_density(alpha=.2, fill="#FF6666") + geom_rug() + geom_vline(colour='red', xintercept=data$baseline[4]) +#
xlab("Max Temperature of Warmest Month (°C)") + ylab("density") + theme(plot.margin=unit(c(.5,.5,-.1,.5), "cm"))#
#
p5 <- ggplot(data.frame(x=as.numeric(data[5, 4:20]) + .05 * rnorm(17)), aes(x=x)) +#
    geom_density(alpha=.2, fill="#FF6666") + geom_rug() + geom_vline(colour='red', xintercept=data$baseline[5]) +#
xlab("Min Temperature of Coldest Month (°C)") + ylab("density") + theme(plot.margin=unit(c(.5,.5,-.1,.5), "cm"))#
#
p6 <- ggplot(data.frame(x=as.numeric(data[6, 4:20]) + .05 * rnorm(17)), aes(x=x)) +#
    geom_density(alpha=.2, fill="#FF6666") + geom_rug() + geom_vline(colour='red', xintercept=data$baseline[6]) +#
xlab("Annual Precipitation (mm)") + ylab("density") + theme(plot.margin=unit(c(.5,.5,-.1,.5), "cm"))#
#
p7 <- ggplot(data.frame(x=as.numeric(data[7, 4:20]) + .05 * rnorm(17)), aes(x=x)) +#
    geom_density(alpha=.2, fill="#FF6666") + geom_rug() + geom_vline(colour='red', xintercept=data$baseline[7]) +#
xlab("Precipitation of Wettest Month (mm)") + ylab("density") + theme(plot.margin=unit(c(.5,.5,-.1,.5), "cm"))#
#
p8 <- ggplot(data.frame(x=as.numeric(data[8, 4:20]) + .05 * rnorm(17)), aes(x=x)) +#
    geom_density(alpha=.2, fill="#FF6666") + geom_rug() + geom_vline(colour='red', xintercept=data$baseline[8]) +#
xlab("Precipitation of Driest Month (mm)") + ylab("density") + theme(plot.margin=unit(c(.5,.5,-.1,.5), "cm"))#
#
multiplot(p1, p4, p5, p2, p6, p7, p8, p3, cols=2)
data
filename
data <- read.csv(filename)
data
seq(0, 1, length.out=17)[c(5, 13)]#
display <- data.frame(biovar=data$biovar, baseline=data$baseline, median=data$median, p25=NA, p75=NA)#
display[1, c('p25', 'p75')] <- sort(data[1, 4:20])[c(5, 13)]#
display[2, c('p25', 'p75')] <- sort(data[2, 4:20])[c(5, 13)]#
display$median[3] <- 100 * data$median[3] / data$baseline[3]#
display[3, c('p25', 'p75')] <- 100 * sort(data[3, 4:20])[c(5, 13)] / data$baseline[3]#
display[4, c('p25', 'p75')] <- sort(data[4, 4:20])[c(5, 13)]#
display[5, c('p25', 'p75')] <- sort(data[5, 4:20])[c(5, 13)]#
display$median[6] <- 100 * data$median[6] / data$baseline[6]#
display[6, c('p25', 'p75')] <- 100 * sort(data[6, 4:20])[c(5, 13)] / data$baseline[6]#
display$median[7] <- 100 * data$median[7] / data$baseline[7]#
display[7, c('p25', 'p75')] <- 100 * sort(data[7, 4:20])[c(5, 13)] / data$baseline[7]#
display$median[8] <- 100 * data$median[8] / data$baseline[8]#
display[8, c('p25', 'p75')] <- 100 * sort(data[8, 4:20])[c(5, 13)] / data$baseline[8]#
#
names(display) <- c("Quantity", "Baseline", "Change", "25 pct.", "75 pct.")#
print(xtable(display, digits=1), include.rownames=F)#
#
if (add.baseline) {#
    for (ii in 1:nrow(data))#
        data[ii, 3:20] <- data[ii, 3:20] + data$baseline[ii]#
}#
#
p1 <- ggplot(data.frame(x=as.numeric(data[1, 4:20]) + .05 * rnorm(17)), aes(x=x)) +#
    geom_density(alpha=.2, fill="#FF6666") + geom_rug() + geom_vline(colour='red', xintercept=data$baseline[1]) +#
xlab("Annual Mean Temperature (°C)") + ylab("density") + theme(plot.margin=unit(c(.5,.5,-.1,.5), "cm"))#
#
p2 <- ggplot(data.frame(x=as.numeric(data[2, 4:20]) + .05 * rnorm(17)), aes(x=x)) +#
    geom_density(alpha=.2, fill="#FF6666") + geom_rug() + geom_vline(colour='red', xintercept=data$baseline[2]) +#
xlab("Mean Diurnal Range (°C)") + ylab("density") + theme(plot.margin=unit(c(.5,.5,-.1,.5), "cm"))#
#
## divide by 100#
p3 <- ggplot(data.frame(x=as.numeric(data[3, 4:20]) / 100 + .05 * rnorm(17)), aes(x=x)) +#
    geom_density(alpha=.2, fill="#FF6666") + geom_rug() + geom_vline(colour='red', xintercept=data$baseline[3] / 100) +#
xlab("Temperature Seasonality (%)") + ylab("density") + theme(plot.margin=unit(c(.5,.5,-.1,.5), "cm"))#
#
p4 <- ggplot(data.frame(x=as.numeric(data[4, 4:20]) + .05 * rnorm(17)), aes(x=x)) +#
    geom_density(alpha=.2, fill="#FF6666") + geom_rug() + geom_vline(colour='red', xintercept=data$baseline[4]) +#
xlab("Max Temperature of Warmest Month (°C)") + ylab("density") + theme(plot.margin=unit(c(.5,.5,-.1,.5), "cm"))#
#
p5 <- ggplot(data.frame(x=as.numeric(data[5, 4:20]) + .05 * rnorm(17)), aes(x=x)) +#
    geom_density(alpha=.2, fill="#FF6666") + geom_rug() + geom_vline(colour='red', xintercept=data$baseline[5]) +#
xlab("Min Temperature of Coldest Month (°C)") + ylab("density") + theme(plot.margin=unit(c(.5,.5,-.1,.5), "cm"))#
#
p6 <- ggplot(data.frame(x=as.numeric(data[6, 4:20]) + .05 * rnorm(17)), aes(x=x)) +#
    geom_density(alpha=.2, fill="#FF6666") + geom_rug() + geom_vline(colour='red', xintercept=data$baseline[6]) +#
xlab("Annual Precipitation (mm)") + ylab("density") + theme(plot.margin=unit(c(.5,.5,-.1,.5), "cm"))#
#
p7 <- ggplot(data.frame(x=as.numeric(data[7, 4:20]) + .05 * rnorm(17)), aes(x=x)) +#
    geom_density(alpha=.2, fill="#FF6666") + geom_rug() + geom_vline(colour='red', xintercept=data$baseline[7]) +#
xlab("Precipitation of Wettest Month (mm)") + ylab("density") + theme(plot.margin=unit(c(.5,.5,-.1,.5), "cm"))#
#
p8 <- ggplot(data.frame(x=as.numeric(data[8, 4:20]) + .05 * rnorm(17)), aes(x=x)) +#
    geom_density(alpha=.2, fill="#FF6666") + geom_rug() + geom_vline(colour='red', xintercept=data$baseline[8]) +#
xlab("Precipitation of Driest Month (mm)") + ylab("density") + theme(plot.margin=unit(c(.5,.5,-.1,.5), "cm"))#
#
multiplot(p1, p4, p5, p2, p6, p7, p8, p3, cols=2)
data
data <- read.csv(filename)#
#
seq(0, 1, length.out=17)[c(5, 13)]#
display <- data.frame(biovar=data$biovar, baseline=data$baseline, median=data$median, p25=NA, p75=NA)#
display[1, c('p25', 'p75')] <- sort(data[1, 4:20])[c(5, 13)]#
display[2, c('p25', 'p75')] <- sort(data[2, 4:20])[c(5, 13)]#
display$median[3] <- 100 * data$median[3] / data$baseline[3]#
display[3, c('p25', 'p75')] <- 100 * sort(data[3, 4:20])[c(5, 13)] / data$baseline[3]#
display[4, c('p25', 'p75')] <- sort(data[4, 4:20])[c(5, 13)]#
display[5, c('p25', 'p75')] <- sort(data[5, 4:20])[c(5, 13)]#
display$median[6] <- 100 * data$median[6] / data$baseline[6]#
display[6, c('p25', 'p75')] <- 100 * sort(data[6, 4:20])[c(5, 13)] / data$baseline[6]#
display$median[7] <- 100 * data$median[7] / data$baseline[7]#
display[7, c('p25', 'p75')] <- 100 * sort(data[7, 4:20])[c(5, 13)] / data$baseline[7]#
display$median[8] <- 100 * data$median[8] / data$baseline[8]#
display[8, c('p25', 'p75')] <- 100 * sort(data[8, 4:20])[c(5, 13)] / data$baseline[8]
data
add.baseline <- F # T (for tropics)
data <- read.csv(filename)#
#
seq(0, 1, length.out=17)[c(5, 13)]#
display <- data.frame(biovar=data$biovar, baseline=data$baseline, median=data$median, p25=NA, p75=NA)#
display[1, c('p25', 'p75')] <- sort(data[1, 4:20])[c(5, 13)]#
display[2, c('p25', 'p75')] <- sort(data[2, 4:20])[c(5, 13)]#
display$median[3] <- 100 * data$median[3] / data$baseline[3]#
display[3, c('p25', 'p75')] <- 100 * sort(data[3, 4:20])[c(5, 13)] / data$baseline[3]#
display[4, c('p25', 'p75')] <- sort(data[4, 4:20])[c(5, 13)]#
display[5, c('p25', 'p75')] <- sort(data[5, 4:20])[c(5, 13)]#
display$median[6] <- 100 * data$median[6] / data$baseline[6]#
display[6, c('p25', 'p75')] <- 100 * sort(data[6, 4:20])[c(5, 13)] / data$baseline[6]#
display$median[7] <- 100 * data$median[7] / data$baseline[7]#
display[7, c('p25', 'p75')] <- 100 * sort(data[7, 4:20])[c(5, 13)] / data$baseline[7]#
display$median[8] <- 100 * data$median[8] / data$baseline[8]#
display[8, c('p25', 'p75')] <- 100 * sort(data[8, 4:20])[c(5, 13)] / data$baseline[8]#
#
names(display) <- c("Quantity", "Baseline", "Change", "25 pct.", "75 pct.")#
print(xtable(display, digits=1), include.rownames=F)#
#
if (add.baseline) {#
    for (ii in 1:nrow(data))#
        data[ii, 3:20] <- data[ii, 3:20] + data$baseline[ii]#
}#
#
p1 <- ggplot(data.frame(x=as.numeric(data[1, 4:20]) + .05 * rnorm(17)), aes(x=x)) +#
    geom_density(alpha=.2, fill="#FF6666") + geom_rug() + geom_vline(colour='red', xintercept=data$baseline[1]) +#
xlab("Annual Mean Temperature (°C)") + ylab("density") + theme(plot.margin=unit(c(.5,.5,-.1,.5), "cm"))#
#
p2 <- ggplot(data.frame(x=as.numeric(data[2, 4:20]) + .05 * rnorm(17)), aes(x=x)) +#
    geom_density(alpha=.2, fill="#FF6666") + geom_rug() + geom_vline(colour='red', xintercept=data$baseline[2]) +#
xlab("Mean Diurnal Range (°C)") + ylab("density") + theme(plot.margin=unit(c(.5,.5,-.1,.5), "cm"))#
#
## divide by 100#
p3 <- ggplot(data.frame(x=as.numeric(data[3, 4:20]) / 100 + .05 * rnorm(17)), aes(x=x)) +#
    geom_density(alpha=.2, fill="#FF6666") + geom_rug() + geom_vline(colour='red', xintercept=data$baseline[3] / 100) +#
xlab("Temperature Seasonality (%)") + ylab("density") + theme(plot.margin=unit(c(.5,.5,-.1,.5), "cm"))#
#
p4 <- ggplot(data.frame(x=as.numeric(data[4, 4:20]) + .05 * rnorm(17)), aes(x=x)) +#
    geom_density(alpha=.2, fill="#FF6666") + geom_rug() + geom_vline(colour='red', xintercept=data$baseline[4]) +#
xlab("Max Temperature of Warmest Month (°C)") + ylab("density") + theme(plot.margin=unit(c(.5,.5,-.1,.5), "cm"))#
#
p5 <- ggplot(data.frame(x=as.numeric(data[5, 4:20]) + .05 * rnorm(17)), aes(x=x)) +#
    geom_density(alpha=.2, fill="#FF6666") + geom_rug() + geom_vline(colour='red', xintercept=data$baseline[5]) +#
xlab("Min Temperature of Coldest Month (°C)") + ylab("density") + theme(plot.margin=unit(c(.5,.5,-.1,.5), "cm"))#
#
p6 <- ggplot(data.frame(x=as.numeric(data[6, 4:20]) + .05 * rnorm(17)), aes(x=x)) +#
    geom_density(alpha=.2, fill="#FF6666") + geom_rug() + geom_vline(colour='red', xintercept=data$baseline[6]) +#
xlab("Annual Precipitation (mm)") + ylab("density") + theme(plot.margin=unit(c(.5,.5,-.1,.5), "cm"))#
#
p7 <- ggplot(data.frame(x=as.numeric(data[7, 4:20]) + .05 * rnorm(17)), aes(x=x)) +#
    geom_density(alpha=.2, fill="#FF6666") + geom_rug() + geom_vline(colour='red', xintercept=data$baseline[7]) +#
xlab("Precipitation of Wettest Month (mm)") + ylab("density") + theme(plot.margin=unit(c(.5,.5,-.1,.5), "cm"))#
#
p8 <- ggplot(data.frame(x=as.numeric(data[8, 4:20]) + .05 * rnorm(17)), aes(x=x)) +#
    geom_density(alpha=.2, fill="#FF6666") + geom_rug() + geom_vline(colour='red', xintercept=data$baseline[8]) +#
xlab("Precipitation of Driest Month (mm)") + ylab("density") + theme(plot.margin=unit(c(.5,.5,-.1,.5), "cm"))#
#
multiplot(p1, p4, p5, p2, p6, p7, p8, p3, cols=2)
